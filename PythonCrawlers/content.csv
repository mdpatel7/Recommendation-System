,Data,Page Title,Type Of Data
0,"
",About this book,plain_text
1,"The Java Programming Wikibook is a shared effort in amassing a comprehensive guide of the complete Java platform — from programming advice and tutorials for the desktop computer to programming on mobile phones. The information presented in this book has been conceptualised with the combined efforts of various contributors, and anonymous editors.
",About this book,plain_text
2,"The primary purpose of this book is to teach the Java programming language to an audience of beginners, but its progressive layout of tutorials increasing in complexity, it can be just as helpful for intermediate and experienced programmers. Thus, this book is meant to be used as:
",About this book,plain_text
3,"a collection of tutorials building upon one another in a progressive manner;
a guidebook for efficient programming with the Java programming language; and,
a comprehensive manual resource for the advanced programmer.",About this book,plain_text
4,"This book is intended to be used in conjunction with various other online resources, such as:
",About this book,plain_text
5,"the Java platform API documentation;
the official Java website; and,
active Java communities online, such as Java.net and JavaRanch, etc.",About this book,plain_text
6,,Who should read this book?[edit],
7,"Everything you would need to know to write computer programs would be explained in this book. By the time you finish reading, you will find yourself proficient enough to tackle just about anything in Java and programs written using it. This book serves as the first few stepping stones of many you would need to cross the unfriendly waters of computer programming. We have put a lot of emphasis in structuring this book in a way that lets you start programming from scratch, with Java as your preferred language of choice. This book is designed for you if any one of the following is true.
",Who should read this book?[edit],plain_text
8,"You are relatively new to programming and have heard how easy it is to learn Java.
You had some BASIC or Pascal in school, and have a grasp of basic programming and logic.
You already know and have been introduced to programming in earlier versions of Java.
You are an experienced developer and know how to program in other languages like C++, Visual Basic, Python, Ruby, etc.
You've heard that Java is great for web applications and web services programming.",Who should read this book?[edit],plain_text
9,"Although this book is generally meant to be for readers who are beginning to learn programming, it can be highly beneficial for intermediate and advanced programmers who may have missed out on some vital information. After completing this book you should be able to solve many complicated problems using the Java skills presented in the following chapters. Once you finish, you are also encouraged to undertake ambitious programming projects of your own.
",Who should read this book?[edit],plain_text
10,"This book assumes that the reader has no prior knowledge of programming in Java, or for that matter, any object-oriented programming language. Practical examples and exercises following each topic and module make it easy to understand the software development methodology.  If you are a complete beginner, we suggest that you move slowly through this book and complete each exercise at your own pace.
",Who should read this book?[edit],plain_text
11,,How to use this book[edit],
12,"This book is a reference book of the Java language and its related technologies. Its goal is to give a complete picture of Java and its technologies.  While the book can be read from the beginning to end, it is also designed to have individual sections that can be read independently.  To help find information quickly, navigation boxes are given in the online version for access to individual topics.
",How to use this book[edit],plain_text
13,"This book is divided to sections. Pages are grouped together into section topics. To make this book expandable in the future via the addition of new sections, the sections navigation-wide are independent from each other. Each section can be considered as a mini book by itself. Pages that belong to the same topic can be navigated by the links on the right hand side.
",How to use this book[edit],plain_text
14,,How can you participate[edit],
15,"Content is constantly being updated and enhanced in this book as is the nature of wiki-based content. This book is therefore in a constant state of evolution. Any Wikibooks users can participate in helping this book to a better standard as both a reader, or a contributor.
",How can you participate[edit],plain_text
16,"If you are interested in reading the content present in this book, we encourage you to:
",How can you participate[edit],plain_text
17,"share comments about the technical accuracy, content, or organization of this book by telling the contributors in the Discussion section for each page. You can find the link Discussion on each page in this book leading you to appropriate sections for discussion. Leave a signature when providing feedback, writing comments, or giving suggestion on the Discussion pages. This can be achieved by appending -- ~~~~ to your messages. Do not add your signatures to the Book pages, they are only meant for the Discussion pages.
share news about the Java Programming Wikibook with your family and friends and let them know about this comprehensive Java guide online.
become a contributing author, if you think that you have information that could fill in some missing gaps in this book.",How can you participate[edit],plain_text
18,"If you are intent on writing content for this book, you need to do the following:
",How can you participate[edit],plain_text
19,"When writing content for this book, you can always pose as an anonymous contributor, however we recommend you sign-in into the Wikibooks website when doing so. It becomes easier to track and acknowledge changes to certain parts of the book. Furthermore, the opinions and views of logged-in users are given precedence over anonymous users.
Once you have started contributing content for this book, make sure that you add your name to the contributor list.
Be bold and try to follow the conventions for this Wikibook. It is important that the conventions for this book be followed to the letter to make content consistent and reliable throughout.",How can you participate[edit],plain_text
20,"
",How can you participate[edit],plain_text
21,"
",History of Java,plain_text
22,"On 23 May 1995, John Gage, the director of the Science Office of the Sun Microsystems along with Marc Andreesen, co-founder and executive vice president at Netscape announced to an audience of SunWorldTM that Java technology wasn't a myth and that it was going to be incorporated into Netscape Navigator.[1]
",History of Java,plain_text
23,"At the time the total number of people working on Java was less than 30.[1] This team would shape the future in the next decade and no one had any idea as to what was in store. From running an unmanned vehicle on Mars to serving as the operating environment of most consumer electronics, e.g. cable set-top boxes, VCRs, toasters and PDAs,[2] Java has come a long way from its inception. Let's see how it all began.
",History of Java,plain_text
24,,Earlier programming languages[edit],
25,"Before Java emerged as a programming language, C++ was the dominant player in the trade. The primary goal of the creators of Java was to create a language that could tackle most of the things that C++ offered while getting rid of some of the more tedious tasks that came with the earlier languages.
",Earlier programming languages[edit],plain_text
26,"Computer hardware went through a performance and price revolution from 1972 to 1991. Better, faster hardware was available at ever lower prices, and the demand for big and complex software exponentially increased. To accommodate the demand, new development technologies were invented.
",Earlier programming languages[edit],plain_text
27,"The C language developed in 1972 by Dennis Ritchie had taken a decade to become the most popular language amongst programmers working on PCs and similar platforms (other languages, like COBOL and FORTRAN, dominated the mainframe market). But, with time programmers found that programming in C became tedious with its structural syntax.[3] Although people attempted to solve this problem, it would be later that a new development philosophy was introduced, one named Object-Oriented Programming (OOP). With OOP, one can write code that can be reused later without needing to rewrite the code over and over again. In 1979, Bjarne Stroustrup developed C++, an enhancement to the C language with included OOP fundamentals and features. Sun generated revenue from Java through the selling of licenses for specialized products such as the Java Enterprise System.
",Earlier programming languages[edit],plain_text
28,,The Green team[edit],
29,"In December of 1990, a project was initiated behind closed doors with the aim to create a programming tool that could render obsolete the C and C++ programming languages. Engineer Patrick Naughton had become extremely frustrated with the state of Sun's C++ and C APIs (Application Programming Interfaces) and tools. While he was considering to move towards NeXT, he was offered a chance to work on new technology and the Stealth Project was started, a secret nobody but he knew.
",The Green team[edit],plain_text
30,"This Stealth Project was later named the Green Project when James Gosling and Mike Sheridan joined Patrick.[1] As the Green Project teethed, the prospects of the project started becoming clearer to the engineers working on it. No longer did it aim to create a new language far superior to the present ones, but it aimed to target devices other than the computer.
",The Green team[edit],plain_text
31,"Staffed at 13 people, they began work in a small office on Sand Hill Road in Menlo Park, California. This team came to be called the Green Team henceforth in time. The project they underwent was chartered by Sun Microsystems to anticipate and plan for the ""next wave"" in computing. For the team, this meant at least one significant trend, that of the convergence of digitally controlled consumer devices and computers.[1]

",The Green team[edit],plain_text
32,,Reshaping thought[edit],
33,"The team started thinking of replacing C++ with a better version, a faster version, a responsive version. But the one thing they hadn't thought of, as of yet, was that the language they were aiming for had to be developed for an embedded system with limited resources. An embedded system is a computer system scaled to a minimalistic interface demanding only a few functions from its design. For such a system, C++ or any successor would seem too large as all the languages at the time demanded a larger footprint than what was desired. The team thus had to think in a different way to go about solving all these problems.
",Reshaping thought[edit],plain_text
34,"Co-founder of Sun Microsystems, Bill Joy, envisioned a language combining the power of Mesa and C in a paper named Further he wrote for the engineers at Sun. Gathering ideas, Gosling began work on enhancing C++ and named it ""C++ ++ --"", a pun on the evolutionary structure of the language's name. The ++ and -- meant, putting in and taking out stuff. He soon abandoned the name and called it Oak[1] after the tree that stood outside his office.
",Reshaping thought[edit],plain_text
35,,"The demise of an idea, birth of another[edit]",
36,"By now, the work on Oak had been significant but come the year 1993, people saw the demise of set-top boxes, interactive TV and the PDAs. A failure that completely ushered the inventors' thoughts to be reinvented. Only a miracle could make the project a success now. And such a miracle awaited anticipation.
","The demise of an idea, birth of another[edit]",plain_text
37,"National Center for Supercomputing Applications (NCSA) had just unveiled its new commercial web browser for the internet the previous year. The focus of the team, now diverted towards where they thought the ""next-wave"" of computing would be — the internet. The team then divulged into the realms of creating the same embeddable technology to be used in the web browser space calling it an applet — a small application. Keeping all of this in mind, the team created a list of features tackling the C++ problems. In their opinion, the project should ...
","The demise of an idea, birth of another[edit]",plain_text
38,".. be simple and gather tested fundamentals and features from the earlier languages in it,
.. have standard sets of APIs with basic and advanced features bundled with the language,
.. get rid of concepts requiring direct manipulation of hardware (in this case, memory) to make the language safe,
.. be platform independent and may written for every platform once (giving birth to the WORA idiom),
.. be able to manipulate network programming out-of-the-box,
.. be embeddable in web browsers, and ...
.. have the ability for a single program to multi-task and do multiple things at the same time.","The demise of an idea, birth of another[edit]",plain_text
39,"The team now needed a proper identity and they decided on naming the new technology they created Java ushering a new generation of products for the internet boom. A by-product of the project was a cartoon named ""Duke"" created by Joe Parlang which became its identity then.
","The demise of an idea, birth of another[edit]",plain_text
40,"Finally at the SunWorldTM conference, Andreesen unveiled the new technology to the masses. Riding along with the explosion of interest and publicity in the Internet, Java quickly received widespread recognition and expectations grew for it to become the dominant software for browser and consumer applications.[2]
","The demise of an idea, birth of another[edit]",plain_text
41,"Initially Java was owned by Sun Microsystems, but later it was released to open source; the term Java was a trademark of Sun Microsystems. Sun released the source code for its HotSpot Virtual Machine and compiler in November 2006, and most of the source code of the class library in May 2007. Some parts were missing because they were owned by third parties, not by Sun Microsystems. The released parts were published under the terms of the GNU General Public License, a free software license.
","The demise of an idea, birth of another[edit]",plain_text
42,,Versions[edit],
43,"Unlike C and C++, Java's growth is pretty recent. Here, we'd quickly go through the development paths that Java took with age.
",Versions[edit],plain_text
44,"Introduced in 1996 for the Solaris, Windows, Mac OS Classic and Linux, Java was initially released as the Java Development Kit 1.0 (JDK 1.0). This included the Java runtime (the virtual machine and the class libraries), and the development tools (e.g., the Java compiler). Later, Sun also provided a runtime-only package, called the Java Runtime Environment (JRE). The first name stuck, however, so usually people refer to a particular version of Java by its JDK version (e.g., JDK 1.0).
",Versions[edit],plain_text
45,"Introduced in 1998 as a quick fix to the former versions, version 1.2 was the start of a new beginning for Java. The JDKs of version 1.2 and later versions are often called Java 2 as well. For example, the official name of JDK 1.4 is The Java(TM) 2 Platform, Standard Edition version 1.4.
",Versions[edit],plain_text
46,"Released in 8 May 2000. The most notable changes were:
",Versions[edit],plain_text
47,"HotSpot JVM included (the HotSpot JVM was first released in April, 1999 for the J2SE 1.2 JVM)
RMI was modified to support optional compatibility with CORBA
JavaSound
Java Naming and Directory Interface (JNDI) included in core libraries (previously available as an extension)
Java Platform Debugger Architecture (JPDA)
Synthetic proxy classes",Versions[edit],plain_text
48,"Released in 6 February 2002, Java 1.4 has improved programmer productivity by expanding language features and available APIs:
",Versions[edit],plain_text
49,"Assertion
Regular Expression
XML processing
Cryptography and Secure Socket Layer (SSL)
Non-blocking I/O (NIO)
Logging",Versions[edit],plain_text
50,"Released in September 2004
",Versions[edit],plain_text
51,"Released on 11 December 2006.
",Versions[edit],plain_text
52,"What's New in Java SE 6:
",Versions[edit],plain_text
53,Web Services - First-class support for writing XML web service client applications.,Versions[edit],plain_text
54,"Scripting - You can now mix in JavaScript technology source code, useful for prototyping. Also useful when you have teams with a variety of skill sets. More advanced developers can plug in their own scripting engines and mix their favorite scripting language in with Java code as they see fit.",Versions[edit],plain_text
55,"Database - No more need to find and configure your own JDBC database when developing a database application. Developers will also get the updated JDBC 4.0, a well-used API with many important improvements, such as special support for XML as an SQL datatype and better integration of Binary Large OBjects (BLOBs) and Character Large OBjects (CLOBs) into the APIs.",Versions[edit],plain_text
56,"More Desktop APIs - GUI developers get a large number of new tricks to play like the ever popular yet newly incorporated SwingWorker utility to help you with threading in GUI apps, JTable sorting and filtering, and a new facility for quick splash screens to quiet impatient users.",Versions[edit],plain_text
57,Monitoring and Management - The really big deal here is that you don't need to do anything special to the startup to be able to attach on demand with any of the monitoring and management tools in the Java SE platform.,Versions[edit],plain_text
58,"Compiler Access - Really aimed at people who create tools for Java development and for frameworks like JavaServer Pages (JSP) or Personal Home Page construction kit (PHP) engines that need to generate a bunch of classes on demand, the compiler API opens up programmatic access to javac for in-process compilation of dynamically generated Java code. The compiler API is not directly intended for the everyday developer, but for those of you deafened by your screaming inner geek, roll up your sleeves and give it a try. And the rest of us will happily benefit from the tools and the improved Java frameworks that use this.",Versions[edit],plain_text
59,"Pluggable Annotations allows programmer to write annotation processor so that it can analyse your code semantically before javac compiles. For example, you could write an annotation processor that verifies whether your program obeys naming conventions.",Versions[edit],plain_text
60,"Desktop Deployment - At long last, Java SE 6 unifies the Java Plug-in technology and Java WebStart engines, which just makes sense. Installation of the Java WebStart application got a much needed makeover.",Versions[edit],plain_text
61,"Security - Java SE 6 has simplified the job of its security administrators by providing various new ways to access platform-native security services, such as native Public Key Infrastructure (PKI) and cryptographic services on Microsoft Windows for secure authentication and communication, Java Generic Security Services (Java GSS) and Kerberos services for authentication, and access to LDAP servers for authenticating users.",Versions[edit],plain_text
62,"The -lities: Quality, Compatibility, Stability - Bug fixes ...",Versions[edit],plain_text
63,"Released on 28 July 2011.
",Versions[edit],plain_text
64,"Feature additions for Java 7 include:
",Versions[edit],plain_text
65,"JVM support for dynamic languages, following the prototyping work currently done on the Multi Language Virtual Machine
Compressed 64-bit pointers Available in Java 6 with -XX:+UseCompressedOops
Small language changes (grouped under a project named Coin):",Versions[edit],plain_text
66,"Concurrency utilities under JSR 166
New file I/O library to enhance platform independence and add support for metadata and symbolic links. The new packages are java.nio.file and java.nio.file.attribute
Library-level support for Elliptic curve cryptography algorithms
An XRender pipeline for Java 2D, which improves handling of features specific to modern GPUs
New platform APIs for the graphics features originally planned for release in Java version 6u10
Enhanced library-level support for new network protocols, including SCTP and Sockets Direct Protocol
Upstream updates to XML and Unicode",Versions[edit],plain_text
67,"Lambda (Java's implementation of lambda functions), Jigsaw (Java's implementation of modules), and part of Coin were dropped from Java 7.
",Versions[edit],plain_text
68,"Java 8 was released on 18 March 2014, and included some features that were planned for Java 7 but later deferred.
",Versions[edit],plain_text
69,"Work on features was organized in terms of JDK Enhancement Proposals (JEPs).
",Versions[edit],plain_text
70,"JSR 335, JEP 126: Language-level support for lambda expressions (officially, lambda expressions; unofficially, closures) under Project Lambda which allow the addition of methods to interfaces without breaking existing implementations. There was an ongoing debate in the Java community on whether to add support for lambda expressions. Supporting lambda expressions also allows the performance of  functional-style operations on streams of elements, such as MapReduce-inspired transformations on collections. Default methods allow an author of an API to add new methods to an interface without breaking the old code using it. Although it was not their primary intent, default methods also allow multiple inheritance of behavior (but not state).",Versions[edit],plain_text
71,"JSR 223, JEP 174: Project Nashorn, a JavaScript runtime which allows developers to embed JavaScript code within applications
JSR 308, JEP 104: Annotation on Java Types
Unsigned Integer Arithmetic
JSR 337, JEP 120: Repeating annotations
JSR 310, JEP 150: Date and Time API
JEP 178: Statically-linked JNI libraries
JEP 153: Launch JavaFX applications (direct launching of JavaFX application JARs)
JEP 122: Remove the permanent generation",Versions[edit],plain_text
72,,References[edit],
73,"
",References[edit],plain_text
74,"The new features and upgrades included into Java changed the face of programming environment and gave a new definition to Object Oriented Programming (OOP in short). But unlike its predecessors, Java needed to be bundled with standard functionality and be independent of the host platform.
",Overview of the Java programming language,plain_text
75,"The primary goals in the creation of the Java language:
",Overview of the Java programming language,plain_text
76,"It is simple.
It is object-oriented.
It is independent of the host platform.
It contains language facilities and libraries for networking.
It is designed to execute code from remote sources securely.",Overview of the Java programming language,plain_text
77,"The Java language introduces some new features that did not exist in other languages like C and C++.
",Overview of the Java programming language,plain_text
78,,Object orientation[edit],
79,"Object orientation (""OO"") refers to a method of programming and language technique. The main idea of OO is to design software around the ""things"" (i.e. objects) it manipulates, rather than the actions it performs.
",Object orientation[edit],plain_text
80,"As the hardware of the computer advanced, it brought about the need to create better software techniques to be able to create ever increasing complex applications.
The intent is to make large software projects easier to manage, thus improving quality and reducing the number of failed projects.
Object oriented solution is the latest software technique.
",Object orientation[edit],plain_text
81,,Platform dependence[edit],
82,"In C or C++ programming, you start to write a source code:



",Platform dependence[edit],plain_text
83,"... you compile it to a machine code file:




",Platform dependence[edit],plain_text
84,"... and then you execute it:





",Platform dependence[edit],plain_text
85,"In this situation, the machine code file and its execution are specific to the platform (Windows, Linux, Mac OS, ...) it was compiled for, that is to say to the targeted platform:
",Platform dependence[edit],plain_text
86,"
",Platform dependence[edit],plain_text
87,"... because the compiled file is a machine code file designed to work on a specific platform and hardware. It would have produced a different results/output for another platform. So if you want your program to run on several platforms, you have to compile your program several times:
",Platform dependence[edit],plain_text
88,"It poses greater vulnerability risks. Note here that when a certain code is compiled into an executable format, the executable cannot be changed dynamically. It would need to be recompiled from the changed code for the changes to be reflected in the finished executable. Modularity (dividing code into modules) is not present in Java's predecessors. If instead of a single executable, the output application was in the form of modules, one could easily change a single module and review changes in the application. In C/C++ on the other hand, a slight change in code required the whole application to be recompiled.
",Platform dependence[edit],plain_text
89,"The idea of Java is to compile the source code into an intermediate language that will be interpreted.
",Platform dependence[edit],plain_text
90,"The intermediate language is the byte code. The interpreter is the Java Virtual Machine (JVM). The byte code file is universal and the JVM is platform specific:
",Platform dependence[edit],plain_text
91,"So a JVM should be coded for each platform. And that's the case. So you just have to generate a unique byte code file (a .class file).
",Platform dependence[edit],plain_text
92,"The first implementations of the language used an interpreted virtual machine to achieve portability, and many implementations still do. These implementations produce programs that run more slowly than the fully-compiled programs created by the typical C++ compiler, so the language suffered a reputation for producing slow programs. Since Java 1.2, Java VM produces programs that run much faster, using multiple techniques.
",Platform dependence[edit],plain_text
93,"The first of these is to simply compile directly into native code like a more traditional compiler, skipping bytecode entirely. This achieves great performance, but at the expense of portability. This is not really used any more.
",Platform dependence[edit],plain_text
94,"Another technique, the just-in-time (JIT) compiler, compiles the Java bytecode into native code at the time the program is run, and keep the compiled code to be used again and again.  More sophisticated VMs even use dynamic recompilation, in which the VM can analyze the behavior of the running program and selectively recompile and optimize critical parts of the program.  Both of these techniques allow the program to take advantage of the speed of native code without losing portability.
",Platform dependence[edit],plain_text
95,"Portability is a technically difficult goal to achieve, and Java's success at that goal is a matter of some controversy.  Although it is indeed possible to write programs for the Java platform that behave consistently across many host platforms, the large number of available platforms with small errors or inconsistencies led some to parody Sun's ""Write once, run anywhere"" slogan as ""Write once, debug everywhere"".
",Platform dependence[edit],plain_text
96,,Standardization[edit],
97,"C++ was built atop the C language and as a result divergent ways of doing the same thing manifested around the language. For instance, creating an object could be done in three different ways in C++. Furthermore, C++ did not come with a standard library bundled with its compilers. Instead, it relied on resources created by other programmers; code which rarely fit together.
",Standardization[edit],plain_text
98,"In Java, standardized libraries are provided to allow access to features of the host machines (such as graphics and networking) in unified ways. The Java language also includes support for multi-threaded programs—a necessity for many networking applications.
",Standardization[edit],plain_text
99,"Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.
",Standardization[edit],plain_text
100,"Java also made progress on the client side, first it had Abstract Window Toolkit (AWT), then Swing, and the most recent client side library is the Standard Widget Toolkit (SWT).
It is interesting to see how they tried to handle the two opposing consuming forces. Those are :
",Standardization[edit],plain_text
101,"It is interesting to see how the approach was switched back and forth. AWT → Swing → SWT.

",Standardization[edit],plain_text
102,,Secure execution[edit],
103,"With the high-level of control built into the language to manipulate hardware, a C/C++ programmer could access almost any resource, either hardware or software on the system. This was intended to be one of the languages' strong points, but this very flexibility led to confusion and complex programming practices.
",Secure execution[edit],plain_text
104,,Error handling[edit],
105,"The old way of error handling was to let each function return an error code then let the caller check what was returned. The problem with this method was that if the return code was full of error-checking codes, this got in the way of the original one that was doing the actual work, which in turn did not make it very readable.
",Error handling[edit],plain_text
106,"In the new way of error handling, functions/methods do not return error codes. Instead, when there is an error, an exception is thrown. The exceptions can be handled by the catch keyword at the end of a try block.  This way, the code that is calling the function does not need to be mangled with error checking codes, thus making the code more readable. This new way of error handling is called Exception handling.
",Error handling[edit],plain_text
107,"Exception handling was also added to C++. However, there are two differences between Java and C++ Exception handling:
",Error handling[edit],plain_text
108,"In Java, the exception that is thrown is a Java object like any other object in Java. It only has to implement Throwable interface.
In Java, the compiler checks whether an exception may be caught or not. The compiler gives an error if there is no catch block for a thrown exception.",Error handling[edit],plain_text
109,"The optional exception handling in the Java predecessors leads the developers not to care about the error handling. As a consequence, unexpected errors often occur. Java forces the developers to handle exceptions. The programmer must handle exception or declare that the user must handle it. Someone must handle it.
",Error handling[edit],plain_text
110,,Networking capabilities[edit],
111,"However powerful, the predecessors of Java lacked a standard feature to network with other computers, and usually relied on the platforms' intricate networking capabilities. With almost all network protocols being standardized, the creators of Java technology wanted this to be a flagship feature of the language while keeping true to the spirit of earlier advances made towards standardizing Remote Procedure Call. Another feature that the Java team focused on was its integration in the World Wide Web and the Internet.
",Networking capabilities[edit],plain_text
112,"The Java platform was one of the first systems to provide wide support for the execution of code from remote sources. The Java language was designed with network computing in mind.
",Networking capabilities[edit],plain_text
113,"An applet could run within a user's browser, executing code downloaded from a remote HTTP server. The remote code runs in a highly restricted ""sandbox"", which protects the user from misbehaving or malicious code; publishers could apply for a certificate that they could use to digitally sign applets as ""safe"", giving them permission to break out of the sandbox and access the local file system and network, presumably under user control.
",Networking capabilities[edit],plain_text
114,,Dynamic class loading[edit],
115,"In conventional languages like C and C++, all code had to be compiled and linked to one executable program, before execution. In Java, classes are compiled as needed. If a class is not needed during an execution phase, that class is not even compiled into byte code.
",Dynamic class loading[edit],plain_text
116,"This feature comes in handy especially in network programming when we do not know, beforehand, what code will be executed. A running program could load classes from the file system or from a remote server.
",Dynamic class loading[edit],plain_text
117,"Also this feature makes it theoretically possible for a Java program to alter its own code during execution, in order to do some self-learning behavior. It would be more realistic to imagine, however, that a Java program would generate Java code before execution, and then, that code would be executed. With some feedback mechanism, the generated code could improve over time.
",Dynamic class loading[edit],plain_text
118,,Automatic memory garbage collection[edit],
119,"In conventional languages like C and C++, the programmer has to make sure that all memory that was allocated is freed. Memory leaks became a regular nuisance in instances where the programmers had to manually allocate the system's memory resources.
",Automatic memory garbage collection[edit],plain_text
120,"Memory resources or buffers have specific modes of operation for optimal performance. Once a buffer is filled with data, it needs to be cleaned up after there is no further use for its content. If a programmer forgets to clean it in his/her code, the memory is easily overloaded. Programming in C/C++ languages became tedious and unsafe because of these very quirks, and programs built in these languages were prone to memory leakages and sudden system crashes — sometimes even harming the hardware itself. Freeing memory is particularly important in servers, since it has to run without stopping for days. If a piece of memory is not freed after use and the server just keeps allocating memory, that memory leak can take down the server.
",Automatic memory garbage collection[edit],plain_text
121,"In Java, freeing up memory is taken out of the programmers hands; the Java Virtual Machine keeps track of all used memory. When memory is not used any more it is automatically freed up. A separate task is running in the background by the JVM, freeing up unreferenced, unused memory. That task is called the Garbage Collector.
",Automatic memory garbage collection[edit],plain_text
122,"The Garbage Collector is always running. This automatic memory garbage collection feature makes it easy to write robust server side programs in Java. The only thing the programmer has to watch for is the speed of object creation. If the application is creating objects faster than the Garbage Collector can free them, it can cause memory problems. Depending on how the JVM is configured, the application either can run out of memory by throwing the NotEnoughMemoryException, or can halt to give time for the Garbage Collector to do its job.
",Automatic memory garbage collection[edit],plain_text
123,,Applet[edit],
124,"The Java creators created the concept of the applet. A Java program can be run in a client browser program. Java was released in 1995; the time when the Internet was becoming more available and familiar to the general public. The promise of Java was in the client browser-side in that code would be downloaded and executed as a Java applet in the client browser program.
",Applet[edit],plain_text
125,,Forbidden bad practices[edit],
126,"Over the years, some features in C/C++ programming became abused by the programmers. Although the language allows it, it was known as bad practices. So the creators of Java have disabled them:
",Forbidden bad practices[edit],plain_text
127,"Operator overloading
Multiple inheritance
Friend classes (access another object's private members)
Restrictions of explicit type casting (related to memory management)",Forbidden bad practices[edit],plain_text
128,,Evaluation[edit],
129,"In most people's opinions, Java technology delivers reasonably well on all these goals. The language is not, however, without drawbacks. Java tends to be more high-level than similar languages (such as C++), which means that the Java language lacks features such as hardware-specific data types, low-level pointers to arbitrary memory addresses, or programming methods like operator overloading. Although these features are frequently abused or misused by programmers, they are also powerful tools. However, Java technology includes Java Native Interface (JNI), a way to call native code from Java language code. With JNI, it is still possible to use some of these features.
",Evaluation[edit],plain_text
130,"Some programmers also complain about its lack of multiple inheritance, a powerful feature of several object-oriented languages, among others C++. The Java language separates inheritance of type and implementation, allowing inheritance of multiple type definitions through interfaces, but only single inheritance of type implementation via class hierarchies. This allows most of the benefits of multiple inheritance while avoiding many of its dangers. In addition, through the use of concrete classes, abstract classes, as well as interfaces, a Java language programmer has the option of choosing full, partial, or zero implementation for the object type he defines, thus ensuring maximum flexibility in application design.
",Evaluation[edit],plain_text
131,"There are some who believe that for certain projects, object orientation makes work harder instead of easier. This particular complaint is not unique to the Java language but applies to other object-oriented languages as well.
",Evaluation[edit],plain_text
132,"The Java platform is the name given to the computing platform from Oracle that helps users to run and develop Java applications. The platform does not just enable a user to run and develop a Java application, but also features a wide variety of tools that can help developers work efficiently with the Java programming language.
",The Java platform (JRE & JDK),plain_text
133,"The platform consists of two essential pieces of software:
",The Java platform (JRE & JDK),plain_text
134,"the Java Runtime Environment (JRE), which is needed to run Java applications and applets; and,
the Java Development Kit (JDK), which is needed to develop those Java applications and applets. If you have installed the JDK, you should know that it comes equipped with a JRE as well. So, for all the purposes of this book, you would only require the JDK.",The Java platform (JRE & JDK),plain_text
135,"In this section, we will explore in further detail what these two software components of the Java platform do.
",The Java platform (JRE & JDK),plain_text
136,,Java Runtime Environment (JRE)[edit],
137,"Any piece of code written in the Java programming language can be run on any operating system, platform or architecture — in fact, it can be run on any device that supports the Java platform. Before Java, this amount of ubiquity was very hard to achieve. If a software was written for a Unix-based system, it was impossible to run the same application on a Windows system — in this case, the application was native only to Unix-based systems.
",Java Runtime Environment (JRE)[edit],plain_text
138,"A major milestone in the development of the Java programming language was to develop a special runtime environment that would execute any Java application independent of the computer's operating system, platform or architecture.
",Java Runtime Environment (JRE)[edit],plain_text
139,"The Java Runtime Environment (JRE) sits on top of the machine's operating system, platform and architecture. If and when a Java application is run, the JRE acts as a liaison between the underlying platform and that application. It interprets the Java application to run in accordance with the underlying platform, such that upon running the application, it looks and behaves like a native application. The part of the JRE that accomplishes this complex liaison agreement is called the Java Virtual Machine (JVM).
",Java Runtime Environment (JRE)[edit],plain_text
140,"
",Java Runtime Environment (JRE)[edit],plain_text
141,"
",Java Runtime Environment (JRE)[edit],plain_text
142,"Native Java applications are preserved in a special format called the byte-code. Byte-code remains the same, no matter what hardware architecture, operating system, or software platform it is running under. On a file-system, Java byte-code resides in files that have the .class (also known as a class file) or the .jar (also known as a Java archive) extension. To run byte-code, the JRE comes with a special tool (appropriately named java).
",Java Runtime Environment (JRE)[edit],plain_text
143,"Suppose your byte-code is called SomeApplication.class. If you want to execute this Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):
",Java Runtime Environment (JRE)[edit],plain_text
144,"If you want to execute a Java byte-code with a .jar extension (say, SomeApplication.jar), you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):
",Java Runtime Environment (JRE)[edit],plain_text
145,"Most computers come with a pre-installed copy of the JRE. If your computer doesn't have a JRE, then the above commands would not work. You can always check what version of the JRE is installed on the computer by writing the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):
",Java Runtime Environment (JRE)[edit],plain_text
146,"Quite possibly, the most important part of the JRE is the Java Virtual Machine (JVM). The JVM acts like a virtual processor, enabling Java applications to be run on the local system. Its main purpose is to interpret (read translate) the received byte-code and make it appear as native code. The older Java architecture used this process of interpretation to execute Java byte-code. Even though the process of interpretation brought the WORA principle to diverse machines, it had a drawback — it consumed a lot of time and clocked the system processor intensively to load an application.
",Java Runtime Environment (JRE)[edit],plain_text
147,"
",Java Runtime Environment (JRE)[edit],plain_text
148,"
",Java Runtime Environment (JRE)[edit],plain_text
149,"Since version 1.2, the JRE features a more robust JVM. Instead of interpreting byte-code, it down-right converts the code straight into equivalent native code for the local system. This process of conversion is called just-in-time compilation or JIT-compilation. This process only occurs when the byte-code is executed for the first time. Unless the byte-code itself is changed, the JVM uses the compiled version of the byte-code on every successive execution. Doing so saves a lot of time and processor effort, allowing applications to execute much faster at the cost of a small delay on first execution.
",Java Runtime Environment (JRE)[edit],plain_text
150,"
",Java Runtime Environment (JRE)[edit],plain_text
151,"
",Java Runtime Environment (JRE)[edit],plain_text
152,"The JVM is an intelligent virtual processor. It has the ability to identify areas within the Java code itself that can be optimized for faster and better performance. Based on every successive run of your Java applications, the JVM would optimize it to run even better.
",Java Runtime Environment (JRE)[edit],plain_text
153,"Java was not the first virtual-machine-based platform, though it is by far the most successful and well-known.  Previous uses for virtual machine technology primarily involved emulators to aid development for not-yet-developed hardware or operating systems, but the JVM was designed to be implemented entirely in software, while making it easy to efficiently port an implementation to hardware of all kinds.
",Java Runtime Environment (JRE)[edit],plain_text
154,,Java Development Kit (JDK)[edit],
155,"The JRE takes care of running the Java code on multiple platforms, however as developers, we are interested in writing pure code in Java which can then be converted into Java byte-code for mass deployment. As developers, we do not need to write Java byte-code; rather we write the code in the Java programming language (which is quite similar to writing C or C++ code).
",Java Development Kit (JDK)[edit],plain_text
156,"Upon downloading the JDK, a developer ensures that their system has the appropriate JRE and additional tools to help with the development of applications in the Java programming language. Java code can be found in files with the extension .java. These files are called Java source files. In order to convert the Java code in these source files to Java byte-code, you need to use the Java compiler tool installed with your JDK.
",Java Development Kit (JDK)[edit],plain_text
157,"The Java compiler tool (named javac in the JDK) is the most important utility found with the JDK.  In order to compile a Java source file (say, SomeApplication.java) to its respective Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):
",Java Development Kit (JDK)[edit],plain_text
158,"This command would convert the SomeApplication.java source file into its equivalent Java byte-code. The resultant byte-code would exist in a newly created file named SomeApplication.class. This process of converting Java source files into their equivalent byte-codes is known as compilation.
",Java Development Kit (JDK)[edit],plain_text
159,"
",Java Development Kit (JDK)[edit],plain_text
160,"
",Java Development Kit (JDK)[edit],plain_text
161,"In most modern operating systems, a large body of reusable code is provided to simplify the programmer's job.  This code is typically provided as a set of dynamically loadable libraries that applications can call at runtime.  Because the Java platform is not dependent on any specific operating system, applications cannot rely on any of the existing libraries.  Instead, the Java platform provides a comprehensive set of standard class libraries, containing much of the same reusable functions commonly found in modern operating systems.
",Java Development Kit (JDK)[edit],plain_text
162,"The Java class libraries serve three purposes within the Java platform.  Like other standard code libraries, they provide the programmer with a well-known set of functions to perform common tasks, such as maintaining lists of items or performing complex string parsing.  In addition, the class libraries provide an abstract interface to tasks that would normally depend heavily on the hardware and operating system.  Tasks such as network access and file access are often heavily dependent on the native capabilities of the platform.  The Java java.net and java.io libraries implement the required native code internally, then provide a standard interface for the Java applications to perform those tasks.  Finally, some underlying platforms may not support all of the features a Java application expects.  In these cases, the class libraries can either emulate those features using whatever is available, or provide a consistent way to check for the presence of a specific feature.
",Java Development Kit (JDK)[edit],plain_text
163,,Similar concepts[edit],
164,"The success of the Java platform and the concepts of the write once, run anywhere principle has led to the development of similar frameworks and platforms. Most notable of these is the Microsoft's .NET framework and its open-source equivalent Mono.
",Similar concepts[edit],plain_text
165,"The .NET framework borrows many of the concepts and innovations of Java — their alternative for the JVM is called the Common Language Runtime (CLR), while their alternative for the byte-code is the Common Intermediate Language (CIL). In fact, the .NET platform had an implementation of a Java-like language called Visual J# (formerly known as J++).
",Similar concepts[edit],plain_text
166,"J# is normally not supported with the JVM because instead of compiling it in Java byte-code, the .NET platform compiles the code into CIL, thus making J# different from the Java programming language. Furthermore, because J# implements the .NET Base Class Libraries (BCL) instead of the Java Class Libraries, J# is nothing more than a non-standard extension of the Java programming language. Due to the lack of interest from developers, Microsoft had to withdraw their support for J#, and focused on a similar programming language: C#.
",Similar concepts[edit],plain_text
167,"The word Java, by itself, usually refers to the Java programming language which was designed for use with the Java platform. Programming languages are typically outside of the scope of the phrase ""platform"".  However, Oracle does not encourage the use of any other languages with the platform, and lists the Java programming language as a core part of the Java 2 platform. The language and runtime are therefore commonly considered a single unit.
",Similar concepts[edit],plain_text
168,"There are cases where you might want to program using a different language (say, Python) and yet be able to generate Java byte-code (instead of the Python compiled code) to be run with the JVM. Many third-party programming language vendors provide compilers that can compile code written in their language to Java byte-code. For instance, Python developers can use Jython compilers to compile Python code to the Java byte-code format (as illustrated below).
",Similar concepts[edit],plain_text
169,"
",Similar concepts[edit],plain_text
170,"
Of late, JVM-targeted third-party programming and scripting languages have seen tremendous growth. Some of these languages are also used to extend the functionalities of the Java language itself. A few examples include the following:
",Similar concepts[edit],plain_text
171,"Groovy
Pizza
GJ (Generic Java) – later officially incorporated into Java SE 5.
NetREXX",Similar concepts[edit],plain_text
172,"
",Similar concepts[edit],plain_text
173,"In order to make use of the content in this book, you would need to follow along each and every tutorial rather than simply reading through the book. But to do so, you would need access to a computer with the Java platform installed on it — the Java platform is the basic prerequisite for running and developing Java code, thus it is divided into two essential pieces of software:
",Installing Java on Your Computer,plain_text
174,"the Java Runtime Environment (JRE), which is needed to run Java applications and applets;
the Java Development Kit (JDK), which is needed to develop those Java applications and applets.",Installing Java on Your Computer,plain_text
175,"However as a developer, you would only require the JDK which comes equipped with a JRE as well.
",Installing Java on Your Computer,plain_text
176,"As Java is just a programming language that allows you to program the computer, it has multiple implementations available. The most popular implementation of JDK and JRE are the ""Oracle Java SE"" (formerly known as Sun JDK), maintained by Oracle as a commercial release. However another similarly popular implementation is the OpenJDK, with the benefit of being free software that could distribute freely under GPL v2 without the requirement of accepting the ""Oracle Binary Code License Agreement for the Java SE Platform Products and JavaFX"". The third option - the GCJ, as part of the GNU Compiler Collection, would also supply the JDK and JRE.
",Installing Java on Your Computer,plain_text
177,"Given below are installation instruction for the Oracle Java SE JDK for various operating systems:
",Installing Java on Your Computer,plain_text
178,"
",Installing Java on Your Computer,plain_text
179,"
In Java, programs are not compiled into executable files; they are compiled into bytecode (as discussed earlier), which the JVM (Java Virtual Machine) then executes at runtime. Java source code is compiled into bytecode when we use the javac compiler. The bytecode gets saved on the disk with the file extension .class. When the program is to be run, the bytecode is converted, using the just-in-time (JIT) compiler. The result is machine code which is then fed to the memory and is executed.
",Compiling programs,plain_text
180,"Java code needs to be compiled twice in order to be executed:
",Compiling programs,plain_text
181,"The Java classes/bytecode are compiled to machine code and loaded into memory by the JVM when needed the first time. This is different from other languages like C/C++ where programs are to be compiled to machine code and linked to create an executable file before it can be executed.
",Compiling programs,plain_text
182,,Quick compilation procedure[edit],
183,"To execute your first Java program, follow the instructions below:
",Quick compilation procedure[edit],plain_text
184,"public class HelloWorld {
  public static void main(String[] args) {
    System.out.println(""Hello World!"");
  }
}
",Quick compilation procedure[edit],code_fragment
185,,Automatic Compilation of Dependent Classes[edit],
186,"In Java, if you have used any reference to any other java object, then the class for that object will be automatically compiled, if that was not compiled already. These automatic  compilations are nested, and this continues until all classes are compiled that are needed to run the program. So it is usually enough to compile only the high level class, since all the dependent classes will be automatically compiled.
",Automatic Compilation of Dependent Classes[edit],plain_text
187,"However, you can't rely on this feature if your program is using reflection to create objects, or you are compiling for servlets or for a ""jar"", package. In these cases you should list these classes for explicit compilation.
",Automatic Compilation of Dependent Classes[edit],plain_text
188,,"Packages, Subdirectories, and Resources[edit]",
189,"Each Java top level class belongs to a package (covered in the chapter about Packages). This may be declared in a package statement at the beginning of the file; if that is missing, the class belongs to the unnamed package.
","Packages, Subdirectories, and Resources[edit]",plain_text
190,"For compilation, the file must be in the right directory structure. A file containing a class in the unnamed package must be in the current/root directory; if the class belongs to a package, it must be in a directory with the same name as the package.
","Packages, Subdirectories, and Resources[edit]",plain_text
191,"The convention is that package names and directory names corresponding to the package consist of only lower case letters.
","Packages, Subdirectories, and Resources[edit]",plain_text
192,"A class with this package declaration
","Packages, Subdirectories, and Resources[edit]",plain_text
193,"package example;
","Packages, Subdirectories, and Resources[edit]",code_fragment
194,"has to be in a directory named example.
","Packages, Subdirectories, and Resources[edit]",plain_text
195,"A class with this package declaration
","Packages, Subdirectories, and Resources[edit]",plain_text
196,"package org.wikibooks.en;
","Packages, Subdirectories, and Resources[edit]",code_fragment
197,"has to be in a directory named en which has to be a sub-directory of wikibooks which in turn has to be a sub-directory of org resulting in org/wikibooks/en on Linux or org\wikibooks\en on Windows.
","Packages, Subdirectories, and Resources[edit]",plain_text
198,"Java programs often contain non-code files such as images and properties files. These are referred to generally as resources and stored in directories local to the classes in which they're used. For example, if the class com.example.ExampleApp uses the icon.png file, this file could be stored as /com/example/resources/icon.png. These resources present a problem when a program is compiled, because javac does not copy them to wherever the .class files are being compiled to (see above); it is up to the programmer to move the resource files and directories.
","Packages, Subdirectories, and Resources[edit]",plain_text
199,,Filename Case[edit],
200,"The Java source file name must be the same as the public class name that the file contains. There can be only one public class defined per file.  The Java class name is case sensitive, as is the source file name.
",Filename Case[edit],plain_text
201,"The naming convention for the class name is for it to start with a capital letter.
",Filename Case[edit],plain_text
202,,Compiler Options[edit],
203,"To debug into Java system classes such as String and ArrayList, you need a special version of the JRE which is compiled with ""debug information"". The JRE included inside the JDK provides this info, but the regular JRE does not. Regular JRE does not include this info to ensure better performance.
",Compiler Options[edit],plain_text
204,"
",Compiler Options[edit],plain_text
205,"   Modern compilers do a pretty good job converting your high-level code, with its nicely indented and nested control structures and arbitrarily typed variables into a big pile of bits called machine code (or bytecode in case of Java), the sole purpose of which is to run as fast as possible on the target CPU (virtual CPU of your JVM). Java code gets converted into several machine code instructions. Variables are shoved all over the place – into the stack, into registers, or completely optimized away. Structures and objects don’t even exist in the resulting code – they’re merely an abstraction that gets translated to hard-coded offsets into memory buffers.
",Compiler Options[edit],plain_text
206,"   So how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is – debugging information.
",Compiler Options[edit],plain_text
207,"   Debugging information is generated by the compiler together with the machine code. It is a representation of the relationship between the executable program and the original source code. This information is encoded into a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files.
",Compiler Options[edit],plain_text
208,"
Symbolic Information : Symbolic resolution is done at class loading time at linking resolution step.
It is the process of replacing symbolic references from the type with direct references. It is done by searching into method area to locate the referenced entity
",Compiler Options[edit],plain_text
209,,The JIT compiler[edit],
210,"The Just-In-Time (JIT) compiler is the compiler that converts the byte-code to machine code. It compiles byte-code once and the compiled machine code is re-used again and again, to speed up execution.  Early Java compilers compiled the byte-code to machine code each time it was used, but more modern compilers cache this machine code for reuse on the machine. Even then, java's JIT compiling was still faster than an ""interpreter-language"", where code is compiled from high level language, instead of from byte-code each time it was used.
",The JIT compiler[edit],plain_text
211,"The standard JIT compiler runs on demand. When a method is called repeatedly, the JIT compiler analyzes the bytecode and produces highly efficient machine code, which runs very fast. The JIT compiler is smart enough to recognize when the code has already been compiled, so as the application runs, compilation happens only as needed. As Java applications run, they tend to become faster and faster, because the JIT can perform runtime profiling and optimization to the code to meet the execution environment. Methods or code blocks which do not run often receive less optimization; those which run often (so called hotspots) receive more profiling and optimization.
",The JIT compiler[edit],plain_text
212,"
",The JIT compiler[edit],plain_text
213,"
There are various ways in which Java code can be executed.  A complex Java application usually uses third party APIs or services. In this section we list the most popular ways a piece of Java code may be packed together and/or executed.
",Running Java programs,plain_text
214,,JSE code execution[edit],
215,"Java language first edition came out in the client-server era.  Thick clients were developed with rich GUI interfaces. Java first edition, JSE (Java Standard Edition) had/has the following in its belt:
",JSE code execution[edit],plain_text
216,"GUI capabilities (AWT, Swing)
Network computing capabilities (RMI)
Multi-tasking capabilities (Threads)",JSE code execution[edit],plain_text
217,"With JSE the following Java code executions are possible:
",JSE code execution[edit],plain_text
218,,J2EE code execution[edit],
219,"As the focus was shifting from reaching GUI clients to thin client applications, with Java version 2, Sun introduced J2EE (Java 2 Extended Edition). J2EE added :
",J2EE code execution[edit],plain_text
220,"Components Base Architecture, (Servlet, JSP, EJB Containers)",J2EE code execution[edit],plain_text
221,"With J2EE the following Java component executions are possible:
",J2EE code execution[edit],plain_text
222,"
",J2EE code execution[edit],plain_text
223,,Jini[edit],
224,"After J2EE Sun had a vision about the next step of network computing. That is Jini. The main idea is that in a network environment, there would be many independent services and consumers. Jini would allow these services/consumers to interact dynamically with each other in a robust way. The basic features of Jini are:
",Jini[edit],plain_text
225,"No user intervention is needed when services are brought on or offline. (In contrast to EJBs where the client program has to know the server and port number where the EJB is deployed, in Jini the client is supposed to find, to discover, the service in the network.)
Self healing by adapting when services (consumers of services) come and go. (Services periodically need to renew a lease to indicate that they are still available.)
Consumers of JINI services do not need prior knowledge of the service's implementation. The implementation is downloaded dynamically and run on the consumer JVM, without configuration and user intervention. (For example, the end user may be presented with a slightly different user interface depending upon which service is being used at the time. The implementation of the user interface code would be provided by the service being used.)",Jini[edit],plain_text
226,"A minimal Jini network environment consists of:
",Jini[edit],plain_text
227,"One or more services
A lookup-service keeping a list of registered services
One or more consumers",Jini[edit],plain_text
228,"Jini is not widely used at the current writing (2006). There are two possible reasons for it. One is Jini a bit complicated to understand and to set it up. The other reason is that Microsoft pulled out from Java, which caused the industry to turn to the use of proprietary solutions.
",Jini[edit],plain_text
229,"
",Jini[edit],plain_text
230,"
This article presents a small Java program which can be run from the console. It computes the distance between two points on a plane. You do not need to understand the structure and meaning of the program just yet; we will get to that soon. Also, because the program is intended as a simple introduction, it has some room for improvement, and later in the module we will show some of these improvements. But let's not get too far ahead of ourselves!
",Understanding a Java program,plain_text
231,,"The Distance Class: Intent, Source, and Use[edit]",
232,"This class is named Distance, so using your favorite editor or Java IDE, first create a file named Distance.java, then copy the source below, paste it into the file and save the file.
","The Distance Class: Intent, Source, and Use[edit]",plain_text
233," 1  public class Distance {
 2    private java.awt.Point point0, point1;
 3  
 4    public Distance(int x0, int y0, int x1, int y1) {
 5      point0 = new java.awt.Point(x0, y0);
 6      point1 = new java.awt.Point(x1, y1);
 7    }
 8  
 9    public void printDistance() {
10      System.out.println(""Distance between "" + point0 + "" and "" + point1
11                      + "" is "" + point0.distance(point1));
12    }
13  
14    public static void main(String[] args) {
15      Distance dist = new Distance(
16               intValue(args[0]), intValue(args[1]),
17               intValue(args[2]), intValue(args[3]));
18      dist.printDistance();
19    }
20  
21    private static int intValue(String data) {
22      return Integer.parseInt(data);
23    }
24  }
","The Distance Class: Intent, Source, and Use[edit]",code_fragment
234,"At this point, you may wish to review the source to see how much you might be able to understand. While perhaps not being the most literate of programming languages, someone with understanding of other procedural languages such as C, or other object oriented languages such as C++ or C#, will be able to understand most if not all of the sample program.
","The Distance Class: Intent, Source, and Use[edit]",plain_text
235,"Once you save the file, compile the program:
","The Distance Class: Intent, Source, and Use[edit]",plain_text
236,"(If the javac command fails, review the installation instructions.)
","The Distance Class: Intent, Source, and Use[edit]",plain_text
237,"To run the program, you supply it with the x and y coordinates of two points on a plane separated by a space. For this version of Distance, only integer points are supported. The command sequence is java Distance <x0> <y0> <x1> <y1> to compute the distance between the points (x0, y0) and (x1, y1).
","The Distance Class: Intent, Source, and Use[edit]",plain_text
238,"Here are two examples:
","The Distance Class: Intent, Source, and Use[edit]",plain_text
239,"We'll explain this strange looking output, and also show how to improve it, later.
","The Distance Class: Intent, Source, and Use[edit]",plain_text
240,,Detailed Program Structure and Overview[edit],
241,"As promised, we will now provide a detailed description of this Java program. We will discuss the syntax and structure of the program and the meaning of that structure.
",Detailed Program Structure and Overview[edit],plain_text
242,"The syntax of a Java class is the characters, symbols and their structure used to code the class. Java programs consist of a sequence of tokens. There are different kinds of tokens. For example, there are word tokens such as class and public which represent keywords (in purple above) — special words with reserved meaning in Java. Other words such as Distance, point0, x1, and printDistance are not keywords but identifiers (in grey). Identifiers have many different uses in Java but primarily they are used as names. Java also has tokens to represent numbers, such as 1 and 3; these are known as literals (in orange). String literals (in blue), such as  ""Distance between "", consist of zero or more characters embedded in double quotes, and operators (in red) such as + and = are used to express basic computation such as addition or String concatenation or assignment. There are also left and right braces ({ and }) which enclose blocks. The body of a class is one such block. Some tokens are punctuation, such as periods . and commas , and semicolons ;. You use whitespace such as spaces, tabs, and newlines, to separate tokens. For example, whitespace is required between keywords and identifiers: publicstatic is a single identifier with twelve characters, not two Java keywords.
",Detailed Program Structure and Overview[edit],plain_text
243,"Sequences of tokens are used to construct the next building blocks of Java classes as shown above: declarations and definitions. A class declaration provides the name and visibility of a class. In our example, public class Distance is the class declaration. It consists (in this case) of two keywords, public and class followed by the identifier Distance.
",Detailed Program Structure and Overview[edit],plain_text
244,"This means that we are defining a class named Distance. Other classes, or in our case, the command line, can refer to the class by this name. The public keyword is an access modifier which declares that this class and its members may be accessed from other classes. The class keyword, obviously, identifies this declaration as a class. Java also allows declarations of interfaces and annotations.
",Detailed Program Structure and Overview[edit],plain_text
245,"The class declaration is then followed by a block (surrounded by curly braces) which provides the class's definition (in blue in figure 2.2). The definition is the implementation of the class – the declaration and definitions of the class's members. This class contains exactly six members, which we will explain in turn.
",Detailed Program Structure and Overview[edit],plain_text
246,"The declaration
",Detailed Program Structure and Overview[edit],plain_text
247,"1 private java.awt.Point point0, point1;
",Detailed Program Structure and Overview[edit],code_fragment
248,"...declares two instance fields. Instance fields represent named values that are allocated whenever an instance of the class is constructed. When a Java program creates a Distance instance, that instance will contain space for point0 and point1. When another Distance object is created, it will contain space for its own point0 and point1 values. The value of point0 in the first Distance object can vary independently of the value of point0 in the second Distance object.
",Detailed Program Structure and Overview[edit],plain_text
249,"This declaration consists of:
",Detailed Program Structure and Overview[edit],plain_text
250,"
These two fields could also have been declared with two separate but more verbose declarations,
",Detailed Program Structure and Overview[edit],plain_text
251,"1  private java.awt.Point point0;
2  private java.awt.Point point1;
",Detailed Program Structure and Overview[edit],code_fragment
252,"Since the type of these fields is a reference type (i.e. a field that refers to or can hold a reference to an object value), Java will implicitly initialize the values of point0 and point1 to null when a Distance instance is created. The null value means that a reference value does not refer to an object. The special Java literal null is used to represent the null value in a program. While you can explicitly assign null values in a declaration, as in
",Detailed Program Structure and Overview[edit],plain_text
253,"1  private java.awt.Point point0 = null;
2  private java.awt.Point point1 = null;
",Detailed Program Structure and Overview[edit],code_fragment
254,"It is not necessary and most programmers omit such default assignments.
",Detailed Program Structure and Overview[edit],plain_text
255,"A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null.
",Detailed Program Structure and Overview[edit],plain_text
256,"1 public Distance(int x0, int y0, int x1, int y1) {
2    point0 = new java.awt.Point(x0, y0);
3    point1 = new java.awt.Point(x1, y1);
4 }
",Detailed Program Structure and Overview[edit],code_fragment
257,"The constructor above consists of five parts:
",Detailed Program Structure and Overview[edit],plain_text
258,"This constructor accepts four parameters, named x0, y0, x1 and y1. Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas.
",Detailed Program Structure and Overview[edit],plain_text
259,"The two assignments in this constructor use Java's new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0), and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable.
",Detailed Program Structure and Overview[edit],plain_text
260,"This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object. Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call:
",Detailed Program Structure and Overview[edit],plain_text
261,"1 {
2    super();
3    point0 = new java.awt.Point(x0, y0);
4    point1 = new java.awt.Point(x1, y1);
5 }
",Detailed Program Structure and Overview[edit],code_fragment
262,"While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as 





(

x

1


−

x

0



)

2


+
(

y

1


−

y

0



)

2






{\displaystyle {\sqrt {(x_{1}-x_{0})^{2}+(y_{1}-y_{0})^{2}}}}

, this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.
",Detailed Program Structure and Overview[edit],plain_text
263,"Methods are the third and most important type of class member. This class contains three methods in which the behavior of the Distance class is defined: printDistance(), main(), and intValue()
",Detailed Program Structure and Overview[edit],plain_text
264,"The printDistance() method prints the distance between the two points to the standard output (normally the console).
",Detailed Program Structure and Overview[edit],plain_text
265,"1 public void printDistance() {
2   System.out.println(""Distance between "" + point0
3     + "" and "" + point1
4     + "" is "" + point0.distance(point1));
5 }
",Detailed Program Structure and Overview[edit],code_fragment
266,"This instance method executes within the context of an implicit Distance object. The instance field references, point0 and point1, refer to instance fields of that implicit object. You can also use the special variable this to explicitly reference the current object. Within an instance method, Java binds the name this to the object on which the method is executing, and the type of this is that of the current class. The body of the printDistance method could also be coded as
",Detailed Program Structure and Overview[edit],plain_text
267,"1   System.out.println(""Distance between "" + this.point0
2     + "" and "" + this.point1
3     + "" is "" + this.point0.distance(this.point1));
",Detailed Program Structure and Overview[edit],code_fragment
268,"to make the instance field references more explicit.
",Detailed Program Structure and Overview[edit],plain_text
269,"This method both computes the distance and prints it in one statement. The distance is computed with point0.distance(point1); distance() is an instance method of the java.awt.Point class (of which point0 and point1 are instances). The method operates on point0 (binding this to the object that point0 refers to during the execution of the method) and accepting another Point as a parameter. Actually, it is slightly more complicated than that, but we'll explain later. The result of the distance() method is a double precision floating point number.
",Detailed Program Structure and Overview[edit],plain_text
270,"This method uses the syntax
",Detailed Program Structure and Overview[edit],plain_text
271,"1  ""Distance between "" + this.point0
2  + "" and "" + this.point1
3  + "" is "" + this.point0.distance(this.point1)
",Detailed Program Structure and Overview[edit],code_fragment
272,"to construct a String to pass to the System.out.println(). This expression is a series of String concatenation methods which concatenates Strings or the String representation of primitive types (such as doubles) or objects, and returns a long string. For example, the result of this expression for the points (0,3) and (4,0) is the String
",Detailed Program Structure and Overview[edit],plain_text
273,"which the method then prints to System.out.
",Detailed Program Structure and Overview[edit],plain_text
274,"In order to print, we invoke the println(). This is an instance method from java.io.PrintStream, which is the type of the static field out in the class java.lang.System. The Java VM binds System.out to the standard output stream when it starts a program.
",Detailed Program Structure and Overview[edit],plain_text
275,"The main() method is the main entry point which Java invokes when you start a Java program from the command line. The command
",Detailed Program Structure and Overview[edit],plain_text
276,"instructs Java to locate the Distance class, put the four command line arguments into an array of String values, then pass those arguments to the public static main(String[]) method of the class. We will introduce arrays shortly. Any Java class that you want to invoke from the command line or desktop shortcut must have a main method with this signature or the following signature: public static main(String...).
",Detailed Program Structure and Overview[edit],plain_text
277,"1 public static void main(String[] args) {
2    Distance dist = new Distance(
3          intValue(args[0]), intValue(args[1]),
4          intValue(args[2]), intValue(args[3]));
5    dist.printDistance();
6 }
",Detailed Program Structure and Overview[edit],code_fragment
278,"The main() method invokes the final method, intValue(), four times. The intValue() takes a single string parameter and returns the integer value represented in the string. For example, intValue(""3"") will return the integer 3.
",Detailed Program Structure and Overview[edit],plain_text
279,"People who do test-first programming or perform regression testing
write
a main() method in every Java class, and
a  main() function in every Python module,
to run automated tests.
When a person executes the file directly,
the main() method executes and runs the automated tests for that file.
When a person executes some other Java file
that in turn imports many other Java classes,
only one main() method is executed --
the main() method of the directly-executed file.
",Detailed Program Structure and Overview[edit],plain_text
280,"The intValue() method delegates its job to the Integer.parseInt() method. The main method could have called Integer.parseInt() directly; the intValue() method simply makes the main() method slightly more readable.
",Detailed Program Structure and Overview[edit],plain_text
281,"1 private static int intValue(String data) {
2    return Integer.parseInt(data);
3 }
",Detailed Program Structure and Overview[edit],code_fragment
282,"This method is private since, like the fields point0 and point1, it is part of the internal implementation of the class and is not part of the external programming interface of the Distance class.
",Detailed Program Structure and Overview[edit],plain_text
283,"Both the main() and intValue() methods are static methods. The static keyword tells the compiler to create a single memory space associated with the class.  Each individual object instantiated has its own private state variables and methods but use the same static methods and members common to the single class object created by the compiler when the first class object is instantiated or created.  This means that the method executes in a static or non-object context — there is no implicit separate instance available when the static methods run from various objects, and the special variable this is not available. As such, static methods cannot access instance methods or instance fields (such as printDistance()) or point0) directly. The main() method can only invoke the instance method printDistance() method via an instance reference such as dist.
",Detailed Program Structure and Overview[edit],plain_text
284,"Most declarations have a data type. Java has several categories of data types: reference types, primitive types, array types, and a special type, void.
",Detailed Program Structure and Overview[edit],plain_text
285,"The primitive types are used to represent boolean, character, and numeric values. This program uses only one primitive type explicitly, int, which represents 32 bit signed integer values. The program also implicitly uses double, which is the return type of the distance() method of java.awt.Point. double values are 64 bit IEEE floating point values. The main() method uses integer values 0, 1, 2, and 3 to access elements of the command line arguments. The Distance() constructor's four parameters also have the type int. Also, the intValue() method has a return type of int. This means a call to that method, such as intValue(args[0]), is an expression of type int. This helps explain why the main method cannot call:
",Detailed Program Structure and Overview[edit],plain_text
286,"1 new Distance(args[0], args[1], args[2], args[3]) // This is an error
",Detailed Program Structure and Overview[edit],code_fragment
287,"Since the type of the args array element is String, and our constructor's parameters must be int, such a call would result in an error because Java will not automatically convert values of type String into int values.
",Detailed Program Structure and Overview[edit],plain_text
288,"Java's primitive types are
boolean,
byte,
char,
short,
int,
long,
float and
double. Each of which are also Java language keywords.
",Detailed Program Structure and Overview[edit],plain_text
289,"In addition to primitive types, Java supports reference type. A reference type is a Java data type which is defined by a Java class or interface. Reference types derive this name because such values refer to an object or contain a reference to an object. The idea is similar to pointers in other languages like C.
",Detailed Program Structure and Overview[edit],plain_text
290,"Java represents sequences of character data, or String, with the reference type java.lang.String which is most commonly referred to as String. String literals, such as  ""Distance between "" are constants whose type is String.
",Detailed Program Structure and Overview[edit],plain_text
291,"This program uses three separate reference types:
",Detailed Program Structure and Overview[edit],plain_text
292,"Java supports arrays, which are aggregate types which have a fixed element type (which can be any Java type) and an integral size. This program uses only one array, String[] args. This indicates that args has an array type and that the element type is String. The Java VM constructs and initializes the array that is passed to the main method. See arrays for more details on how to create arrays and access their size.
",Detailed Program Structure and Overview[edit],plain_text
293,"The elements of arrays are accessed with integer indices. The first element of an array is always element 0. This program accesses the first four elements of the args array explicitly with the indices 0, 1, 2, and 3. This program does not perform any input validation, such as verifying that the user passed at least four arguments to the program. We will fix that later.
",Detailed Program Structure and Overview[edit],plain_text
294,"void is not a type in Java; it represents the absence of a type. Methods which do not return values are declared as void methods.
",Detailed Program Structure and Overview[edit],plain_text
295,"This class defines two void methods:
",Detailed Program Structure and Overview[edit],plain_text
296,"1 public static void main(String[] args) { ... }
2 public void printDistance()  { ... }
",Detailed Program Structure and Overview[edit],code_fragment
297,,Whitespace[edit],
298,"Whitespace in Java is used to separate the tokens in a Java source file. Whitespace is required in some places, such as between access modifiers, type names and Identifiers, and is used to improve readability elsewhere.
",Whitespace[edit],plain_text
299,"Wherever whitespace is required in Java, one or more whitespace characters may be used. Wherever whitespace is optional in Java, zero or more whitespace characters may be used.
",Whitespace[edit],plain_text
300,"Java whitespace consists of the
",Whitespace[edit],plain_text
301,"space character ' ' (0x20),
the tab character (hex 0x09),
the form feed character (hex 0x0c),
the line separators characters newline (hex 0x0a) or carriage return (hex 0x0d) characters.",Whitespace[edit],plain_text
302,"Line separators are special whitespace characters in that they also terminate line comments, whereas normal whitespace does not.
",Whitespace[edit],plain_text
303,"Other Unicode space characters, including vertical tab, are not allowed as whitespace in Java.
",Whitespace[edit],plain_text
304,"Look at the static method intValue:
",Whitespace[edit],plain_text
305,"1 private static int intValue(String data) {
2   return Integer.parseInt(data);
3 }
",Whitespace[edit],code_fragment
306,"Whitespace is required between private and static, between static and int, between int and intValue, and between String and data.
",Whitespace[edit],plain_text
307,"If the code is written like this:
",Whitespace[edit],plain_text
308,"1 privatestaticint intValue(String data) {
2   return Integer.parseInt(data);
3 }
",Whitespace[edit],code_fragment
309,"...it means something completely different: it declares a method which has the return type privatestaticint It is unlikely that this type exists and the method is no longer static, so the above would result in a semantic error.
",Whitespace[edit],plain_text
310,,Indentation[edit],
311,"Java ignores all whitespace in front of a statement. As this, these two code snippets are identical for the compiler:
",Indentation[edit],plain_text
312," 1 public static void main(String[] args) {
 2   Distance dist = new Distance(
 3            intValue(args[0]), intValue(args[1]),
 4            intValue(args[2]), intValue(args[3]));
 5   dist.printDistance();
 6 }
 7 
 8 private static int intValue(String data) {
 9   return Integer.parseInt(data);
10 }
",Indentation[edit],code_fragment
313," 1 public static void main(String[] args) {
 2 Distance dist = new Distance(
 3 intValue(args[0]), intValue(args[1]),
 4 intValue(args[2]), intValue(args[3]));
 5 dist.printDistance();
 6 }
 7 
 8 private static int intValue(String data) {
 9 return Integer.parseInt(data);
10 }
",Indentation[edit],code_fragment
314,"However, the first one's style (with whitespace) is preferred, as the readability is higher. The method body is easier to distinguish from the head, even at a higher reading speed.
",Indentation[edit],plain_text
315,"
",Indentation[edit],plain_text
316,,What is a Java IDE?[edit],
317,"A Java IDE (for Integrated Development Environment) is a software application which enables users to more easily write and debug Java programs. Many IDEs provide features like syntax highlighting and code completion, which help the user to code more easily.

",What is a Java IDE?[edit],plain_text
318,,Eclipse[edit],
319,"Eclipse is a Free and Open Source IDE, plus a developer tool framework that can be extended for a particular development need. IBM was behind its development, and it replaced IBM VisualAge tool. The idea was to create a standard look and feel that can be extended via plugins. The extensibility distinguishes Eclipse from other IDEs. Eclipse was also meant to compete with Microsoft Visual Studio tools. Microsoft tools give a standard way of developing code in the Microsoft world. Eclipse gives a similar standard way of developing code in the Java world, with a big success so far. With the online error checking only, coding can be sped up by at least 50% (coding does not include programming).
",Eclipse[edit],plain_text
320,"The goals for Eclipse are twofold:
",Eclipse[edit],plain_text
321,"IBM's WSAD, and later IBM Rational Software Development Platform, are built on Eclipse.
",Eclipse[edit],plain_text
322,"Standard Eclipse features:
",Eclipse[edit],plain_text
323,"Standard window management (perspectives, views, browsers, explorers, ...)
Error checking as you type (immediate error indications, ...)
Help window as you type (type ., or <ctrl> space, ...)
Automatic build (changes in source code are automatically compiled, ...)
Built-in debugger (full featured GUI debugger)
Source code generation (getters and setters, ...)
Searches (for implementation, for references, ...)
Code refactoring (global reference update, ...)
Plugin-based architecture (ability to build tools that integrate seamlessly with the environment, and some other tools)
...",Eclipse[edit],plain_text
324,"
",Eclipse[edit],plain_text
325,,NetBeans[edit],
326,"The NetBeans IDE is a Free and Open Source IDE for software developers. The IDE runs on many platforms including Windows, GNU/Linux, Solaris and Mac OS X. It is easy to install and use straight out of the box. You can easily create Java applications for mobile devices using Mobility Pack in NetBeans. With Netbeans 6.0, the IDE has become one of the most preferred development tools, whether it be designing a Swing UI, building a mobile application, an enterprise application or using it as a platform for creating your own IDE.
",NetBeans[edit],plain_text
327,"
",NetBeans[edit],plain_text
328,,JCreator[edit],
329,"JCreator is a simple and lightweight JAVA IDE from XINOX Software. It runs only on Windows platforms. It is very easy to install and starts quickly, as it is a native application. This is a good choice for beginners.
",JCreator[edit],plain_text
330,,Processing[edit],
331,"Processing is an enhanced IDE. It adds some extra commands and a simplified programming model. This makes it much easier for beginners to start programming in Java. It was designed to help graphic artists learn a bit of programming without struggling too much. Processing runs on Windows, GNU/Linux and Mac OS X platforms.
",Processing[edit],plain_text
332,,BlueJ[edit],
333,"BlueJ is an IDE that includes templates and will compile and run the applications for you. BlueJ is often used by classes because it is not necessary to set classpaths. BlueJ has its own sets of libraries and you can add your own under preferences. That sets the classpath for all compilations that come out of it to include those you have added and the BlueJ libraries.
",BlueJ[edit],plain_text
334,"BlueJ offers an interesting GUI for creation of packages and programs. Classes are represented as boxes with arrows running between them to represent inheritance/implementation or if on is constructed in another. The source code is generated by the UML diagram or vice-versa. BlueJ adds all those classes (the project) into the classpath at compile time. 
",BlueJ[edit],plain_text
335,"By default it doesn't display the line numbers, so this should be ticked into Options\Preferences...
",BlueJ[edit],plain_text
336,,Kawa[edit],
337,"Kawa is basically a Java editor developed by Tek-Tools. It does not include wizards and GUI tools, best suited to experienced Java programmers in small and midsized development teams. It looks that there is no new development for Kawa.
",Kawa[edit],plain_text
338,"See also a javaworld article
",Kawa[edit],plain_text
339,,JBuilder[edit],
340,"JBuilder is an IDE with proprietary source code, sold by Embarcadero Technologies. One of the advantages is the integration with Together, a modeling tool.
",JBuilder[edit],plain_text
341,,DrJava[edit],
342,"DrJava is an IDE developed by the JavaPLT group at Rice University. It is designed for students.
",DrJava[edit],plain_text
343,,Other IDEs[edit],
344,"Geany
IntelliJ IDEA
JDeveloper
jGRASP
jEdit
MyEclipse
Visual Café
Gel
JIPE
Zeus
Setu Eye Saving Lightweight(fast)C,C++,JAVA IDE",Other IDEs[edit],plain_text
345,"
",Other IDEs[edit],plain_text
346,"
Now that we have the Java platform on our systems and have run the first program successfully, we are geared towards understanding how programs are actually made. As we have already discussed, a program is a set of instructions, which are tasks provided to a computer. These instructions are called statements in Java. Statements can be anything from a single line of code to a complex mathematical equation. Consider the following line:
",Statements,plain_text
347,"1 int age = 24;
",Statements,code_fragment
348,"This line is a simple instruction that tells the system to initialize a variable and set its value as 24. If the above statement was the only one in the program, it would look similar to this:
",Statements,plain_text
349,"1 public class MyProgram {
2     public static void main(String[] args) {
3         int age = 24;
4     }
5 }
",Statements,code_fragment
350,"Java places its statements within a class declaration and, in the class declaration, the statements are usually placed in a method declaration, as above.
",Statements,plain_text
351,,Variable declaration statement[edit],
352,"The simplest statement is a variable declaration:
",Variable declaration statement[edit],plain_text
353,"1 int age;
",Variable declaration statement[edit],code_fragment
354,"It defines a variable that can be used to store values for later use. The first token is the data type of the variable (which type of values this variable can store). The second token is the name of the variable, by which you will be referring to it. Then each declaration statement is ended by a semicolon (;).
",Variable declaration statement[edit],plain_text
355,,Assignment statements[edit],
356,"Up until now, we've assumed the creation of variables as a single statement. In essence, we assign a value to those variables, and that's just what it is called. When you assign a value to a variable in a statement, that statement is called an assignment statement (also called an initialization statement). Did you notice one more thing? It's the semicolon (;), which is at the end of each statement. A clear indicator that a line of code is a statement is its termination with an ending semicolon. If one was to write multiple statements, it is usually done with each statement on a separate line ending with a semicolon. Consider the example below:
",Assignment statements[edit],plain_text
357,"1 int a = 10;
2 int b = 20;
3 int c = 30;
",Assignment statements[edit],code_fragment
358,"You do not necessarily have to use a new line to write each statement. Just like English, you can begin writing the next statement where you ended the first one as depicted below:
",Assignment statements[edit],plain_text
359,"1 int a = 10; int b = 20; int c = 30;
",Assignment statements[edit],code_fragment
360,"However, the only problem with putting multiple statements on one line is, it's very difficult to read it. It doesn't look that intimidating at first, but once you've got a significant amount of code, it's usually better to organize it in a way that makes sense. It would look more complex and incomprehensible written as it is in Listing 3.4.
",Assignment statements[edit],plain_text
361,"Now that we have looked into the anatomy of a simple assignment statement, we can look back at what we've achieved. We know that...
",Assignment statements[edit],plain_text
362,"A statement is a unit of code in programming.
If we are assigning a variable a value, the statement is called an assignment statement.
An assignment statement includes three parts: a data type, the variable name (also called the identifier) and the value of a variable. We will look more into the nature of identifiers and values in the section Variables later.",Assignment statements[edit],plain_text
363,"Now, before we move on to the next topic, you need to try and understand what the code below does.
",Assignment statements[edit],plain_text
364,"1 int firstNumber = 10;
2 int secondNumber = 20;
3 int result = firstNumber + secondNumber;
4 System.out.println(result);
5 secondNumber = 30;
6 System.out.println(result);
",Assignment statements[edit],code_fragment
365,"The first two statements are pretty much similar to those in Section 3.3 but with different variable names. The third however is a bit interesting. We've already talked of variables as being similar to gift boxes. Think of your computer's memory as a shelf where you put all those boxes. Whenever you need a box (or variable), you call its identifier (that's the name of the variable). So calling the variable identifier firstNumber gives you the number 10, calling secondNumber would give you 20 hence when you add the two up, the answer should be 30. That's what the value of the last variable result would be. The part of the third statement where you add the numbers, i.e., firstNumber + secondNumber is called an expression and the expression is what decides what the value is to be. If it's just a plain value, like in the first two statements, then it's called a literal (the value is literally the value, hence the name literal).
",Assignment statements[edit],plain_text
366,"Note that after the assignment to result its value will not be changed if we assign different values to firstNumber or secondNumber, like in line 5.
",Assignment statements[edit],plain_text
367,"With the information you have just attained, you can actually write a decent Java program that can sum up values.
",Assignment statements[edit],plain_text
368,,Assertion[edit],
369,"An assertion checks if a condition is true:
",Assertion[edit],plain_text
370,"1     public int getAge() {
2         assert age >= 0;
3         return age;
4     }
",Assertion[edit],code_fragment
371,"Each assert statement is ended by a semi-colon (;). However, assertions are disabled by default, so you must run the program with the -ea argument in order for assertions to be enabled (java -ea [name of compiled program]).
",Assertion[edit],plain_text
372,,Program Control Flow[edit],
373,"Statements are evaluated in the order as they occur. The execution of flow begins at the top most statement and proceed downwards till the last statement is encountered. A statement can be substituted by a statement block. There are special statements that can redirect the execution flow based on a condition, those statements are called branching statements, described in detail in a later section.
",Program Control Flow[edit],plain_text
374,,Statement Blocks[edit],
375,"A bunch of statements can be placed in braces to be executed as a single block. Such a block of statements can be named
or be provided with a condition for execution. Below is how you'd place a series of statements in a block.
",Statement Blocks[edit],plain_text
376,"1 {
2     int a = 10;
3     int b = 20;
4     int result = a + b;
5 }
",Statement Blocks[edit],code_fragment
377,,Branching Statements[edit],
378,"Program flow can be affected using function/method calls, loops and iterations. Of various types of branching constructs,
we can easily pick out two generic branching methods.
",Branching Statements[edit],plain_text
379,"Unconditional Branching
Conditional Branching",Branching Statements[edit],plain_text
380,"If you look closely at a method, you'll see that a method is a named statement block that is executed by calling that particular name. An unconditional branch is created either by invoking the method or by calling break, continue, return or throw, all of which are described below.
",Branching Statements[edit],plain_text
381,"When a name of a method is encountered in a flow, it stops execution in the current method and branches to the newly called method. After returning a value from the called method, execution picks up at the original method on the line below the method call.
",Branching Statements[edit],plain_text
382," 1 public class UnconditionalBranching {
 2     public static void main(String[] args) {
 3         System.out.println(""Inside main method! Invoking aMethod!"");
 4         aMethod();
 5         System.out.println(""Back in main method!"");
 6     }
 7 
 8     public static void aMethod() {
 9         System.out.println(""Inside aMethod!"");
10     }
11 }
",Branching Statements[edit],code_fragment
383,"The program flow begins in the main method. Just as aMethod is invoked, the flow travels to
the called method. At this very point, the flow branches to the other method. Once the method is completed, the flow
is returned to the point it left off and resumes at the next statement after the call to the method.
",Branching Statements[edit],plain_text
384,,Return statement[edit],
385,"A return statement exits from a block, so it is often the last statement of a method:
",Return statement[edit],plain_text
386,"1     public int getAge() {
2         int age = 24;
3         return age;
4     }
",Return statement[edit],code_fragment
387,"A return statement can return the content of a variable or nothing. Beware not to write statements after a return statement which would not be executed! Each return statement is ended by a semi-colon (;).
",Return statement[edit],plain_text
388,"Conditional branching is attained with the help of the if...else and switch statements. A
conditional branch occurs only if a certain condition expression evaluates to true.
",Return statement[edit],plain_text
389,"Also referred to as if statements, these allow a program to perform a test and then take action based on the result of that test.
",Return statement[edit],plain_text
390,"The form of the if statement:
",Return statement[edit],plain_text
391,"if (condition) {
  do statements here if condition is true
} else {
  do statements here if condition is false
}
",Return statement[edit],plain_text
392,"The condition is a boolean expression which can be either true or false. The actions performed will depend on the value of the condition.
",Return statement[edit],plain_text
393,"Example:
",Return statement[edit],plain_text
394,"1 if (i > 0) {
2    System.out.println(""value stored in i is greater than zero"");
3 } else {
4    System.out.println(""value stored is not greater than zero"");
5 }
",Return statement[edit],code_fragment
395,"If statements can also be made more complex using the else if combination:
",Return statement[edit],plain_text
396,"if (condition 1) {
   do statements here if condition 1 is true
} else if (condition 2) {
   do statements here if condition 1 is false and condition 2 is true
} else {
  do statements here if neither condition 1 nor condition 2 is true
}
",Return statement[edit],plain_text
397,"Example:
",Return statement[edit],plain_text
398,"1 if (i > 0) {
2    System.out.println(""value stored in i is greater than zero"");
3 } else if (i < 0) {
4    System.out.println(""value stored in i is less than zero"");
5 } else {
6    System.out.println(""value stored is equal to 0"");
7 }
",Return statement[edit],code_fragment
399,"If there is only one statement to be executed after the condition, as in the above example, it is possible to omit the curly braces, however Oracle's Java Code Conventions explicitly state that the braces should always be used.
",Return statement[edit],plain_text
400,"There is no looping involved in an if statement so once the condition has been evaluated the program will continue with the next instruction after the statement.
",Return statement[edit],plain_text
401,"The if ... else statement is used to conditionally execute one of two blocks of
statements, depending on the result of a boolean condition.
",Return statement[edit],plain_text
402,"Example:
",Return statement[edit],plain_text
403,"1 if (list == null) {
2   // This block of statements executes if the condition is true.
3 } else {
4   // This block of statements executes if the condition is false.
5 }
",Return statement[edit],code_fragment
404,"Oracle's Java Code Conventions recommend that the braces should always be used.
",Return statement[edit],plain_text
405,"An if statement has two forms:
",Return statement[edit],plain_text
406,"if (boolean-condition)
   statement1
",Return statement[edit],plain_text
407,"and
",Return statement[edit],plain_text
408,"if (boolean-condition)
   statement1
else
   statement2
",Return statement[edit],plain_text
409,"Use the second form if you have different statements to execute if the boolean-condition is true or if it is false. Use the first if you only wish to execute statement1 if the condition is true and you do not wish to execute alternate statements if the condition is false.
",Return statement[edit],plain_text
410,"The code section 3.13 calls two int methods, f() and y(), stores the results, then uses an if statement to test if x is less than y and if it is, the statement1 body will swap the values. The end result is x always contains the larger result and y always contains the smaller result.
",Return statement[edit],plain_text
411,"1 int x = f();
2 int y = y();
3 if (x < y) {
4   int z = x;
5   x = y;
6   y = z;
7 }
",Return statement[edit],code_fragment
412,"if...else statements also allow for the use of another statement, else if.  This statement is used to provide another if statement to the conditional that can only be executed if the others are not true.  For example:
",Return statement[edit],plain_text
413,"1 if (x == 2)
2   x = 4;
3 else if (x == 3)
4   x = 6;
5 else
6   x = -1;
",Return statement[edit],code_fragment
414,"The else if statement is useful in this case because if one of the conditionals is true, the other must be false.  Keep in mind that if one is true, the other will not execute.  For example, if the statement at line 2 contained in the first conditional were changed to x = 3;, the second conditional, the else if, would still not execute.  However, when dealing with primitive types in conditional statements, it is more desirable to use switch statements rather than multiple else if statements.
",Return statement[edit],plain_text
415,"The switch conditional statement is basically a shorthand version of writing many if...else statements.  The syntax for switch statements is as follows:
",Return statement[edit],plain_text
416,"switch(<variable>) {
  case <result>: <statements>; break;
  case <result>: <statements>; break;
  default: <statements>; break;
}
",Return statement[edit],plain_text
417,"This means that if the variable included equals one of the case results, the statements following that case, until the word break will run.  The default case executes if none of the others are true.  Note: the only types that can be analysed through switch statements are char, byte, short, or int primitive types.  This means that Object variables can not by analyzed through switch statements. However, as of the JDK 7 release, you can use a String object in the expression of a switch statement.
",Return statement[edit],plain_text
418," 1 int n = 2, x;
 2 switch (n) {
 3   case 1: x = 2;
 4     break;
 5   case 2: x = 4;
 6     break;
 7   case 3: x = 6;
 8     break;
 9   case 4: x = 8;
10     break;
11 }
12 return x;
",Return statement[edit],code_fragment
419,"In this example, since the integer variable n is equal to 2, case 2 will execute, make x equal to 4.  Thus, 4 is returned by the method.
",Return statement[edit],plain_text
420,,Iteration Statements[edit],
421,"Iteration Statements are statements that are used to iterate a block of statements. Such statements are often referred
to as loops. Java offers four kinds of iterative statements.
",Iteration Statements[edit],plain_text
422,"The while loop
The do...while loop
The for loop
The foreach loop",Iteration Statements[edit],plain_text
423,"The while loop iterates a block of code while the condition it specifies is true.
",Iteration Statements[edit],plain_text
424,"The syntax for the loop is:
",Iteration Statements[edit],plain_text
425,"while (condition) {
   statement;
 }
",Iteration Statements[edit],plain_text
426,"Here the condition is an expression.
An expression as discussed earlier is any statement that returns a value. While condition statements
evaluate to a boolean value, that is, either true or false. As long as the condition is
true, the loop will iterate the block of code over and over and again. Once the condition evaluates
to false, the loop exits to the next statement outside the loop.
",Iteration Statements[edit],plain_text
427,"The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executes
",Iteration Statements[edit],plain_text
428,"do {
   statement;
 } while (condition);
",Iteration Statements[edit],plain_text
429,"The for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. Example:
",Iteration Statements[edit],plain_text
430,"1 for (int i = 0; i < 100; i++) {
2   System.out.println(i + ""\t"" + i * i);
3 }
",Iteration Statements[edit],code_fragment
431,"The program prints the numbers 0 to 99 and their squares.
",Iteration Statements[edit],plain_text
432,"The same statement in a while loop:
",Iteration Statements[edit],plain_text
433,"1 int i = 0;
2 while (i < 100) {
3    System.out.println(i + ""\t"" + i * i);
4    i++;
5 }
",Iteration Statements[edit],code_fragment
434,"The foreach statement allows you to iterate through all the items in a collection,
examining each item in turn while still preserving its type. The syntax for the foreach statement is:
",Iteration Statements[edit],plain_text
435,"for (type item : collection) statement;
",Iteration Statements[edit],plain_text
436,"For an example, we'll take an array of Strings denoting days in a week and traverse through the
collection, examining one item at a time.
",Iteration Statements[edit],plain_text
437,"1 String[] days = {""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday"", ""Sunday""};
2 
3 for (String day : days) {
4   System.out.println(day);
5 }
",Iteration Statements[edit],code_fragment
438,"Notice that the loop automatically exits after the last item in the collection has been examined in the statement
block.
",Iteration Statements[edit],plain_text
439,"Although the enhanced for loop can make code much clearer, it can't be used in some common situations.
",Iteration Statements[edit],plain_text
440,"Only access. Elements can not be assigned to, eg, not to increment each element in a collection.
Only single structure. It's not possible to traverse two structures at once, eg, to compare two arrays.
Only single element. Use only for single element access, eg, not to compare successive elements.
Only forward. It's possible to iterate only forward by single steps.
At least Java 5. Don't use it if you need compatibility with versions before Java 5.",Iteration Statements[edit],plain_text
441,,The continue and break statements[edit],
442,"At times, you would like to re-iterate a loop without executing the remaining statement within the loop. The
continue statement causes the loop to re-iterate and start over from the top most statement inside
the loop.
",The continue and break statements[edit],plain_text
443,"Where there is an ability to re-iterate the loop, there is an ability to exit the loop when required. At any given
moment, if you'd like to exit a loop and end all further work within the loop, the break ought to be
used.
",The continue and break statements[edit],plain_text
444,"The continue and break statements can be used with a label like follows:
",The continue and break statements[edit],plain_text
445,"1 String s = ""A test string for the switch!\nLine two of test string..."";
2 outer: for (int i = 0; i < s.length(); i++) {
3   switch (s.charAt(i)) {
4     case '\n': break outer;
5     case ' ': break;
6     default: System.out.print(s.charAt(i));
7   }
8 }
",The continue and break statements[edit],code_fragment
446,,Throw statement[edit],
447,"A throw statement exits from a method and so on and so on or it is caught by a try/catch block. It does not return a variable but an exception:
",Throw statement[edit],plain_text
448,"1     public int getAge() {
2         throw new NullPointerException();
3     }
",Throw statement[edit],code_fragment
449,"Beware not to write statements after a throw statement which would not be executed too! Each throw statement is ended by a semi-colon (;).
",Throw statement[edit],plain_text
450,,try/catch[edit],
451,"A try/catch must at least contain the try block and the catch block:
",try/catch[edit],plain_text
452,"1 try {
2   // Some code
3 } catch (Exception e) {
4   // Optional exception handling
5 } finally {
6   // This code is executed no matter what
7 }
",try/catch[edit],code_fragment
453," 1 public class AProgram {
 2 
 3     private int age = 24;
 4 
 5     public static void main(String[] args) {
 6         int daysInAYear = 365;int ageInDay = 100000;
 7         int localAge = ageInDay / daysInAYear;
 8     }
 9 
10     public int getAge() {
11         return age;
12     }
13 }
",try/catch[edit],code_fragment
454,"
",try/catch[edit],plain_text
455,"
Conditional blocks allow a program to take a different path depending on some condition(s). These allow a program to perform a test and then take action based on the result of that test. In the code sections, the actually executed code lines will be highlighted.
",Conditional blocks,plain_text
456,"The if block executes only if the boolean expression associated with it is true. The structure of an if block is as follows:
",Conditional blocks,plain_text
457,"Here is a double example to illustrate what happens if the condition is true and if the condition is false:
",Conditional blocks,plain_text
458," 1 int age = 6;
 2 System.out.println(""Hello!"");
 3 
 4 if (age < 13) {
 5   System.out.println(""I'm a child."");
 6 }
 7 
 8 if (age > 20) {
 9   System.out.println(""I'm an adult."");
10 }
11 
12 System.out.println(""Bye!"");
",Conditional blocks,code_fragment
459,"The if block may optionally be followed by an else block which will execute if that boolean expression is false. The structure of an if block is as follows:
",Conditional blocks,plain_text
460,"
",Conditional blocks,plain_text
461,"An else-if block may be used when multiple conditions need to be checked. else-if statements come after the if block, but before the else block. The structure of an if block is as follows:
",Conditional blocks,plain_text
462,"Here is an example to illustrate:
",Conditional blocks,plain_text
463," 1 public class MyConditionalProgram {
 2     public static void main (String[] args) {
 3       int a = 5;
 4       if (a > 0) {
 5           // a is greater than 0, so this statement will execute
 6           System.out.println(""a is positive"");
 7       } else if (a >= 0) {
 8           // a case has already executed, so this statement will NOT execute
 9           System.out.println(""a is positive or zero"");
10       } else {
11           // a case has already executed, so this statement will NOT execute
12           System.out.println(""a is negative"");
13       }
14     }
15 }
",Conditional blocks,code_fragment
464,"Keep in mind that only a single block will execute, and it will be the first true condition.
",Conditional blocks,plain_text
465,"All the conditions are evaluated when if is reached, no matter what the result of the condition is, after the execution of the if block:
",Conditional blocks,plain_text
466," 1 int a = 5;
 2 if (a > 0) {
 3     // a is greater than 0, so this statement will execute
 4     System.out.println(""a is positive"");
 5     a = -5;
 6 } else if (a < 0) {
 7     // a WAS greater than 0, so this statement will not execute
 8     System.out.println(""a is negative"");
 9 } else {
10     // a does not equal 0, so this statement will not execute
11     System.out.println(""a is zero"");
12 }
",Conditional blocks,code_fragment
467,"Conditional expressions use the compound ?: operator. Syntax:
",Conditional blocks,plain_text
468,"This evaluates boolean expression1, and if it is true then the conditional expression has the value of expression1; otherwise the conditional expression has the value of expression2.
",Conditional blocks,plain_text
469,"Example:
",Conditional blocks,plain_text
470,"1 String answer = (p < 0.05)? ""reject"" : ""keep"";
",Conditional blocks,code_fragment
471,"This is equivalent to the following code fragment:
",Conditional blocks,plain_text
472,"1 String answer;
2 if (p < 0.05) {
3     answer = ""reject"";
4 } else {
5     answer = ""keep"";
6 }
",Conditional blocks,code_fragment
473,"The switch conditional statement is basically a shorthand version of writing many if...else statements. The switch block evaluates a char, byte, short, or int (or enum, starting in J2SE 5.0; or String, starting in J2SE 7.0), and, based on the value provided, jumps to a specific case within the switch block and executes code until the break command is encountered or the end of the block.  If the switch value does not match any of the case values, execution will jump to the optional default case.
",Conditional blocks,plain_text
474,"The structure of a switch statement is as follows:
",Conditional blocks,plain_text
475,"Here is an example to illustrate:
",Conditional blocks,plain_text
476," 1 int i = 3;
 2 switch(i) {
 3     case 1:
 4         // i doesn't equal 1, so this code won't execute
 5         System.out.println(""i equals 1"");
 6         break;
 7     case 2:
 8         // i doesn't equal 2, so this code won't execute
 9         System.out.println(""i equals 2"");
10         break;
11     default:
12         // i has not been handled so far, so this code will execute
13         System.out.println(""i equals something other than 1 or 2"");
14 }
",Conditional blocks,code_fragment
477,"If a case does not end with the break statement, then the next case will be checked, otherwise the execution will jump to the end of the switch statement.
",Conditional blocks,plain_text
478,"Look at this example to see how it's done:
",Conditional blocks,plain_text
479," 1 int i = -1;
 2 switch(i) {
 3     case -1:
 4     case 1:
 5         // i is -1, so it will fall through to this case and execute this code
 6         System.out.println(""i is 1 or -1"");
 7         break;
 8     case 0:
 9         // The break command is used before this case, so if i is 1 or -1, this will not execute
10         System.out.println(""i is 0"");
11 }
",Conditional blocks,code_fragment
480,"Starting in J2SE 5.0, the switch statement can also be used with an enum value instead of an integer.
",Conditional blocks,plain_text
481,"Though enums have not been covered yet, here is an example so you can see how it's done (note that the enum constants in the cases do not need to be qualified with the type:
",Conditional blocks,plain_text
482," 1 Day day = Day.MONDAY; // Day is a fictional enum type containing the days of the week
 2 switch(day) {
 3     case MONDAY:
 4         // Since day == Day.MONDAY, this statement will execute
 5         System.out.println(""Mondays are the worst!"");
 6         break;
 7     case TUESDAY:
 8     case WEDNESDAY:
 9     case THURSDAY:
10         System.out.println(""Weekdays are so-so."");
11         break;
12     case FRIDAY:
13     case SATURDAY:
14     case SUNDAY:
15         System.out.println(""Weekends are the best!"");
16         break;
17 }
",Conditional blocks,code_fragment
483,"Starting in J2SE 7.0, the switch statement can also be used with an String value instead of an integer.
",Conditional blocks,plain_text
484," 1 String day = ""Monday"";
 2 switch(day) {
 3     case ""Monday"":
 4         // Since day == ""Monday"", this statement will execute
 5         System.out.println(""Mondays are the worst!"");
 6         break;
 7     case ""Tuesday"":
 8     case ""Wednesday"":
 9     case ""Thursday"":
10         System.out.println(""Weekdays are so-so."");
11         break;
12     case ""Friday"":
13     case ""Saturday"":
14     case ""Sunday"":
15         System.out.println(""Weekends are the best!"");
16         break;
17     default:
18         throw new IllegalArgumentException(""Invalid day of the week: "" + day);
19 }
",Conditional blocks,code_fragment
485,"
",Conditional blocks,plain_text
486,"
Loops are a handy tool that enables programmers to do repetitive tasks with minimal effort. Say we want a program that can count from 1 to 10, we could write the following program.
",Loop blocks,plain_text
487," 1 class Count {
 2     public static void main(String[] args) {
 3         System.out.println(""1 "");
 4         System.out.println(""2 "");
 5         System.out.println(""3 "");
 6         System.out.println(""4 "");
 7         System.out.println(""5 "");
 8         System.out.println(""6 "");
 9         System.out.println(""7 "");
10         System.out.println(""8 "");
11         System.out.println(""9 "");
12         System.out.println(""10 "");
13     }
14 }
",Loop blocks,code_fragment
488,"
The task will be completed just fine, the numbers 1 to 10 will be printed in the output, but there are a few problems with this solution:
",Loop blocks,plain_text
489,"Flexibility:  what if we wanted to change the start number or end number? We would have to go through and change them, adding extra lines of code where they're needed.
Scalability: 10 repeats are trivial, but what if we wanted 100 or even 1000 repeats? The number of lines of code needed would be overwhelming for a large number of iterations.
Maintenance: where there is a large amount of code, one is more likely to make a mistake.
Feature: the number of tasks is fixed and doesn't change at each execution.",Loop blocks,plain_text
490,"Using loops we can solve all these problems. Once you get you head around them they will be invaluable to solving many problems in programming.
",Loop blocks,plain_text
491,"Open up your editing program and create a new file saved as Loop.java. Now type or copy the following code:
",Loop blocks,plain_text
492,"1 class Loop {
2     public static void main(String[] args) {
3         int i;
4         for (i = 1; i <= 10; i++) {
5             System.out.println(i + "" "");
6         }
7     }
8 }
",Loop blocks,code_fragment
493,"If we run the program, the same result is produced, but looking at the code, we immediately see the advantages of loops. Instead of executing 10 different lines of code, line 5 executes ten times. 10 lines of code have been reduced to just 4. Furthermore, we may change the number 10 to any number we like. Try it yourself, replace the 10 with your own number.
",Loop blocks,plain_text
494,"while loops are the simplest form of loop. The while loop repeats a block of code while the specified condition is true. Here is the structure of a while loop:
",Loop blocks,plain_text
495,"The loop's condition is checked before each iteration of the loop. If the condition is false at the start of the loop, the loop will not be executed at all. The code section 3.28 sets in squareHigherThan200 the smallest integer whose square exceeds 200.
",Loop blocks,plain_text
496,"1 int squareHigherThan200 = 0;
2 
3 while (squareHigherThan200 * squareHigherThan200 < 200) {
4   squareHigherThan200 = squareHigherThan200 + 1;
5 }
",Loop blocks,code_fragment
497,"The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executes It is useful when we try to find a data that does the job by randomly browsing an amount of data.
",Loop blocks,plain_text
498,"The for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. It consists of the keyword for followed by three extra statements enclosed in parentheses. The first statement is the variable declaration statement, which allows you to declare one or more integer variables. The second is the condition, which is checked the same way as the while loop. Last is the iteration statement, which is used to increment or decrement variables, though any statement is allowed.
",Loop blocks,plain_text
499,"This is the structure of a for loop:
",Loop blocks,plain_text
500,"To clarify how a for loop is used, here is an example:
",Loop blocks,plain_text
501,"1 for (int i = 1; i <= 10; i++) {
2     System.out.println(i);
3 }
",Loop blocks,code_fragment
502,"The for loop is like a template version of the while loop. The alternative code using a while loop would be as follows:
",Loop blocks,plain_text
503,"1 int i = 1;
2 while (i <= 10) {
3   System.out.println(i);
4   i++;
5 }
",Loop blocks,code_fragment
504,"The code section 3.31 shows how to iterate with the for loop using multiple variables and the code section 3.32 shows how any of the parameters of a for loop can be skipped. Skip them all, and you have an infinitely repeating loop.
",Loop blocks,plain_text
505,"1 for (int i = 1, j = 10; i <= 10; i++, j--) {
2   System.out.print(i + "" "");
3   System.out.println(j);
4 }
",Loop blocks,code_fragment
506,"Arrays haven't been covered yet, but you'll want to know how to use the enhanced for loop, called the for-each loop. The for-each loop automatically iterates through a list or array and assigns the value of each index to a variable.
",Loop blocks,plain_text
507,"To understand the structure of a for-each loop, look at the following example:
",Loop blocks,plain_text
508,"1 String[] sentence = {""I"", ""am"", ""a"", ""Java"", ""program.""};
2 for (String word : sentence) {
3     System.out.print(word + "" "");
4 }
",Loop blocks,code_fragment
509,"The example iterates through an array of words and prints them out like a sentence. What the loop does is iterate through sentence and assign the value of each index to word, then execute the code block.
",Loop blocks,plain_text
510,"Here is the general contract of the for-each loop:
",Loop blocks,plain_text
511,"Make sure that the type of the array or list is assignable to the declared variable, or you will get a compilation error. Notice that the loop automatically exits after the last item in the collection has been examined in the statement
block.
",Loop blocks,plain_text
512,"Although the enhanced for loop can make code much clearer, it can't be used in some common situations.
",Loop blocks,plain_text
513,"Only access. Elements can not be assigned to, eg, not to increment each element in a collection.
Only single structure. It's not possible to traverse two structures at once, eg, to compare two arrays.
Only single element. Use only for single element access, eg, not to compare successive elements.
Only forward. It's possible to iterate only forward by single steps.
At least Java 5. Don't use it if you need compatibility with versions before Java 5.",Loop blocks,plain_text
514,,Break and continue keywords[edit],
515,"The break keyword exits a flow control loop, such as a for loop. It basically breaks the loop.
",Break and continue keywords[edit],plain_text
516,"In the code section 3.34, the loop would print out all the numbers from 1 to 10, but we have a check for when i equals 5. When the loop reaches its fifth iteration, it will be cut short by the break statement, at which point it will exit the loop.
",Break and continue keywords[edit],plain_text
517,"1 for (int i = 1; i <= 10; i++) {
2     System.out.println(i);
3     if (i == 5) {
4        System.out.println(""STOP!"");
5        break;
6     }
7 }
",Break and continue keywords[edit],code_fragment
518,"The continue keyword jumps straight to the next iteration of a loop and evaluates the boolean expression controlling the loop. The code section 3.35 is an example of the continue statement in action:
",Break and continue keywords[edit],plain_text
519,"1 for (int i = 1; i <= 10; i++) {
2     if (i == 5) {
3         System.out.println(""Caught i == 5"");
4         continue;
5     }
6     System.out.println(i);
7 }
",Break and continue keywords[edit],code_fragment
520,"As the break and continue statements reduce the readability of the code, it is recommended to reduce their use or replace them with the use of if and while blocks. Some IDE refactoring operations will fail because of such statements.
",Break and continue keywords[edit],plain_text
521," 1 int numberOfItems = 5;
 2 int currentItems = 0;
 3 int currentCandidate = 1;
 4 
 5 while (currentItems < numberOfItems) {
 6   currentCandidate = currentCandidate + 1;
 7   System.out.println(""Test with integer: "" + currentCandidate);
 8  
 9   boolean found = true;
10   for (int i = currentCandidate - 1; i > 1; i--) {
11    
12     // Test if i is a divisor of currentCandidate
13     if ((currentCandidate % i) == 0) {
14       System.out.println(""Not matching..."");
15       found = false;
16       break;
17     }
18    
19   }
20  
21   if (found) {
22     System.out.println(""Matching!"");
23     currentItems = currentItems + 1;
24   }
25 }
26 
27 System.out.println(""Find the value: "" + currentCandidate);
",Break and continue keywords[edit],code_fragment
522,,Labels[edit],
523,"Labels can be used to give a name to a loop. The reason to do this is so we can break out of or continue with upper-level loops from a nested loop.
",Labels[edit],plain_text
524,"Here is how to label a loop:
",Labels[edit],plain_text
525,"To break out of or continue with a loop, use the break or continue keyword followed by the name of the loop.
",Labels[edit],plain_text
526,"For example:
",Labels[edit],plain_text
527," 1 int i, j;
 2 int[][] nums = {
 3     {1, 2, 5},
 4     {6, 9, 7},
 5     {8, 3, 4}
 6 };
 7 
 8 Outer:
 9 for (i = 0; i < nums.length; i++) {
10     for (j = 0; j < nums[i].length; j++) {
11         if (nums[i][j] == 9) {
12             System.out.println(""Found number 9 at ("" + i + "", "" + j + "")"");
13             break Outer;
14         }
15     }
16 }
",Labels[edit],code_fragment
528,"You needn't worry if you don't understand all the code, but look at how the label is used to break out of the outer loop from the inner loop. However, as such a code is hard to read and maintain, it is highly recommended not to use labels.
",Labels[edit],plain_text
529,,Try... catch blocks[edit],
530,"The try-catch blocks are used to catch any exceptions or other throwable objects within the code.
",Try... catch blocks[edit],plain_text
531,"Here's what try-catch blocks looks like:
",Try... catch blocks[edit],plain_text
532,"The code listing 3.6 tries to print all the arguments that have been passed to the program. However, if there not enough arguments, it will throw an exception.
",Try... catch blocks[edit],plain_text
533," 1 public class Attempt {
 2   public static void main(String[] args) {
 3     try {
 4       System.out.println(args[0]);
 5       System.out.println(args[1]);
 6       System.out.println(args[2]);
 7       System.out.println(args[3]);
 8     } catch (ArrayIndexOutOfBoundsException e) {
 9       System.out.println(""Not enough arguments"");
10     }
11   }
12 }
",Try... catch blocks[edit],code_fragment
534,"In addition to the try and catch blocks, a finally block may be present. The finally block is always executed, even if an exception is thrown. It may appear with or without a catch block, but always with a try block.
",Try... catch blocks[edit],plain_text
535,"Here is what a finally block looks like:
",Try... catch blocks[edit],plain_text
536,,Examples[edit],
537,"The code listing 3.7 recieves a number as parameter and print its binary representation.
",Examples[edit],plain_text
538," 1 public class GetBinary {
 2     public static void main(String[] args) {
 3         if (args.length == 0) {
 4             // Print usage
 5             System.out.println(""Usage: java GetBinary <decimal integer>"");
 6             System.exit(0);
 7         } else {
 8             // Print arguments
 9             System.out.println(""Received "" + args.length + "" arguments."");
10             System.out.println(""The arguments are:"");
11             for (String arg : args) {
12                 System.out.println(""\t"" + arg);
13             }
14         }
15 
16         int number = 0;
17         String binary = """";
18 
19         // Get the input number
20         try {
21             number = Integer.parseInt(args[0]);
22         } catch (NumberFormatException ex) {
23             System.out.println(""Error: argument must be a base-10 integer."");
24             System.exit(0);
25         }
26 
27         // Convert to a binary string
28         do {
29             switch (number % 2) {
30                 case 0: binary = '0' + binary; break;
31                 case 1: binary = '1' + binary; break;
32             }
33             number >>= 1;
34         } while (number > 0);
35 
36         System.out.println(""The binary representation of "" + args[0] + "" is "" + binary);
37     }
38 }
",Examples[edit],code_fragment
539,"The code listing 3.8 is a simulation of playing a game called Lucky Sevens. It is a dice game where the player rolls two dice. If the numbers on the dice add up to seven, he wins $4. If they do not, he loses $1. The game shows how to use control flow in a program as well as the fruitlessness of gambling.
",Examples[edit],plain_text
540," 1 import java.util.*;
 2 
 3 public class LuckySevens {
 4     public static void main(String[] args) {
 5         Scanner in = new Scanner(System.in);
 6         Random random = new Random();
 7         String input;
 8         int startingCash, cash, maxCash, rolls, roll;
 9 
10         // Loop until ""quit"" is input
11         while (true) {
12             System.out.print(""Enter the amount of cash to start with (or \""quit\"" to quit): "");
13 
14             input = in.nextLine();
15 
16             // Check if user wants to exit
17             if (input.toLowerCase().equals(""quit"")) {
18                 System.out.println(""\tGoodbye."");
19                 System.exit(0);
20             }
21 
22             // Get number
23             try {
24                 startingCash = Integer.parseInt(input);
25             } catch (NumberFormatException ex) {
26                 System.out.println(""\tPlease enter a positive integer greater than 0."");
27                 continue;
28             }
29 
30             // You have to start with some money!
31             if (startingCash <= 0) {
32                 System.out.println(""\tPlease enter a positive integer greater than 0."");
33                 continue;
34             }
35 
36             cash = startingCash;
37             maxCash = cash;
38             rolls = 0;
39             roll = 0;
40 
41             // Here is the game loop
42             for (; cash > 0; rolls++) {
43                roll = random.nextInt(6) + 1;
44                roll += random.nextInt(6) + 1;
45 
46                 if (roll == 7)
47                     cash += 4;
48                 else
49                     cash -= 1;
50 
51                 if (cash > maxCash)
52                     maxCash = cash;
53             }
54 
55             System.out.println(""\tYou start with $"" + startingCash + "".\n""
56                     + ""\tYou peak at $"" + maxCash + "".\n""
57       + ""\tAfter "" + rolls + "" rolls, you run out of cash."");
58         }
59     }
60 }
",Examples[edit],code_fragment
541,"
",Examples[edit],plain_text
542,"
Boolean values are values that evaluate to either true or false, and are represented by the boolean data type.  Boolean expressions are very similar to mathematical expressions, but instead of using mathematical operators such as ""+"" or ""-"", you use comparative or boolean operators such as ""=="" or ""!"".
",Boolean expressions,plain_text
543,,Comparative operators[edit],
544,"Java has several operators that can be used to compare variables.  For example, how would you tell if one variable has a greater value than another?  The answer: use the ""greater-than"" operator.
",Comparative operators[edit],plain_text
545,"Here is a list of the comparative operators in Java:
",Comparative operators[edit],plain_text
546,"> : Greater than
< : Less than
>= : Greater than or equal to
<= : Less than or equal to
== : Equal to
!= : Not equal to",Comparative operators[edit],plain_text
547,"To see how these operators are used, look at this example:
",Comparative operators[edit],plain_text
548,"1 int a = 5, b = 3;
2 System.out.println(a > b); // Value is true because a is greater than b
3 System.out.println(a == b); // Value is false because a does not equal b
4 System.out.println(a != b); // Value is true because a does not equal b
5 System.out.println(b <= a); // Value is true because b is less than a
",Comparative operators[edit],code_fragment
549,"Comparative operators can be used on any primitive types (except boolean), but only the ""equals"" and ""does not equal"" operators work on objects.  This is because the less-than/greater-than operators cannot be applied to objects, but the equivalency operators can.
",Comparative operators[edit],plain_text
550,,Boolean operators[edit],
551,"The Java boolean operators are based on the operations of the boolean algebra. The boolean operators operate directly on boolean values.
",Boolean operators[edit],plain_text
552,"Here is a list of four common boolean operators in Java:
",Boolean operators[edit],plain_text
553,"! : Boolean NOT
&& : Boolean AND
|| : Boolean inclusive OR
^ : Boolean exclusive XOR",Boolean operators[edit],plain_text
554,"The boolean NOT operator (""!"") inverts the value of a boolean expression.  The boolean AND operator (""&&"") will result in true if and only if the values on both sides of the operator are true.  The boolean inclusive OR operator (""||"") will result in true if either or both of the values on the sides of the operator is true.  The boolean exclusive XOR operator (""^"") will result in true if one and only of the values on the sides of the operator is true.
",Boolean operators[edit],plain_text
555,"To show how these operators are used, here is an example:
",Boolean operators[edit],plain_text
556," 1 boolean iMTrue = true;
 2 boolean iMTrueToo = true;
 3 boolean iMFalse = false;
 4 boolean iMFalseToo = false;
 5 
 6 System.out.println(""NOT operand:"");
 7 System.out.println(!iMTrue);
 8 System.out.println(!iMFalse);
 9 System.out.println(!(4 < 5));
10 System.out.println(""AND operand:"");
11 System.out.println(iMTrue && iMTrueToo);
12 System.out.println(iMFalse && iMFalseToo);
13 System.out.println(iMTrue && iMFalse);
14 System.out.println(iMTrue && !iMFalse);
15 System.out.println(""OR operand:"");
16 System.out.println(iMTrue || iMTrueToo);
17 System.out.println(iMFalse || iMFalseToo);
18 System.out.println(iMTrue || iMFalse);
19 System.out.println(iMFalse || !iMTrue);
20 System.out.println(""XOR operand:"");
21 System.out.println(iMTrue ^ iMTrueToo);
22 System.out.println(iMFalse ^ iMFalseToo);
23 System.out.println(iMTrue ^ iMFalse);
24 System.out.println(iMFalse ^ !iMTrue);
",Boolean operators[edit],code_fragment
557,"Here are the truth tables for the boolean operators:
",Boolean operators[edit],plain_text
558,"In Java, boolean logic has a useful property called short circuiting.  This means that expressions will only be evaluated as far as necessary.  In the expression (a && b), if a is false, then b will not be evaluated because the expression will be false no matter what. Here is an example that shows that the second expression is not automatically checked:
",Boolean operators[edit],plain_text
559,"1 System.out.println((4 < 5) || ((10 / 0) == 2));
",Boolean operators[edit],code_fragment
560,"To disable this property, you can use & instead of && and | instead of || but it's not recommended.
",Boolean operators[edit],plain_text
561,"
",Boolean operators[edit],plain_text
562,"In the Java programming language, the words field and variable are both one and the same thing. Variables are devices that are used to store data, such as a number, or a string of character data.
",Variables,plain_text
563,,Variables in Java programming[edit],
564,"Java is considered as a strongly typed programming language. Thus all variables in the Java programming language ought to have a particular data type. This is either declared or inferred and the Java language only allows programs to run if they adhere to type constraints.
",Variables in Java programming[edit],plain_text
565,"If you present a numeric type with data that is not numeric, say textual content, then such declarations would violate Java’s type system. This gives Java the ability of type safety. Java checks if an expression or data is encountered with an incorrect type or none at all. It then automatically flags this occurrence as an error at compile time. Most type-related errors are caught by the Java compiler, hence making a program more secure and safe once compiled completely and successfully. Some languages (such as C) define an interpretation of such a statement and use that interpretation without any warning; others (such as PL/I) define a conversion for almost all such statements and perform the conversion to complete the assignment. Some type errors can still occur at runtime because Java supports a cast operation which is a way of changing the type of one expression to another. However, Java performs run time type checking when doing such casts, so an incorrect type cast will cause a runtime exception rather than succeeding silently and allowing data corruption.
",Variables in Java programming[edit],plain_text
566,"On the other hand, Java is also known as a hybrid language. While supporting object oriented programming (OOP), Java is not a pure OO language like Smalltalk or Ruby. Instead, Java offers both object types and primitive types. Primitive types are used for boolean, character, and numeric values and operations. This allows relatively good performance when manipulating numeric data, at the expense of flexibility. For example, you cannot subclass the primitive types and add new operations to them.
",Variables in Java programming[edit],plain_text
567,,Kinds of variables[edit],
568,"In the Java programming language, there are four kinds of variables.
",Kinds of variables[edit],plain_text
569,"1 public class ClassWithVariables {
2     public int id = 0;
3     public static boolean isClassUsed;
4 
5     public void processData(String parameter) {
6       Object currentValue = null;
7     }
8 }
",Kinds of variables[edit],code_fragment
570,"In the code listing 3.9, are examples of all four kinds of variables.
",Kinds of variables[edit],plain_text
571,"Instance variables: These are variables that are used to store the state of an object (for example, id). Every object created from a class definition would have its own copy of the variable. It is valid for and occupies storage for as long as the corresponding object is in memory.
Class variables: These variables are explicitly defined within the class-level scope with a static modifier (for example, isClassUsed). No other variables can have a static modifier attached to them. Because these variables are defined with the static modifier, there would always be a single copy of these variables no matter how many times the class has been instantiated. They live as long as the class is loaded in memory.
Parameters or Arguments: These are variables passed into a method signature (for example, parameter). Recall the usage of the args variable in the main method. They are not attached to modifiers (i.e. public, private, protected or static) and they can be used everywhere in the method. They are in memory during the execution of the method and can't be used after the method returns.
Local variables: These variables are defined and used specifically within the method-level scope (for example, currentValue) but not in the method signature. They do not have any modifiers attached to it. They no longer exist after the method has returned.",Kinds of variables[edit],plain_text
572," 1 public class SomeClass {
 2   public static int c = 1;
 3   public int a = c;
 4   private int b;
 5 
 6   public void someMethod(int d) {
 7     d = c;
 8     int e;
 9   }
10 }
",Kinds of variables[edit],code_fragment
573,,Creating variables[edit],
574,"Variables and all the information they store are kept in the computer's memory for access. Think of a computer's memory as a table of data — where each cell corresponds to a variable.
",Creating variables[edit],plain_text
575,"Upon creating a variable, we basically create a new address space and give it a unique name. Java goes one step further and lets you define what you can place within the variable — in Java parlance you call this a data type. So, you essentially have to do two things in order to create a variable:
",Creating variables[edit],plain_text
576,"Create a variable by giving it a unique name; and,
Define a data type for the variable.",Creating variables[edit],plain_text
577,"The following code demonstrates how a simple variable can be created. This process is known as variable declaration.
",Creating variables[edit],plain_text
578,"1 int a;
",Creating variables[edit],code_fragment
579,,Assigning values to variables[edit],
580,"Because we have provided a data type for the variable, we have a hint as to what the variable can and cannot hold. We know that int (integer) data type supports numbers that are either positive or negative integers. Therefore once a variable is created, we can provide it with any integer value using the following syntax. This process is called an assignment operation.
",Assigning values to variables[edit],plain_text
581,"1 int a;
2 a = 10;
",Assigning values to variables[edit],code_fragment
582,"Java provides programmers with a simpler way of combining both variable declaration and assignment operation in one line. Consider the following code:
",Assigning values to variables[edit],plain_text
583,"1 int a = 10;
",Assigning values to variables[edit],code_fragment
584,,Grouping variable declarations and assignment operations[edit],
585,"Consider the following code:
",Grouping variable declarations and assignment operations[edit],plain_text
586,"1 int a;
2 int b;
3 String c;
4 a = 10;
5 b = 20;
6 c = ""some text"";
",Grouping variable declarations and assignment operations[edit],code_fragment
587,"There are various ways by which you can streamline the writing of this code. You can group the declarations of similar data types in one statement, for instance:
",Grouping variable declarations and assignment operations[edit],plain_text
588,"1 int a, b;
2 String c;
3 a = 10;
4 b = 20;
5 c = ""some text"";
",Grouping variable declarations and assignment operations[edit],code_fragment
589,"Alternatively, you can further reduce the syntax by doing group declarations and assignments together, as such:
",Grouping variable declarations and assignment operations[edit],plain_text
590,"1 int a = 10, b = 20;
2 String c = ""some text"";
",Grouping variable declarations and assignment operations[edit],code_fragment
591,,Identifiers[edit],
592,"Although memory spaces have their own addresses — usually a hash number such as 0xCAD3, etc. — it is much easier to remember a variable's location in the memory if we can give it a recognizable name. Identifiers are the names we give to our variables. You can name your variable anything like aVariable, someVariable, age, someonesImportantData, etcetera. But notice: none of the names we described here has a space within it. Hence, it is pretty obvious that spaces aren't allowed in variable names. In fact, there are a lot of other things that are not allowed in variable names. The things that are allowed are:
",Identifiers[edit],plain_text
593,"Characters A to Z and their lower-case counterparts a to z.
Numbers 0 to 9. However, numbers should not come at the beginning of a variable's name.
And finally, special characters that include only $ (dollar sign) and _ (underscore).",Identifiers[edit],plain_text
594,"Any valid variable names might be correct but they are not always what you should be naming your variables for a few reasons as listed below:
",Identifiers[edit],plain_text
595,"The name of the variable should reflect the value within them.
The identifier should be named following the naming guidelines or conventions for doing so. We will explain that in a bit.
The identifier shouldn't be a nonsense name like lname, you should always name it properly: lastName is the best way of naming a variable.",Identifiers[edit],plain_text
596,,Naming conventions for identifiers[edit],
597,"When naming identifiers, you need to use the following guidelines which ensure that your variables are named accurately. As we discussed earlier, we should always name our variables in a way that tells us what they hold. Consider this example:
",Naming conventions for identifiers[edit],plain_text
598,"1 int a = 24;
2 int b = 365;
3 int c = a * b;
",Naming conventions for identifiers[edit],code_fragment
599,"Do you know what this program does? Well, it multiplies two values. That much you guessed right. But, do you know what those values are? Exactly, you don't. Now consider this code:
",Naming conventions for identifiers[edit],plain_text
600,"1 int age = 24;
2 int daysInYear = 365;
3 int ageInDays = age * daysInYear;
",Naming conventions for identifiers[edit],code_fragment
601,"Now you can tell what's happening, can't you? However, before we continue, notice the case of the variables. If a word contains CAPITAL LETTERS, it is in UPPER CASE. If a word has small letters, it is in lower case. Both cases in a word renders it as mIxEd CaSe.
",Naming conventions for identifiers[edit],plain_text
602,"The variables we studied so far had a mixed case. When there are two or more words making up the names of a variable, you need to use a special case called the camel-case. Just like the humps of a camel, your words need to stand out. Using this technique, the words first and name could be written as either firstName or FirstName.
",Naming conventions for identifiers[edit],plain_text
603,"The first instance, firstName is what we use as the names of variables. Remember though, firstName is not the same as FirstName because Java is case-sensitive. Case-sensitive basically implies that the case in which you wrote one word is the case you have to call that word in when using them later on. Anything other than that is not the same as you intended. You'll know more as you progress. You can hopefully tell now why the variables you were asked to identify weren't proper.
",Naming conventions for identifiers[edit],plain_text
604,,Literals (values)[edit],
605,"Now that we know how variables should be named, let us look at the values of those variables. Simple values like numbers are called literals. This section shows you what literals are and how to use them. Consider the following code:
",Literals (values)[edit],plain_text
606,"1 int age = 24;
2 long bankBalance = 20000005L;
",Literals (values)[edit],code_fragment
607,"By now, we've only seen how numbers work in assignment statements. Let's look at data types other than numbers. Characters are basically letters of the English alphabet. When writing a single character, we use single quotes to encapsulate them. Take a look at the code below:
",Literals (values)[edit],plain_text
608,"1 char c = 'a';
",Literals (values)[edit],code_fragment
609,"Why, you ask? Well, the explanation is simple. If written without quotes, the system would think it's a variable identifier. That's the very distinction you have to make when differentiating between variables and their literal values. Character data types are a bit unusual. First, they can only hold a single character. What if you had to store a complete name within them, say John, would you write something like:
",Literals (values)[edit],plain_text
610,"1 char firstChar = 'J';
2 char secondChar = 'o';
3 char thirdChar = 'h';
4 char fourthChar = 'n';
",Literals (values)[edit],code_fragment
611,"Now, that's pathetic. Thankfully, there's a data type that handles large number of characters, it's called a String. A string can be initialized as follows:
",Literals (values)[edit],plain_text
612,"1 String name = ""John"";
",Literals (values)[edit],code_fragment
613,"Notice, the use of double quotation marks instead of single quotation marks. That's the only thing you need to worry about.
",Literals (values)[edit],plain_text
614,"
",Literals (values)[edit],plain_text
615,"
Primitive types are the most basic data types available within the Java language. There are 8: boolean, byte, char, short, int, long, float and double. These types serve as the building blocks of data manipulation in Java. Such types serve only one purpose — containing pure, simple values of a kind. Because these data types are defined into the Java type system by default, they come with a number of operations predefined. You can not define a new operation for such primitive types. In the Java type system, there are three further categories of primitives:
",Primitive Types,plain_text
616,"Numeric primitives: short, int, long, float and double. These primitive data types hold only numeric data. Operations associated with such data types are those of simple arithmetic (addition, subtraction, etc.) or of comparisons (is greater than, is equal to, etc.)
Textual primitives: byte and char. These primitive data types hold characters (that can be Unicode alphabets or even numbers). Operations associated with such types are those of textual manipulation (comparing two words, joining characters to make words, etc.). However, byte and char can also support arithmetic operations.
Boolean and null primitives: boolean and null.",Primitive Types,plain_text
617,"All the primitive types have a fixed size. Thus, the primitive types are limited to a range of values. A smaller primitive type (byte) can contain less values than a bigger one (long).
",Primitive Types,plain_text
618,"Integer primitive types silently overflow:
",Primitive Types,plain_text
619,"1 int i = Integer.MAX_VALUE;
2 System.out.println(i);
3 i = i + 1;
4 System.out.println(i);
5 System.out.println(Integer.MIN_VALUE);
",Primitive Types,code_fragment
620,"As Java is strongly typed, you can't assign a floating point number (a number with a decimal point) to an integer variable:
",Primitive Types,plain_text
621,"1 int age;
2 age = 10.5;
",Primitive Types,code_fragment
622,"A primitive type should be set by an appropriate value. The primitive types can be initialized with a literal. Most of the literals are primitive type values, except String Literals, which are instance of the String class.
",Primitive Types,plain_text
623,,Numbers in computer science[edit],
624,"Programming may not be as trivial or boring as just crunching huge numbers any more. However, huge chunks of code written in any programming language today, let alone Java, obsessively deal with numbers, be it churning out huge prime numbers,[1] or just calculating a cost of emission from your scooter. In 1965, Gemini V space mission escaped a near-fatal accident caused by a programming error.[2] Again in 1979, a computer program overestimated the ability of five nuclear reactors to withstand earthquakes; the plants shut down temporarily.[3] There is one thing common to both these programming errors: the subject data, being computed at the time the errors occurred, was numeric. Out of past experience, Java came bundled with revised type checking for numeric data and put significant emphasis on correctly identifying different types of it. You must recognise the importance of numeric data when it comes to programming.
",Numbers in computer science[edit],plain_text
625,"Numbers are stored in memory using a binary system. The memory is like a grid of cells:
",Numbers in computer science[edit],plain_text
626,"Each cell can contain a binary digit (shortened to bit), that is to say, zero or one:
",Numbers in computer science[edit],plain_text
627,"Actually, each cell does contain a binary digit, as one bit is roughly equivalent to 1 and an empty cell in the memory signifies 0. A single binary digit can only hold two possible values: a zero or a one.
",Numbers in computer science[edit],plain_text
628,"Multiple bits held together can hold multiple permutations — 2 bits can hold 4 possible values, 3 can hold 8, and so on. For instance, the maximum number 8 bits can hold (11111111 in binary) is 255 in the decimal system. So, the numbers from 0 to 255 can fit within 8 bits.
",Numbers in computer science[edit],plain_text
629,"It is all good, but this way, we can only host positive numbers (or unsigned integers). They are called unsigned integers. Unsigned integers are whole number values that are all positive and do not attribute to negative values. For this very reason, we would ask one of the 8 bits to hold information about the sign of the number (positive or negative). This leaves us with just 7 bits to actually count out a number. The maximum number that these 7 bits can hold (1111111) is 127 in the decimal system.
",Numbers in computer science[edit],plain_text
630,"Altogether, using this method, 8 bits can hold numbers ranging from -128 to 127 (including zero) — a total of 256 numbers. Not a bad pay-off one might presume. The opposite to an unsigned integer is a signed integer that have the capability of holding both positive and negative values.
",Numbers in computer science[edit],plain_text
631,"But, what about larger numbers. You would need significantly more bits to hold larger numbers. That's where Java's numeric types come into play. Java has multiple numeric types — their size dependent on the number of bits that are at play.
",Numbers in computer science[edit],plain_text
632,"In Java, numbers are dealt with using data types specially formulated to host numeric data. But before we dive into these types, we must first set some concepts in stone. Just like you did in high school (or even primary school), numbers in Java are placed in clearly distinct groups and systems. As you'd already know by now, number systems includes groups like the integer numbers (0, 1, 2 ... ∞); negative integers (0, -1, -2 ... -∞) or even real and rational numbers (value of Pi, ¾, 0.333~, etcetera). Java simply tends to place these numbers in two distinct groups, integers (-∞ ... 0 ... ∞) and floating point numbers (any number with decimal points or fractional representation). For the moment, we would only look into integer values as they are easier to understand and work with.
",Numbers in computer science[edit],plain_text
633,,Integer types in Java[edit],
634,"With what we have learned so far, we will identify the different types of signed integer values that can be created and manipulated in Java. Following is a table of the most basic numeric types: integers. As we have discussed earlier, the data types in Java for integers caters to both positive and negative values and hence are signed numeric types. The size in bits for a numeric type determines what its minimum and maximum value would be. If in doubt, one can always calculate these values.
",Integer types in Java[edit],plain_text
635,"Lets see how this new found knowledge of the basic integer types in Java fits into the picture. Say, you want to numerically manipulate the days in a year — all 365 days. What type would you use? Since the data type byte only goes up to 127, would you risk giving it a value greater than its allowed maximum. Such decisions might save you from dreaded errors that might occur out of the programmed code. A much more sensible choice for such a numeric operation might be a short. Oh, why couldn't they make just one data type to hold all kinds of numbers? Wouldn't you ask that question? Well, let's explore why.
",Integer types in Java[edit],plain_text
636,"When you tell a program you need to use an integer, say even a byte, the Java program allocates a space in the memory. It allocates whole 8 bits of memory. Where it wouldn't seem to matter for today's memory modules that have place for almost a dozen trillion such bits, it matters in other cases. Once allocated that part of the memory gets used and can only be claimed back after the operation is finished. Consider a complicated Java program where the only data type you'd be using would be long integers. What happens when there's no space for more memory allocation jobs? Ever heard of the Stack Overflow errors. That's exactly what happens — your memory gets completely used up and fast. So, choose your data types with extreme caution.
",Integer types in Java[edit],plain_text
637,"Enough talk, let's see how you can create a numeric type. A numeric type begins with the type's name (short, int, etc.) and then provides with a name for the allocated space in the memory. Following is how it's done. Say, we need to create a variable to hold the number of days in a year.
",Integer types in Java[edit],plain_text
638,"1 short daysInYear = 365;
",Integer types in Java[edit],code_fragment
639,"Here, daysInYear is the name of the variable that holds 365 as its value, while short is the data type for that particular value. Other uses of integer data types in Java might see you write code such as this given below:
",Integer types in Java[edit],plain_text
640,"1 byte maxByte = 127;
2 short maxShort = 32767;
3 int maxInt = 2147483647;
4 long maxLong = 9223372036854775807L;
",Integer types in Java[edit],code_fragment
641,,Integer numbers and floating point numbers[edit],
642,"The data types that one can use for integer numbers are byte, short, int and long but when it comes to floating point numbers, we use float or double. Now that we know that, we can modify the code in the code section 3.53 as:
",Integer numbers and floating point numbers[edit],plain_text
643,"1 double age = 10.5;
",Integer numbers and floating point numbers[edit],code_fragment
644,"Why not float, you say? If we'd used a float, we would have to append the number with a f as a suffix, so 10.5 should be 10.5f as in:
",Integer numbers and floating point numbers[edit],plain_text
645,"1 float age = 10.5f;
",Integer numbers and floating point numbers[edit],code_fragment
646,"Floating-point math never throws exceptions. Dividing a non-zero value by 0 equals infinity. Dividing a non-infinite value by infinity equals 0.
",Integer numbers and floating point numbers[edit],plain_text
647," 5 ...
 6 
 7 a = false;
 8 b = 3.2;
 9 c = 35;
10 d = -93485L;
11 e = 'q';
",Integer numbers and floating point numbers[edit],code_fragment
648,,Data conversion (casting)[edit],
649,"Data conversion (casting) can happen between two primitive types. There are two kinds of casting:
",Data conversion (casting)[edit],plain_text
650,"Implicit: casting operation is not required; the magnitude of the numeric value is always preserved. However, precision may be lost when converting from integer to floating point types
Explicit: casting operation required; the magnitude of the numeric value may not be preserved",Data conversion (casting)[edit],plain_text
651,"1 int  i = 65;
2 long l = i;
",Data conversion (casting)[edit],code_fragment
652,"1 long l = 656666L;
2 int  i = (int) l;
",Data conversion (casting)[edit],code_fragment
653,"The following table shows the conversions between primitive types, it shows the casting operation for explicit conversions:
",Data conversion (casting)[edit],plain_text
654,"Unlike C, C++ and similar languages, Java can't represent false as 0 or null and can't represent true as non-zero. Java can't cast from boolean to a non-boolean primitive data type, or vice versa.
",Data conversion (casting)[edit],plain_text
655,"
For non primitive types:
",Data conversion (casting)[edit],plain_text
656,,Notes[edit],
657,"In order to do arithmetic in Java, one must first declare at least one variable. Typically one declares a variable and assigns it a value before any arithmetic is done. Here's an example of declaring an integer variable:
",Arithmetic expressions,plain_text
658,"1 int x = 5;
",Arithmetic expressions,code_fragment
659,"After creating a variable, one can manipulate its value by using Java's operators: + (addition), - (subtraction), * (multiplication), / (integer division), % (modulo or remainder), ++ (pre- & postincrement by one), -- (pre- & postdecrement by one).
",Arithmetic expressions,plain_text
660," 1 public class Operators {
 2   public static void main(String[] args) {
 3     int x = 5;
 4     System.out.println(""x = "" + x);
 5     System.out.println();
 6    
 7     System.out.println(""--- Addition             ---"");
 8     x = 5;
 9     System.out.println(""x + 2 = "" + (x + 2));
10     System.out.println(""x = "" + x);
11     System.out.println();
12    
13     System.out.println(""--- Subtraction          ---"");
14     x = 5;
15     System.out.println(""x - 4 = "" + (x - 4));
16     System.out.println(""x = "" + x);
17     System.out.println();
18    
19     System.out.println(""--- Multiplication       ---"");
20     x = 5;
21     System.out.println(""x * 3 = "" + (x * 3));
22     System.out.println(""x = "" + x);
23     System.out.println();
24    
25     System.out.println(""--- (Integer) Division   ---"");
26     x = 5;
27     System.out.println(""x / 2 = "" + (x / 2));
28     System.out.println(""x = "" + x);
29     System.out.println();
30    
31     System.out.println(""--- Modulo (Remainder)   ---"");
32     x = 5;
33     System.out.println(""x % 2 = "" + (x % 2));
34     System.out.println(""x = "" + x);
35     System.out.println();
36    
37     System.out.println(""--- Preincrement by one  ---"");
38     x = 5;
39     System.out.println(""++x   = "" + (++x  ));
40     System.out.println(""x = "" + x);
41     System.out.println();
42    
43     System.out.println(""--- Predecrement by one  ---"");
44     x = 5;
45     System.out.println(""--x   = "" + (--x  ));
46     System.out.println(""x = "" + x);
47     System.out.println();
48    
49     System.out.println(""--- Postincrement by one ---"");
50     x = 5;
51     System.out.println(""x++   = "" + (x++  ));
52     System.out.println(""x = "" + x);
53     System.out.println();
54    
55     System.out.println(""--- Postdecrement by one ---"");
56     x = 5;
57     System.out.println(""x--   = "" + (x--  ));
58     System.out.println(""x = "" + x);
59     System.out.println();
60   }
61 }
",Arithmetic expressions,code_fragment
661,"The division operator rounds towards zero: 5/2 is 2, and -5/2 is -2.
The remainder operator has the same sign as the left operand; it is defined such that ((a/b)*b) + (a%b) is always equal to a.
The preincrement, predecrement, postincrement, and postdecrement operators are special: they also change the value of the variable, by adding or subtracting one. The only difference is that preincrement/decrement returns the new value of the variable; postincrement returns the original value of the variable.
",Arithmetic expressions,plain_text
662," 1 public class Question8 {
 2   public static void main(String[] args) {
 3     int x = 10;
 4     x = x + 10;
 5     x = 2 * x;
 6     x = x - 19;
 7     x = x / 3;
 8     System.out.println(x);
 9   }
10 }
",Arithmetic expressions,code_fragment
663,"When using several operators in the same expression, one must consider Java's order of precedence. Java uses the standard PEMDAS (Parenthesis, Exponents, Multiplication and Division, Addition and Subtraction) order. When there are multiple instances of the same precedence, Java reads from left to right. Consider what the output of the following code would be:
",Arithmetic expressions,plain_text
664,"1 System.out.println(10*5 + 100/10 - 5 + 7%2);
",Arithmetic expressions,code_fragment
665,"The following chart shows how Java would compute this expression:
",Arithmetic expressions,plain_text
666,"
",Arithmetic expressions,plain_text
667,"
Besides performing mathematical functions, there are also operators to assign numbers to variables (each example again uses the variable initialized as x = 5):
",Arithmetic expressions,plain_text
668," 1 public class Assignments {
 2   public static void main(String[] args) {
 3     int x = 5;
 4     x = 3;
 5     System.out.println(""Assignment                                       (x = 3) : "" + x);
 6 
 7     x = 5;
 8     x += 5;
 9     System.out.println(""Assign x plus another integer to itself          (x += 5): "" + x);
10 
11     x = 5;
12     x -= 4;
13     System.out.println(""Assign x minus another integer to itself         (x -= 4): "" + x);
14 
15     x = 5;
16     x *= 6;
17     System.out.println(""Assign x multiplied by another integer to itself (x *= 6): "" + x);
18 
19     x = 5;
20     x /= 5;
21     System.out.println(""Assign x divided by another integer to itself    (x /= 5): "" + x);
22   }
23 }
",Arithmetic expressions,code_fragment
669,,Using bitwise operators within Java[edit],
670,"Java has besides arithmetic operators a set of bit operators to manipulate the bits in a number, and a set of logical operators. The bitwise logical operators are
",Using bitwise operators within Java[edit],plain_text
671,"Besides these logical bitwise functions, there are also operators to assign numbers to variables (x = -5):
",Using bitwise operators within Java[edit],plain_text
672,"The shift operators are used to shift the bits to the left or right, which is also a quick way to multiply/divide by two:
",Using bitwise operators within Java[edit],plain_text
673,"
",Using bitwise operators within Java[edit],plain_text
674,"Java Literals are syntactic representations of boolean, character, numeric, or string data. Literals provide a means of expressing specific values in your program. For example, in the following statement, an integer variable named count is declared and assigned an integer value. The literal 0 represents, naturally enough, the value zero.
",Literals,plain_text
675,"1 int count = 0;
",Literals,code_fragment
676,"The code section 3.62 contains two number literals followed by two boolean literals at line 1, one string literal followed by one number literal at line 2, and one string literal followed by one real number literal at line 3:
",Literals,plain_text
677,"1 (2 > 3) ? true : false;
2 ""text"".substring(2);
3 System.out.println(""Display a hard coded float: "" + 37.19f);
",Literals,code_fragment
678,,Boolean Literals[edit],
679,"There are two boolean literals
",Boolean Literals[edit],plain_text
680,"true represents a true boolean value
false represents a false boolean value",Boolean Literals[edit],plain_text
681,"There are no other boolean literals, because there are no other boolean values!
",Boolean Literals[edit],plain_text
682,,Numeric Literals[edit],
683,"There are three types of numeric literals in Java.
",Numeric Literals[edit],plain_text
684,"In Java, you may enter integer numbers in several formats:
",Numeric Literals[edit],plain_text
685,"By default, the integer literal primitive type is int. If you want a long, add a letter el suffix (either the character l or the character L) to the integer literal. This suffix denotes a long integer rather than a standard integer. For example, 3405691582L is a long integer literal. Long integers are 8 bytes in length as opposed to the standard 4 bytes for int. It is best practice to use the suffix L instead of l to avoid confusion with the digit 1 (one) which looks like l in many fonts: 200l ≠ 2001. If you want a short integer literal, you have to cast it.
",Numeric Literals[edit],plain_text
686,"Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.
",Numeric Literals[edit],plain_text
687,"Floating point numbers are expressed as decimal fractions or as exponential notation:
",Numeric Literals[edit],plain_text
688,"1 double decimalNumber = 5.0;
2 decimalNumber = 89d;
3 decimalNumber = 0.5;
4 decimalNumber = 10f;
5 decimalNumber = 3.14159e0;
6 decimalNumber = 2.718281828459045D;
7 decimalNumber = 1.0e-6D;
",Numeric Literals[edit],code_fragment
689,"Floating point numbers consist of:
",Numeric Literals[edit],plain_text
690,"Here, integer digits represents one or more of the digits 0 through 9.
",Numeric Literals[edit],plain_text
691,"Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.
",Numeric Literals[edit],plain_text
692,"Character literals are constant valued character expressions embedded in a Java program. Java characters are sixteen bit Unicode characters, ranging from 0 to 65535. Character literals are expressed in Java as a single quote, the character, and a closing single quote ('a', '7', '$', 'π'). Character literals have the type char, an unsigned integer primitive type. Character literals may be safely promoted to larger integer types such as int and long. Character literals used where a short or byte is called for must be cast to short or byte since truncation may occur.
",Numeric Literals[edit],plain_text
693,,String Literals[edit],
694,"String literals consist of the double quote character ("") (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character (""), such as: ""Ceci est une string.""
",String Literals[edit],plain_text
695,"So a string literal follows the following grammar:
",String Literals[edit],plain_text
696,"<STRING :
        ""\""""
        (    (~[""\"""",""\\"",""\n"",""\r""])
        |(""\\""
            ( [""n"",""t"",""b"",""r"",""f"",""\\"",""'"",""\""""]
            |[""0""-""7""]([""0""-""7""])?
            |[""0""-""3""][""0""-""7""][""0""-""7""]
            )
        )
        )*
        ""\"""">
",String Literals[edit],plain_text
697,"Within string and character literals, the backslash character can be used to escape special characters, such as unicode escape sequences, or the following special characters:
",String Literals[edit],plain_text
698,"String literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text:
",String Literals[edit],plain_text
699,"1 String text = ""This is a String literal\n""
2             + ""which spans not one and not two\n""
3             + ""but three lines of text.\n"";
",String Literals[edit],code_fragment
700,,null[edit],
701,"null is a special Java literal which represents a null value: a value which does not refer to any object. It is an error to attempt to dereference the null value — Java will throw a NullPointerException. null is often used to represent uninitialized state.
",null[edit],plain_text
702,,Mixed Mode Operations[edit],
703,"In concatenation operations, the values in brackets are concatenated first. Then the values are concatenated from the left to the right. Be careful when mixing character literals and integers in String concatenation operations:
",Mixed Mode Operations[edit],plain_text
704,"1 int one = '1';
2 int zero = '0';
3 
4 System.out.println(""120? "" + one + '2' + zero);
",Mixed Mode Operations[edit],code_fragment
705,"The unexpected results arise because '1' and '0' are converted twice. The expression is concatenated as such:
",Mixed Mode Operations[edit],plain_text
706,"The code section 66 yields the desired result:
",Mixed Mode Operations[edit],plain_text
707,"1 char one = '1';
2 char zero = '0';
3 
4 System.out.println(""120? "" + one + '2' + zero);
",Mixed Mode Operations[edit],code_fragment
708,"1 int one = '1';
2 int zero = '0';
3 
4 System.out.println(""  3? "" + (one + '2' + zero));
5 System.out.println(""102? "" + 100 + '2' + 0);
6 System.out.println(""102? "" + (100 + '2' + 0));
",Mixed Mode Operations[edit],code_fragment
709,"
",Mixed Mode Operations[edit],plain_text
710,"
Methods are how we communicate with objects. When we invoke or call a method we are asking the object to carry out a task. We can say methods implement the behaviour of objects. For each method we need to give a name, we need to define its input parameters and we need to define its return type. We also need to set its visibility (private, protected or public). If the method throws a checked exception, that needs to be declared as well. It is called a method definition. The syntax of method definition is:
",Methods,plain_text
711,"We can declare that the method does not return anything using the void Java keyword. For example:
",Methods,plain_text
712,"1 private void methodName(String parameter1, String parameter2) {
2   ...
3   return;
4 }
",Methods,code_fragment
713,"When the method returns nothing, the return keyword at the end of the method is optional. When the execution flow reaches the return keyword, the method execution is stopped and the execution flow returns to the caller method. The return keyword can be used anywhere in the method as long as there is a way to execute the instructions below:
",Methods,plain_text
714," 1 private void aMethod(int a, int b) {
 2   int c = 0;
 3   if (a > 0) {
 4     c = a;
 5     return;
 6   }
 7   int c = c + b;
 8   return;
 9   int c = c * 2;
10 }
",Methods,code_fragment
715,"In the code section 3.68, the return keyword at line 5 is well placed because the instructions below can be reached when a is negative or equal to 0. However, the return keyword at line 8 is badly placed because the instructions below can't be reached.
",Methods,plain_text
716,"1 private int myMethod(int a, int b, boolean c) {
2   b = b + 2;
3   if (a > 0) {
4     a = a + b;
5     return a;
6   } else {
7     a = 0;
8   }
9 }
",Methods,code_fragment
717,,Parameter passing[edit],
718,"We can pass any primitive data types or reference data type to a method.
",Parameter passing[edit],plain_text
719,"The primitive types are passed in by value. It means that as soon as the primitive type is passed in, there is no more link between the value inside the method and the source variable:
",Parameter passing[edit],plain_text
720,"1 private void modifyValue(int number) {
2   number += 1;
3 }
",Parameter passing[edit],code_fragment
721,"1 int i = 0;
2 modifyValue(i);
3 System.out.println(i);
",Parameter passing[edit],code_fragment
722,"As you can see in code section 3.70, the modifyValue() method has not modified the value of i.
",Parameter passing[edit],plain_text
723,"The object references are passed by value. It means that:
",Parameter passing[edit],plain_text
724,"There is no more link between the reference inside the method and the source reference,
The source object itself and the object itself inside the method are still the same.",Parameter passing[edit],plain_text
725,"You must understand the difference between the reference of an object and the object itself. A object reference is the link between a variable name and an instance of object:
",Parameter passing[edit],plain_text
726,"An object reference is a pointer, an address to the object instance.
",Parameter passing[edit],plain_text
727,"The object itself is the value of its attributes inside the object instance:
",Parameter passing[edit],plain_text
728,"Take a look at the example above:
",Parameter passing[edit],plain_text
729,"1 private void modifyObject(FirstClass anObject) {
2   anObject.setName(""Susan"");
3 }
",Parameter passing[edit],code_fragment
730,"1 FirstClass object = new FirstClass();
2 object.setName(""Christin"");
3 
4 modifyObject(object);
5 
6 System.out.println(object.getName());
",Parameter passing[edit],code_fragment
731,"The name has changed because the method has changed the object itself and not the reference. Now take a look at the other example:
",Parameter passing[edit],plain_text
732,"1 private void modifyObject(FirstClass anObject) {
2   anObject = new FirstClass();
3   anObject.setName(""Susan"");
4 }
",Parameter passing[edit],code_fragment
733,"1 FirstClass object = new FirstClass();
2 object.setName(""Christin"");
3 
4 modifyObject(object);
5 
6 System.out.println(object.getName());
",Parameter passing[edit],code_fragment
734,"The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:
",Parameter passing[edit],plain_text
735," 1 FirstClass object = new FirstClass();
 2 object.setName(""Christin"");
 3 
 4 // Start of the method
 5 FirstClass anObject = object;
 6 anObject = new FirstClass();
 7 anObject.setName(""Susan"");
 8 // End of the method
 9 
10 System.out.println(object.getName());
",Parameter passing[edit],code_fragment
736,,Variable argument list[edit],
737,"Java SE 5.0 added syntactic support for methods with variable argument list, which simplifies the typesafe usage of methods requiring a variable number of arguments. Less formally, these parameters are called varargs[1]. The type of a variable parameter must be followed with ..., and Java will box all the arguments into an array:
",Variable argument list[edit],plain_text
738,"1 public void drawPolygon(Point... points) {
2   //…
3 }
",Variable argument list[edit],code_fragment
739,"When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an array of Point objects. Within the method, the points can be referenced as points[0], points[1], etc. If no points are passed, the array has a length of zero.
",Variable argument list[edit],plain_text
740,"A method can have both normal parameters and a variable parameter but the variable parameter must always be the last parameter. For instance, if the programmer is required to use a minimum number of parameters, those parameters can be specified before the variable argument:
",Variable argument list[edit],plain_text
741,"1 // A polygon needs at least three points.
2 public void drawPolygon(Point p1, Point p2, Point p3, Point... otherPoints) {
3   //…
4 }
",Variable argument list[edit],code_fragment
742,,Return parameter[edit],
743,"A method may return a value (which can be a primitive type or an object reference). If the method does not return a value we use the void Java keyword.
",Return parameter[edit],plain_text
744,"However, a method can return only one value so what if you want to return more than one value from a method?
You can pass in an object reference to the method, and let the method modify the object properties so the modified values can be considered as an output value from the method.
You can also create an Object array inside the method, assign the return values and return the array to the caller. However, this gives a problem if you want to mix primitive data types and object references as the output values from the method.
",Return parameter[edit],plain_text
745,"There is a better approach, define a special return object with the needed return values. Create that object inside the method, assign the values and return the reference to this object. This special object is ""bound"" to this method and used only for returning values, so do not use a public class. The best way is to use a nested class, see example below:
",Return parameter[edit],plain_text
746," 1 public class MyObject {
 2   ...
 3  
 4   /** Nested object is for return values from getPersonInfoById method */
 5   private static class ReturnObject {
 6       private int age;
 7       private String name;
 8 
 9       public void setAge(int age) {
10           this.age = age;
11       }
12  
13       public int getAge() {
14           return age;
15       }
16 
17       public void setName(String name) {
18           name = name;
19       }
20  
21       public String getName() {
22           return name;
23       }
24   } // End of nested class definition
25 
26   /** Method using the nested class to return values */
27   public ReturnObject getPersonInfoById(int id) {
28     int    age;
29     String name;
30     ...
31     // Get the name and age based on the ID from the database
32     ...
33     ReturnObject result = new ReturnObject();
34     result.setAge(age);
35     result.setName(name);
36 
37     return result;
38   }
39 }
",Return parameter[edit],code_fragment
747,"In the above example the getPersonInfoById method returns an object reference that contains both values of the name and the age. See below how you may use that object:
",Return parameter[edit],plain_text
748,"1 MyObject object = new MyObject();
2 MyObject.ReturnObject person = object.getPersonInfoById(102);
3 
4 System.out.println(""Person Name="" + person.getName());
5 System.out.println(""Person Age ="" + person.getAge());
",Return parameter[edit],code_fragment
749,"1 private int myMethod(int a, int b, String c) {
2   if (a > 0) {
3     c = """";
4     return c;
5   }
6   int b = b + 2;
7   return b;
8 }
",Return parameter[edit],code_fragment
750,,"Special method, the constructor[edit]",
751,"The constructor is a special method called automatically when an object is created with the new keyword. Constructor does not have a return value and its name is the same as the class name. Each class must have a constructor. If we do not define one, the compiler will create a default so called empty constructor automatically.
","Special method, the constructor[edit]",plain_text
752,"1 public class MyClass {
2   /**
3   * MyClass Empty Constructor
4   */
5   public MyClass() {
6   }
7 }
","Special method, the constructor[edit]",code_fragment
753,,Static methods[edit],
754,"A static method is a method that can be called without an object instance. It can be called on the class directly. For example, the valueOf(String) method of the Integer class is a static method:
",Static methods[edit],plain_text
755,"1 Integer i = Integer.valueOf(""10"");
",Static methods[edit],code_fragment
756,"The static keyword makes attributes instance-agnostic. This means that you cannot reference a static attribute of a single object (because such a specific object attribute doesn't exist). Instead, only one instance of a static attribute exists, whether there is one object in the JVM or one hundred. Here is an example of using a static attribute in a static method:
",Static methods[edit],plain_text
757,"1 private static int count = 0;
2 
3 public static int getNewInteger() {
4   return count++;
5 }
",Static methods[edit],code_fragment
758,"You can notice that when you use System.out.println(), out is a static attribute of the System class. A static attribute is related to a class, not to any object instance. This is how Java achieves one universal output stream that we can use to print output. Here is a more complex use case:
",Static methods[edit],plain_text
759," 1 public class MyProgram {
 2 
 3     public static int count = 0;
 4 
 5     public static void main (String[] args) {
 6         MyProgram.count++;
 7 
 8         MyProgram program1 = new MyProgram();
 9         program1.count++;
10 
11         MyProgram program2 = new MyProgram();
12         program2.count++;
13 
14         new MyProgram().count++;
15         System.out.println(MyProgram.count);
16     }
17 }
",Static methods[edit],code_fragment
760,"
",Static methods[edit],plain_text
761,"
String is a class built into the Java language defined in the java.lang package. It represents character strings. Strings are ubiquitous in Java. Study the String class and its methods carefully. It will serve you well to know how to manipulate them skillfully. String literals in Java programs, such as ""abc"", are implemented as instances of this class like this:
",String,plain_text
762,"1 String str = ""This is string literal"";
",String,code_fragment
763,"On the right hand side a String object is created represented by the string literal. Its object reference is assigned to the str variable.
",String,plain_text
764,,Immutability[edit],
765,"Strings are immutable; that is, they cannot be modified once created. Whenever it looks as if a String object was modified actually a new String object was created. For instance, the String.trim() method returns the string with leading and trailing whitespace removed. Actually, it creates a new trimmed string and then returns it. Pay attention on what happens in Code section 3.82:
",Immutability[edit],plain_text
766,"1 String badlyCutText = ""     Java is great.     "";
2 System.out.println(badlyCutText);
3 
4 badlyCutText.trim();
5 System.out.println(badlyCutText);
",Immutability[edit],code_fragment
767,"The trim() method call does not modify the object so nothing happens. It creates a new trimmed string and then throws it away.
",Immutability[edit],plain_text
768,"1 String badlyCutText = ""     Java is great.     "";
2 System.out.println(badlyCutText);
3 
4 badlyCutText = badlyCutText.trim();
5 System.out.println(badlyCutText);
",Immutability[edit],code_fragment
769,"The returned string is assigned to the variable. It does the job as the trim() method has created a new String instance.
",Immutability[edit],plain_text
770,,Concatenation[edit],
771,"The Java language provides special support for the string concatenation with operator +:
",Concatenation[edit],plain_text
772,"1 System.out.println(""First part"");
2 System.out.println("" second part"");
3 String str = ""First part"" + "" second part"";
4 System.out.println(str);
",Concatenation[edit],code_fragment
773,"The concatenation is not always processed at the same time. Raw string literals concatenation is done at compile time, hence there is a single string literal in the byte code of the class. Concatenation with at least one object is done at runtime.
",Concatenation[edit],plain_text
774,"+ operator can concatenate other objects with strings. For instance, integers will be converted to strings before the concatenation:
",Concatenation[edit],plain_text
775,"1 System.out.println(""Age="" + 25);
",Concatenation[edit],code_fragment
776,"Each Java object has the String toString() inherited from the Object class. This method provides a way to convert objects into Strings. Most classes override the default behavior to provide more specific (and more useful) data in the returned String:
",Concatenation[edit],plain_text
777,"1 System.out.println(""Age="" + new Integer(31));
",Concatenation[edit],code_fragment
778,,Using StringBuilder/StringBuffer to concatenate strings[edit],
779,"Remember that String objects are immutable objects. Once a String is created, it can not be modified, takes up memory until garbage collected. Be careful of writing a method like this:
",Using StringBuilder/StringBuffer to concatenate strings[edit],plain_text
780,"1 public String convertToString(Collection<String> words) {
2   String str = """";
3   // Loops through every element in words collection
4   for (String word : words) {
5     str = str + word + "" "";
6   }
7   return str;
8 }
",Using StringBuilder/StringBuffer to concatenate strings[edit],code_fragment
781,"On the + operation a new String object is created at each iteration. Suppose words contains the elements [""Foo"", ""Bar"", ""Bam"", ""Baz""]. At runtime, the method creates thirteen Strings:
",Using StringBuilder/StringBuffer to concatenate strings[edit],plain_text
782,"Even though only the last one is actually useful.
",Using StringBuilder/StringBuffer to concatenate strings[edit],plain_text
783,"To avoid unnecessary memory use like this, use the StringBuilder class. It provides similar functionality to Strings, but stores its data in a mutable way. Only one StringBuilder object is created. Also because object creation is time consuming, using StringBuilder produces much faster code.
",Using StringBuilder/StringBuffer to concatenate strings[edit],plain_text
784,"1 public String convertToString(Collection<String> words) {
2   StringBuilder buf = new StringBuilder();
3   // Loops through every element in words collection
4   for (String word : words) {
5     buf.append(word);
6     buf.append("" "");
7   }
8   return buf.toString();
9 }
",Using StringBuilder/StringBuffer to concatenate strings[edit],code_fragment
785,"As StringBuilder isn't thread safe (see the chapter on Concurrency) you can't use it in more than one thread. For a multi-thread environment, use StringBuffer instead which does the same and is thread safe. However, StringBuffer is slower so only use it when it is required. Moreover, before Java 5 only StringBuffer existed.
",Using StringBuilder/StringBuffer to concatenate strings[edit],plain_text
786,,Comparing Strings[edit],
787,"Comparing strings is not as easy as it may first seem. Be aware of what you are doing when comparing String's using ==:
",Comparing Strings[edit],plain_text
788,"1 String greeting = ""Hello World!"";
2 if (greeting == ""Hello World!"") {
3     System.out.println(""Match found."");
4 }
",Comparing Strings[edit],code_fragment
789,"The difference between the above and below code is that the above code checks
to see if the String's are the same objects in memory which they are. This is as a result of the fact that
String's are stored in a place in memory called the String Constant Pool. If the new keyword is not explicitly used when 
creating the String it checks to see if it already exists in the Pool and uses the existing one. If it does not exist, a new Object is created. This is what allows Strings to be immutable in Java.
To test for equality, use the equals(Object) method inherited by every class and defined by String to return true if and only if the object passed in is a String contains the exact same data:
",Comparing Strings[edit],plain_text
790,"1 String greeting = ""Hello World!"";
2 if (greeting.equals(""Hello World!"")) {
3     System.out.println(""Match found."");
4 }
",Comparing Strings[edit],code_fragment
791,"Remember that the comparison is case sensitive.
",Comparing Strings[edit],plain_text
792,"1 String greeting = ""Hello World!"";
2 if (greeting.equals(""hello world!"")) {
3     System.out.println(""Match found."");
4 }
",Comparing Strings[edit],code_fragment
793,"To order String objects, use the compareTo() method, which can be accessed wherever we use a String datatype. The compareTo() method returns a negative, zero, or positive number if the parameter is less than, equal to, or greater than the object on which it is called. Let's take a look at an example:
",Comparing Strings[edit],plain_text
794,"1 String person1 = ""Peter"";
2 String person2 = ""John"";
3 if (person1.compareTo(person2) > 0) {
4     // Badly ordered
5     String temp = person1;
6     person1 = person2;
7     person2 = temp;
8 }
",Comparing Strings[edit],code_fragment
795,"The code section 3.92 is comparing the String variable person1 to person2. If person1 is different even in the slightest manner, we will get a value above or below 0 depending on the exact difference. The result is negative if this String object lexicographically precedes the argument string. The result is positive if this String object lexicographically follows the argument string. Take a look at the Java API for more details.
",Comparing Strings[edit],plain_text
796,,Splitting a String[edit],
797,"Sometimes it is useful to split a string into separate strings, based on a regular expressions. The String class has a split() method, since Java 1.4, that will return a String array:
",Splitting a String[edit],plain_text
798,"1 String person = ""Brown, John:100 Yonge Street, Toronto:(416)777-9999"";
2 ...
3 String[] personData = person.split("":"");
4 ...
5 String name    = personData[0];
6 String address = personData[1];
7 String phone   = personData[2];
",Splitting a String[edit],code_fragment
799,"Another useful application could be to split the String text based on the new line character, so you could process the text line by line.
",Splitting a String[edit],plain_text
800,,Substrings[edit],
801,"It may also be sometimes useful to create substrings, or strings using the order of letters from an existing string.  This can be done in two methods.
",Substrings[edit],plain_text
802,"The first method involves creating a substring out of the characters of a string from a given index to the end:
",Substrings[edit],plain_text
803,"1 String str = ""coffee"";
2 System.out.println(str.substring(3));
",Substrings[edit],code_fragment
804,"The index of the first character in a string is 0.
",Substrings[edit],plain_text
805,"By counting from there, it is apparent that the character in index 3 is the second ""f"" in ""coffee"". This is known as the beginIndex. All characters from the beginIndex until the end of the string will be copied into the new substring.
",Substrings[edit],plain_text
806,"The second method involves a user-defined beginIndex and endIndex:
",Substrings[edit],plain_text
807,"1 String str = ""supporting"";
2 System.out.println(str.substring(3, 7));
",Substrings[edit],code_fragment
808,"The string returned by substring() would be ""port"".
",Substrings[edit],plain_text
809,"Please note that the endIndex is not inclusive. This means that the last character will be of the index endIndex-1. Therefore, in this example, every character from index 3 to index 6, inclusive, was copied into the substring.
",Substrings[edit],plain_text
810,,String cases[edit],
811,"The String class also allows for the modification of cases. The two methods that make this possible are toLowerCase() and toUpperCase().
",String cases[edit],plain_text
812,"1 String str = ""wIkIbOoKs"";
2 System.out.println(str.toLowerCase());
3 System.out.println(str.toUpperCase());
",String cases[edit],code_fragment
813,"These methods are useful to do a search which is not case sensitive:
",String cases[edit],plain_text
814," 1 String word = ""Integer"";
 2 String text = ""A number without a decimal part is an integer.""
 3   + "" Integers are a list of digits."";
 4 
 5 ...
 6 
 7 // Remove the case
 8 String lowerCaseWord = word.toLowerCase();
 9 String lowerCaseText = text.toLowerCase();
10 
11 // Search
12 int index = lowerCaseText.indexOf(lowerCaseWord);
13 while (index != -1) {
14   System.out.println(word
15     + "" appears at column ""
16     + (index + 1)
17     + ""."");
18   index = lowerCaseText.indexOf(lowerCaseWord, index + 1);
19 }
",String cases[edit],code_fragment
815," 1 public static String getDisplayName(String mail) {
 2   String displayName = null;
 3  
 4   if (mail != null) {
 5     String[] mailParts = mail.split(""@"");
 6     String namePart = mailParts[0];
 7     String[] namesParts = namePart.split(""\\."");
 8    
 9     // The last name
10     String lastName = namesParts[1];
11     lastName = lastName.toUpperCase();
12    
13     // The first name
14     String firstName = namesParts[0];
15    
16     String firstNameInitial = firstName.substring(0, 1);
17     firstNameInitial = firstNameInitial.toUpperCase();
18    
19     String firstNameEnd = firstName.substring(1);
20     firstNameEnd = firstNameEnd.toLowerCase();
21    
22     // Concatenation
23     StringBuilder displayNameBuilder = new StringBuilder(lastName).append("" "").append(firstNameInitial).append(firstNameEnd);
24     displayName = displayNameBuilder.toString();
25   }
26  
27   return displayName;
28 }
",String cases[edit],code_fragment
816,,See also[edit],
817," Java API: java.lang.String
 Java API: java.lang.StringBuffer
 Java API: java.lang.StringBuilder",See also[edit],plain_text
818,"
An object is composed of fields and methods. The fields, also called data members, characteristics, attributes, or properties, describe the state of the object. The methods generally describe the actions associated with a particular object. Think of an object as a noun, its fields as adjectives describing that noun, and its methods as the verbs that can be performed by or on that noun.
",Objects,plain_text
819,"For example, a sports car is an object. Some of its fields might be its height, weight, acceleration, and speed. An object's fields just hold data about that object. Some of the methods of the sports car could be ""drive"", ""park"", ""race"", etc. The methods really don't mean much unless associated with the sports car, and the same goes for the fields.
",Objects,plain_text
820,"The blueprint that lets us build our sports car object is called a class. A class doesn't tell us how fast our sports car goes, or what color it is, but it does tell us that our sports car will have a field representing speed and color, and that they will be say, a number and a word (or hex color code), respectively. The class also lays out the methods for us, telling the car how to park and drive, but these methods can't take any action with just the blueprint — they need an object to have an effect.
",Objects,plain_text
821,"In Java, a class is located in a file similar to its own name.  If you want to have a class called SportsCar, its source file needs to be SportsCar.java.  The class is created by placing the following in the source file:
",Objects,plain_text
822,"1 public class SportsCar {
2    /* Insert your code here */
3 }
",Objects,code_fragment
823,"The class doesn't do anything yet, as you will need to add methods and field variables first.
",Objects,plain_text
824,"The objects are different from the primitive types because:
",Objects,plain_text
825,,Instantiation and constructors[edit],
826,"In order to get from class to object, we ""build"" our object by instantiation. Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object, which was created from a class.
",Instantiation and constructors[edit],plain_text
827,"This instantiation is brought about by one of the class's methods, called a constructor. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.
",Instantiation and constructors[edit],plain_text
828,"In general there are four constructor types: default, non-default, copy, and cloning.
",Instantiation and constructors[edit],plain_text
829,"A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from setting the color of your default sports car color to red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.
",Instantiation and constructors[edit],plain_text
830,"1 SportsCar car = new SportsCar();
",Instantiation and constructors[edit],code_fragment
831,"A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.
",Instantiation and constructors[edit],plain_text
832,"1 SportsCar car = new SportsCar(""red"", 12, 190);
",Instantiation and constructors[edit],code_fragment
833,"A copy constructor is not included in the Java language, however one can easily create a constructor that does the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.
",Instantiation and constructors[edit],plain_text
834,"Java has the concept of cloning an object, and the end results are similar to the copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to the destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.
",Instantiation and constructors[edit],plain_text
835,"1 SportsCar car = oldCar.clone();
",Instantiation and constructors[edit],code_fragment
836,,Type[edit],
837,"When an object is created, a reference to the object is also created. The object can not be accessed directly in Java, only through this object reference. This object reference has a type assigned to it. We need this type when passing the object reference to a method as a parameter. Java does strong type checking.
",Type[edit],plain_text
838,"Type is basically a list of features/operations, that can be performed through that object reference.  The object reference type is basically a contract that guarantees that those operations will be there at run time.
",Type[edit],plain_text
839,"When a car is created, it comes with a list of features/operations listed in the user manual that guarantees that those will be there when the car is used.
",Type[edit],plain_text
840,"When you create an object from a class by default its type is the same as its class. It means that all the features/operations the class defined are there and available, and can be used. See below:
",Type[edit],plain_text
841,"1 (new ClassName()).operations();
",Type[edit],code_fragment
842,"You can assign this to a variable having the same type as the class:
",Type[edit],plain_text
843,"1 ClassName objRefVariable = new ClassName();
2 objRefVariable.operations();
",Type[edit],code_fragment
844,"You can assign the created object reference to the class, super class, or to an interface the class implements:
",Type[edit],plain_text
845,"1 SuperClass objectRef = new ClassName(); // features/operations list are defined by the SuperClass class
2 ...
3 Interface inter = new ClassName(); // features/operations list are defined by the interface
",Type[edit],code_fragment
846,"In the car analogy, the created car may have different Types of drivers. We create separate user manuals for them, an Average user manual, a Power user manual, a Child user manual, or a Handicapped user manual. Each type of user manual describes only those features/operations appropriate for the type of driver.  For instance, the Power driver may have additional gears to switch to higher speeds, that are not available to other type of users...
",Type[edit],plain_text
847,"When the car key is passed from an adult to a child we are replacing the user manuals, that is called Type Casting.
",Type[edit],plain_text
848,"In Java, casts can occur in three ways:
",Type[edit],plain_text
849,"up casting going up in the inheritance tree, until we reach the Object
up casting to an interface the class implements
down casting until we reach the class the object was created from",Type[edit],plain_text
850,,Autoboxing/unboxing[edit],
851,"Autoboxing and unboxing, language features since Java 1.5, make the programmer's life much easier when it comes to working with the primitive wrapper types. Consider this code fragment:
",Autoboxing/unboxing[edit],plain_text
852,"1 int age = 23;
2 Integer ageObject = new Integer(age);
",Autoboxing/unboxing[edit],code_fragment
853,"Primitive wrapper objects were Java's way of allowing one to treat primitive data types as though they were objects. Consequently, one was expected to wrap one's primitive data type with the corresponding primitive wrapper object, as shown above.
",Autoboxing/unboxing[edit],plain_text
854,"Since Java 1.5, one may write as below and the compiler will automatically create the wrap object. The extra step of wrapping the primitive is no longer required. It has been automatically boxed up on your behalf:
",Autoboxing/unboxing[edit],plain_text
855,"1 int age = 23;
2 Integer ageObject = age;
",Autoboxing/unboxing[edit],code_fragment
856,"Each primitive type has a class wrapper:
",Autoboxing/unboxing[edit],plain_text
857,"Unboxing uses the same process in reverse. Study the following code for a moment. The if statement requires a boolean primitive value, yet it was given a Boolean wrapper object. No problem! Java 1.5 will automatically unbox this.
",Autoboxing/unboxing[edit],plain_text
858,"1 Boolean canMove = new Boolean(true);
2  
3 if (canMove) {
4   System.out.println(""This code is legal in Java 1.5"");
5 }
",Autoboxing/unboxing[edit],code_fragment
859,"5 Integer a = 10;
6 Integer b = a + 2;
7 System.out.println(b);
",Autoboxing/unboxing[edit],code_fragment
860,,Methods in the Object class[edit],
861,"Methods in the java.lang.Object class are inherited, and thus shared in common by all classes.
",Methods in the Object class[edit],plain_text
862,"The java.lang.Object.clone() method returns a new object that is a copy of the current object.  Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.
",Methods in the Object class[edit],plain_text
863,"The java.lang.Object.equals(java.lang.Object) method compares the object to another object and returns a boolean result indicating if the two objects are equal.  Semantically, this method compares the contents of the objects whereas the equality comparison operator ""=="" compares the object references.  The equals method is used by many of the data structure classes in the java.util package.  Some of these data structure classes also rely on the Object.hashCode method—see the hashCode method for details on the contract between equals and hashCode. Implementing equals() isn't always as easy as it seems, see 'Secrets of equals()' for more information.
",Methods in the Object class[edit],plain_text
864,"The java.lang.Object.finalize() method is called exactly once before the garbage collector frees the memory for object.  A class overrides finalize to perform any clean up that must be performed before an object is reclaimed.  Most objects do not need to override finalize.
",Methods in the Object class[edit],plain_text
865,"There is no guarantee when the finalize method will be called, or the order in which the finalize method will be called for multiple objects.  If the JVM exits without performing garbage collection, the OS may free the objects, in which case the finalize method doesn't get called.
",Methods in the Object class[edit],plain_text
866,"The finalize method should always be declared protected to prevent other classes from calling the finalize method.
",Methods in the Object class[edit],plain_text
867,"protected void finalize() throws Throwable { ... }
",Methods in the Object class[edit],plain_text
868,"The java.lang.Object.getClass() method returns the java.lang.Class object for the class that was used to instantiate the object.  The class object is the base class of reflection in Java.  Additional reflection support is provided in the java.lang.reflect package.
",Methods in the Object class[edit],plain_text
869,"The java.lang.Object.hashCode() method returns an integer (int). This integer can be used to distinguish objects although not completely. It quickly separates most of the objects and those with the same hash code are separated later in another way. It is used by the classes that provide associative arrays, for instance, those that implement the java.util.Map interface
. They use the hash code to store the object in the associative array. A good hashCode implementation will return a hash code:
",Methods in the Object class[edit],plain_text
870,"Stable: does not change
Evenly distributed: the hash codes of unequal objects tend to be unequal and the hash codes are evenly distributed across integer values.",Methods in the Object class[edit],plain_text
871,"The second point means that two different objects can have the same hash code so two objects with the same hash code are not necessarily the same!
",Methods in the Object class[edit],plain_text
872,"Since associative arrays depend on both the equals and hashCode methods, there is an important contract between these two methods that must be maintained if the objects are to be inserted into a Map:
",Methods in the Object class[edit],plain_text
873,"In order to maintain this contract, a class that overrides the equals method must also override the hashCode method, and vice versa, so that hashCode is based on the same properties (or a subset of the properties) as equals.
",Methods in the Object class[edit],plain_text
874,"A further contract that the map has with the object is that the results of the hashCode and equals methods will not change once the object has been inserted into the map.  For this reason, it is generally a good practice to base the hash function on immutable properties of the object.
",Methods in the Object class[edit],plain_text
875,"The java.lang.Object.toString() method returns a java.lang.String that contains a text representation of the object.  The toString method is implicitly called by the compiler when an object operand is used with the string concatenation operators (+ and +=).
",Methods in the Object class[edit],plain_text
876,"Every object has two wait lists for threads associated with it.  One wait list is used by the synchronized keyword to acquire the mutex lock associated with the object.  If the mutex lock is currently held by another thread, the current thread is added to the list of blocked threads waiting on the mutex lock.  The other wait list is used for signaling between threads accomplished through the wait and notify and notifyAll methods.
",Methods in the Object class[edit],plain_text
877,"Use of wait/notify allows efficient coordination of tasks between threads.  When one thread needs to wait for another thread to complete an operation, or needs to wait until an event occurs, the thread can suspend its execution and wait to be notified when the event occurs.  This is in contrast to polling, where the thread repeatedly sleeps for a short period of time and then checks a flag or other condition indicator.  Polling is both more computationally expensive, as the thread has to continue checking, and less responsive since the thread won't notice the condition has changed until the next time to check.
",Methods in the Object class[edit],plain_text
878,"There are three overloaded versions of the wait method to support different ways to specify the timeout value: java.lang.Object.wait(), java.lang.Object.wait(long) and java.lang.Object.wait(long, int).  The first method uses a timeout value of zero (0), which means that the wait does not timeout; the second method takes the number of milliseconds as a timeout; the third method takes the number of nanoseconds as a timeout, calculated as 1000000 * timeout + nanos.
",Methods in the Object class[edit],plain_text
879,"The thread calling wait is blocked (removed from the set of executable threads) and added to the object's wait list.  The thread remains in the object's wait list until one of three events occurs:
",Methods in the Object class[edit],plain_text
880,"The wait method must be called inside of a block or method synchronized on the object.  This insures that there are no race conditions between wait and notify.  When the thread is placed in the wait list, the thread releases the object's mutex lock.  After the thread is removed from the wait list and added to the set of executable threads, it must acquire the object's mutex lock before continuing execution.
",Methods in the Object class[edit],plain_text
881,"The java.lang.Object.notify() and java.lang.Object.notifyAll() methods remove one or more threads from an object's wait list and add them to the set of executable threads.  notify removes a single thread from the wait list, while notifyAll removes all threads from the wait list.  Which thread is removed by notify is unspecified and dependent on the JVM implementation.
",Methods in the Object class[edit],plain_text
882,"The notify methods must be called inside of a block or method synchronized on the object.  This insures that there are no race conditions between wait and notify.
",Methods in the Object class[edit],plain_text
883,"
If your application becomes quite big, you may have lots of classes. Although you can browse them in their alphabetic order, it becomes confusing. So your application classes can be sorted into packages.
",Packages,plain_text
884,"A package is a name space that mainly contains classes and interfaces. For instance, the standard class ArrayList is in the package java.util. For this class, java.util.ArrayList is called its fully qualified name because this syntax has no ambiguity. Classes in different packages can have the same name. For example, you have the two classes java.util.Date and java.sql.Date which are not the same. If no package is declared in a class, its package is the default package.
",Packages,plain_text
885,,Package declaration[edit],
886,"In a class, a package is declared at the top of the source code using the keyword package:
",Package declaration[edit],plain_text
887,"1 package business;
2 
3 public class BusinessClass {
4 }
",Package declaration[edit],code_fragment
888,"If your class is declared in a package, say business, your class must be placed in a subfolder called business from the root of your application folder. This is how the compiler and the class loader find the Java files on the file system. You can declare your class in a subpackage, say engine. So the full package is business.engine and the class must be placed in a subsubfolder called engine in the subfolder business (not in a folder called business.engine).
",Package declaration[edit],plain_text
889,,Import and class usage[edit],
890,"The simpliest way to use a class declared in a package is to prefix the class name with its package:
",Import and class usage[edit],plain_text
891,"1 business.BusinessClass myBusinessClass = new business.BusinessClass();
",Import and class usage[edit],code_fragment
892,"If you are using the class from a class in the same package, you don't have to specify the package. If another class with the same name exists in another package, it will use the local class.
",Import and class usage[edit],plain_text
893,"The syntax above is a bit verbose. You can import the class by using the import Java keyword at the top of the file and then only specify its name:
",Import and class usage[edit],plain_text
894,"1 import business.BusinessClass;
2 
3 public class MyClass {
4   public static void main(String[] args) {
5     BusinessClass myBusinessClass = new BusinessClass();
6   }
7 }
",Import and class usage[edit],code_fragment
895,"Note that you can't import two classes with the same name in two different packages.
",Import and class usage[edit],plain_text
896,"The classes Integer and String belongs to the package java.lang but they don't need to be imported as the java.lang package is implicitly imported in all classes.
",Import and class usage[edit],plain_text
897,,Wildcard imports[edit],
898,"It is possible to import an entire package, using an asterisk:
",Wildcard imports[edit],plain_text
899,"1 import javax.swing.*;
",Wildcard imports[edit],code_fragment
900,"While it may seem convenient, it may cause problems if you make a typographical error.  For example, if you use the above import to use JFrame, but then type JFraim frame = new JFraim();, the Java compiler will report an error similar to ""Cannot find symbol: JFraim"".  Even though it seems as if it was imported,  the compiler is giving the error report at the first mention of JFraim, which is half-way through your code, instead of the point where you imported JFrame along with everything else in javax.swing.
",Wildcard imports[edit],plain_text
901,"If you change this to import javax.swing.JFraim; the error will be at the import instead of within your code.
",Wildcard imports[edit],plain_text
902,"Furthermore, if you import javax.swing.*; and import java.util.*;, and javax.swing.Queue is later added in a future version of Java, your code that uses Queue (java.util) will fail to compile.  This particular example is fairly unlikely, but if you are working with non-Oracle libraries, it may be more likely to happen.
",Wildcard imports[edit],plain_text
903,,Package convention[edit],
904,"A package name should start with a lower character. This eases to distinguish a package from a class name. In some operating systems, the directory names are not case sensitive. So package names should be lowercase.
",Package convention[edit],plain_text
905,"The Java package needs to be unique across Vendors to avoid name collisions. For that reason Vendors usually use their domain name in reverse order. That is guaranteed to be unique.  For example a company called Your Company Inc., would use a package name something like this: com.yourcompany.yourapplicationname.yourmodule.YourClass.
",Package convention[edit],plain_text
906,,Importing packages from .jar files[edit],
907,"If you are importing library packages and classes that reside in a .jar file, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.
",Importing packages from .jar files[edit],plain_text
908,"For example, to compile and run a class from a project's top directory (that contains the two directories /source and /libraries) you could use the following command:
",Importing packages from .jar files[edit],plain_text
909,"And then to run it, similarly:
",Importing packages from .jar files[edit],plain_text
910,"The above is simplified, and demands that MainClass be in the default package, or a package called source, which isn't very desirable.
",Importing packages from .jar files[edit],plain_text
911,"With BlueJ just click on Tools, Preferences, Libraries, and add the .jar one by one.
",Importing packages from .jar files[edit],plain_text
912,,Class loading/package[edit],
913,"The runtime identity of a class in Java is defined by the fully qualified class name and its defining class loader. This means that the same class, loaded by two different class loaders, is seen by the Virtual Machine as two completely different types.
",Class loading/package[edit],plain_text
914,"
",Class loading/package[edit],plain_text
915,"An array is similar to a table of objects or primitive types, keyed by index. You may have noticed the strange parameter of the default main() method (String[] args) since the beginning of the book. It is an array. Let's handle this parameter:
",Arrays,plain_text
916,"1 public class ArrayExample {
2   public static void main(String[] args) {
3     for (int i = 0; i < args.length; ++i) {
4       System.out.println(""Argument #"" + (i + 1) + "": "" + args[i]);
5     }
6   }
7 }
",Arrays,code_fragment
917,"In the code listing 3.15, the array is args. It is an array of String objects (here those objects are the words that have been typed by the user at the program launching). At line 4, One contained object is accessed using its index in the array. You can see that its value is printed on the standard output. Note that the strings have been put in the array with the right order.
",Arrays,plain_text
918,,Fundamentals[edit],
919,"In Java, an array is an object. This object has a given type for the contained primitive types or objects (int, char, String, ...). An array can be declared in several ways:
",Fundamentals[edit],plain_text
920,"1 int[] array1 = null;
2 int array2[] = null;
",Fundamentals[edit],code_fragment
921,"Those syntaxes are identical but the first one is recommended. It can also be instantiated in several ways:
",Fundamentals[edit],plain_text
922,"1 array1 = new int[10];
2 int[] array0 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //this only works in the declaration
3 array1 = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
",Fundamentals[edit],code_fragment
923,"At line 1, we instantiate an array of 10 items that get the default value (which is 0 for int). At lines 2 and 3, we instantiate arrays of 10 given items. It will each be given an index according to its order. We can know the size of the array using the length attribute:
",Fundamentals[edit],plain_text
924,"1 int nbItems = 10;
2 Object[] array3 = new Object[nbItems];
3 System.out.println(array3.length);
",Fundamentals[edit],code_fragment
925,"Arrays are allocated at runtime, so the specified size in an array creation expression may be a variable (rather than a constant expression as in C). However, the size of an instantiated array never changes. If you need to change the size, you have to create a new instance. Items can be accessed by their index. Beware! The first index is 0:
",Fundamentals[edit],plain_text
926,"1 char[] array4 = {'a', 'b', 'c', 'd', 'e'};
2 System.out.println(array4[2]);
3 array4[4] = 'z';
4 System.out.println(array4[4]);
",Fundamentals[edit],code_fragment
927,"If you attempt to access to a too high index or negative index, you will get an ArrayIndexOutOfBoundsException.
",Fundamentals[edit],plain_text
928,"1 public class Question20 {
2   public static void main(String[] args) {
3     String[] listOfWord = {""beggars"", ""can't"", ""be"", ""choosers""};
4     System.out.println(listOfWord[1]);
5     System.out.println(listOfWord[listOfWord.length-1]);
6   }
7 }
",Fundamentals[edit],code_fragment
929,,Two-Dimensional Arrays[edit],
930,"Actually, there are no two-dimensional arrays in Java. However, an array can contain any class of object, including an array:
",Two-Dimensional Arrays[edit],plain_text
931,"1 String[][] twoDimArray = {{""a"", ""b"", ""c"", ""d"", ""e""},
2                           {""f"", ""g"", ""h"", ""i"", ""j""},
3                           {""k"", ""l"", ""m"", ""n"", ""o""}};
4 
5 int[][] twoDimIntArray = {{ 0,  1,  2,  3,  4},
6                           {10, 11, 12, 13, 14},
7                           {20, 21, 22, 23, 24}};
",Two-Dimensional Arrays[edit],code_fragment
932,"It's not exactly equivalent to two-dimensional arrays because the size of the sub-arrays may vary. The sub-array reference can even be null. Consider:
",Two-Dimensional Arrays[edit],plain_text
933,"1 String[][] weirdTwoDimArray = {{""10"", ""11"", ""12""},
2                                null,
3                                {""20"", ""21"", ""22"", ""23"", ""24""}};
",Two-Dimensional Arrays[edit],code_fragment
934,"Note that the length of a two-dimensional array is the number of one-dimensional arrays it contains. In the above example, weirdTwoDimArray.length is 3, whereas weirdTwoDimArray[2].length is 5.
",Two-Dimensional Arrays[edit],plain_text
935,"In the code section 3.58, we defined an array that has three elements, each element contains an array having 5 elements. We could create the array having the 5 elements first and use that one in the initialize block.
",Two-Dimensional Arrays[edit],plain_text
936,"1 String[] oneDimArray = {""00"", ""01"", ""02"", ""03"", ""04""};
2 String[][] twoDimArray = {oneDimArray,
3                           {""10"", ""11"", ""12"", ""13"", ""14""},
4                           {""20"", ""21"", ""22"", ""23"", ""24""}};
",Two-Dimensional Arrays[edit],code_fragment
937,"1 String[][] alphabet = {{""a"", ""b"", ""c"", ""d"", ""e""},
2                           {""f"", ""g"", ""h"", ""i"", ""j""},
3                           {""k"", ""l"", ""m"", ""n"", ""o""},
4                           {""p"", ""q"", ""r"", ""s"", ""t""},
5                           {""u"", ""v"", ""w"", ""x"", ""y""},
6                           {""z""}};
",Two-Dimensional Arrays[edit],code_fragment
938,,Multidimensional Array[edit],
939,"Going further any number of dimensional array can be defined.
",Multidimensional Array[edit],plain_text
940,"or
",Multidimensional Array[edit],plain_text
941,"The java.lang.Math class allows the use of many common mathematical functions that can be used while creating programs.
",Mathematical functions,plain_text
942,"Since it is in the java.lang package, the Math class does not need to be imported. However, in programs extensively utilizing these functions, a static import can be used.
",Mathematical functions,plain_text
943,,Math constants[edit],
944,"There are two constants in the Math class that are fairly accurate approximations of irrational mathematical numbers.
",Math constants[edit],plain_text
945,"The Math.E constant represents the value of Euler's number (e), the base of the natural logarithm.
",Math constants[edit],plain_text
946,"1 public static final double E = 2.718281828459045;
",Math constants[edit],code_fragment
947,"The Math.PI constant represents the value of pi, the ratio of a circle's circumference to its diameter.
",Math constants[edit],plain_text
948,"1 public static final double PI = 3.141592653589793;
",Math constants[edit],code_fragment
949,,Math methods[edit],
950,"There are several methods in the Math class that deal with exponential functions.
",Math methods[edit],plain_text
951,"The power method, double Math.pow(double, double), returns the first parameter to the power of the second parameter.  For example, a call to Math.pow(2, 10) will return a value of 1024 (210).
",Math methods[edit],plain_text
952,"The Math.exp(double) method, a special case of pow, returns e to the power of the parameter. In addition, double Math.expm1(double) returns (ex - 1). Both of these methods are more accurate and convenient in these special cases.
",Math methods[edit],plain_text
953,"Java also provides special cases of the pow function for square roots and cube roots of doubles, double Math.sqrt(double) and double Math.cbrt(double).
",Math methods[edit],plain_text
954,"Java has no general logarithm function; when needed this can be simulated using the change-of-base theorem.
",Math methods[edit],plain_text
955,"double Math.log(double) returns the natural logarithm of the parameter (not the common logarithm, as its name suggests!).
",Math methods[edit],plain_text
956,"double Math.log10(double) returns the common (base-10) logarithm of the parameter.
",Math methods[edit],plain_text
957,"double Math.log1p(double) returns ln(parameter+1). It is recommended for small values.
",Math methods[edit],plain_text
958,"The trigonometric methods of the Math class allow users to easily deal with trigonometric functions in programs. All accept only doubles. Please note that all values using these methods are initially passed and returned in radians, not degrees.  However, conversions are possible.
",Math methods[edit],plain_text
959,"The three main trigonometric methods are Math.sin(x), Math.cos(x), and Math.tan(x), which are used to find the sine, cosine, and tangent, respectively, of any given number. So, for example, a call to Math.sin(Math.PI/2) would return a value of about 1.  Although methods for finding the cosecant, secant, and cotangent are not available, these values can be found by taking the reciprocal of the sine, cosine, and tangent, respectively.  For example, the cosecant of pi/2 could be found using 1/Math.sin(Math.PI/2).
",Math methods[edit],plain_text
960,"Java provides inverse counterparts to the trigonometric functions: Math.asin(x), and Math.acos(x), Math.atan(x).
",Math methods[edit],plain_text
961,"In addition, hyperbolic functions are available: Math.sinh(x), Math.cosh(x), and Math.tanh(x).
",Math methods[edit],plain_text
962,"To convert between degree and radian measures of angles, two methods are available, Math.toRadians(x) and Math.toDegrees(x).  While using Math.toRadians(x), a degrees value must be passed in, and that value in radians (the degree value multiplied by pi/180) will be returned.  The Math.toDegrees(x) method takes in a value in radians and the value in degrees (the radian value multiplied by 180/pi) is returned.
",Math methods[edit],plain_text
963,"The absolute value method of the Math class is compatible with the int, long, float, and double types. The data returned is the absolute value of parameter (how far away it is from zero) in the same data type.  For example:
",Math methods[edit],plain_text
964,"1 int result = Math.abs(-3);
",Math methods[edit],code_fragment
965,"In this example, result will contain a value of 3.
",Math methods[edit],plain_text
966,"These methods are very simple comparing functions.  Instead of using if...else statements, one can use the Math.max(x1, x2) and Math.min(x1, x2) methods.  The Math.max(x1, x2) simply returns the greater of the two values, while the Math.min(x1, x2) returns the lesser of the two.  Acceptable types for these methods include int, long, float, and double.
",Math methods[edit],plain_text
967,,Functions dealing with floating-point representation[edit],
968,"Java 1.5 and 1.6 introduced several non-mathematical functions specific to the computer floating-point representation of numbers.
",Functions dealing with floating-point representation[edit],plain_text
969,"Math.ulp(double) and Math.ulp(float) return an ulp, the smallest value which, when added to the argument, would be recognized as larger than the argument.
",Functions dealing with floating-point representation[edit],plain_text
970,"Math.copySign returns the value of the first argument with the sign of the second argument. It can be used to determine the sign of a zero value.
",Functions dealing with floating-point representation[edit],plain_text
971,"Math.getExponent returns (as an int) the exponent used to scale the floating-point argument in computer representation.
",Functions dealing with floating-point representation[edit],plain_text
972,,Rounding number example[edit],
973,"Sometimes, we are not only interested in mathematically correct rounded numbers, but we want that a fixed number of significant digits are always displayed, regardless of the number used. Here is an example program that returns always the correct string. You are invited to modify it such that it does the same and is simpler!
",Rounding number example[edit],plain_text
974,"The constant class contains repeating constants that should exist only once in the code so that to avoid inadvertent changes. (If the one constant is changed inadvertently, it is most likely to be seen, as it is used at several locations.)
",Rounding number example[edit],plain_text
975," 1 /**
 2  * Class that comprises of constant values & string utilities.
 3  *
 4  * @since 2013-09-05
 5  * @version 2014-10-14
 6  */
 7 public class StringUtils {
 8 	/** Dash or minus constant */
 9 	public static final char DASH = '-'; 
10 	/** The exponent sign in a scientific number, or the capital letter E */
11 	public static final char EXPONENT = 'E';
12 	/** The full stop or period */
13 	public static final char PERIOD = '.';
14 	/** The zero string constant used at several places */
15 	public static final String ZERO = ""0"";
16 
17 	/**
18 	 * Removes all occurrences of the filter character in the text.
19 	 *
20 	 * @param text Text to be filtered
21 	 * @param filter The character to be removed.
22 	 * @return the string
23 	 */
24 	public static String filter(final String text, final String filter) {
25 		final String[] words = text.split(""["" + filter + ""]"");
26 
27 		switch (words.length) {
28 			case 0: return text;
29 			case 1: return words[0];
30 			default:
31 				final StringBuilder filteredText = new StringBuilder();
32 
33 				for (final String word : words) {
34 					filteredText.append(word);
35 				}
36 
37 				return filteredText.toString();
38 		}
39 	}
40 }
",Rounding number example[edit],code_fragment
976,"The MathsUtils class is like an addition to the java.lang.Math class and contains the rounding calculations.
",Rounding number example[edit],plain_text
977,"  1 package string;
  2 
  3 /**
  4  * Class for special mathematical calculations.<br/>
  5  * ATTENTION:<br/>Should depend only on standard Java libraries!
  6  *
  7  * @since 2013-09-05
  8  * @version 2014-10-14
  9 */
 10 public class MathsUtils {
 11 
 12 	// CONSTANTS
 13 	// ------------------------------------------
 14 
 15 	/** The exponent sign in a scientific number, or the capital letter E. */
 16 	public static final char EXPONENT = 'E';
 17 
 18 	/** Value after which the language switches from scientific to double */
 19 	private static final double E_TO_DOUBLE = 1E-3;
 20 
 21 	/** The zero string constant used at several places. */
 22 	public static final String ZERO = ""0"";
 23 
 24 	/** The string of zeros */
 25 	private static final String ZEROS = ""000000000000000000000000000000000"";
 26 
 27 	// METHODS
 28 	// ------------------------------------------
 29 
 30 	/**
 31 	 * Determines, if the number uses a scientific representation.
 32 	 *
 33 	 * @param number the number
 34 	 * @return true, if it is a scientific number, false otherwise
 35 	 */
 36 	private static boolean isScientific(final double number) {
 37 		return ((new Double(number)).toString().indexOf(EXPONENT) > 0);
 38 	}
 39 
 40 	/**
 41 	 * Determines how many zeros are to be appended after the decimal digits.
 42 	 *
 43 	 * @param significantsAfter Requested significant digits after decimal
 44 	 * @param separator Language-specific decimal separator
 45 	 * @param number Rounded number
 46 	 * @return Requested value
 47 	 */
 48 	private static byte calculateMissingSignificantZeros(
 49 			final byte significantsAfter,
 50 			final char separator,
 51 			final double number) {
 52 
 53 		final byte after = findSignificantsAfterDecimal(separator, number);
 54 
 55 		final byte zeros =
 56 				(byte) (significantsAfter - ((after == 0) ? 1 : after));
 57 
 58 		return ((zeros >= 0) ? zeros : 0);
 59 	}
 60 
 61 	/**
 62 	 * Finds the insignificant zeros after the decimal separator.
 63 	 *
 64 	 * @param separator Language-specific decimal separator
 65 	 * @param number the number
 66 	 * @return the byte
 67 	 */
 68 	private static byte findInsignificantZerosAfterDecimal(
 69 			final char separator,
 70 			final double number) {
 71 
 72 		if ((Math.abs(number) >= 1) || isScientific(number)) {
 73 			return 0;
 74 		} else {
 75 			final StringBuilder string = new StringBuilder();
 76 
 77 			string.append(number);
 78 			string.delete(0,
 79 					string.indexOf(new Character(separator).toString()) + 1);
 80 
 81 			// Determine what to match:
 82 			final String regularExpression = ""[1-9]"";
 83 
 84 			final String[] split = string.toString().split(regularExpression);
 85 
 86 			return (split.length > 0) ? (byte) split[0].length() : 0;
 87 		}
 88 	}
 89 
 90 	/**
 91 	 * Calculates the number of all significant digits (without the sign and
 92 	 * the decimal separator).
 93 	 *
 94 	 * @param significantsAfter Requested significant digits after decimal
 95 	 * @param separator Language-specific decimal separator
 96 	 * @param number Value where the digits are to be counted
 97 	 * @return Number of significant digits
 98 	 */
 99 	private static byte findSignificantDigits(final byte significantsAfter,
100 			final char separator,
101 			final double number) {
102 
103 		if (number == 0) { return 0; }
104 		else {
105 			String mantissa =
106 					findMantissa(separator, new Double(number).toString());
107 
108 			if (number == (long)number) {
109 				mantissa = mantissa.substring(0, mantissa.length() - 1);
110 			}
111 
112 			mantissa = retrieveDigits(separator, mantissa);
113 			// Find the position of the first non-zero digit:
114 			short nonZeroAt = 0;
115 
116 			for (; (nonZeroAt < mantissa.length())
117 					&& (mantissa.charAt(nonZeroAt) == '0'); nonZeroAt++) ;
118 
119 			return (byte)mantissa.substring(nonZeroAt).length();
120 		}
121 	}
122 	
123 	/**
124 	 * Determines the number of significant digits after the decimal separator
125 	 * knowing the total number of significant digits and the number before the
126 	 * decimal separator.
127 	 *
128 	 * @param significantsBefore Number of significant digits before separator
129 	 * @param significantDigits Number of all significant digits
130 	 * @return Number of significant decimals after the separator
131 	 */
132 	private static byte findSignificantsAfterDecimal(
133 			final byte significantsBefore,
134 			final byte significantDigits) {
135 
136 		final byte afterDecimal =
137 				(byte) (significantDigits - significantsBefore);
138 
139 		return (byte) ((afterDecimal > 0) ? afterDecimal : 0);
140 	}
141 
142 	/**
143 	 * Determines the number of digits before the decimal point.
144 	 *
145 	 * @param separator Language-specific decimal separator
146 	 * @param number Value to be scrutinised
147 	 * @return Number of digits before the decimal separator
148 	 */
149 	private static byte findSignificantsBeforeDecimal(final char separator,
150 													final double number) {
151 
152 		final String value = new Double(number).toString();
153 
154 		// Return immediately, if result is clear: Special handling at
155 		// crossroads of floating point and exponential numbers:
156 		if ((number == 0) || (Math.abs(number) >= E_TO_DOUBLE)
157 				&& (Math.abs(number) < 1)) {
158 
159 			return 0;
160 		} else if ((Math.abs(number) > 0) && (Math.abs(number) < E_TO_DOUBLE)) {
161 			return 1;
162 		} else {
163 			byte significants = 0;
164 			// Significant digits to the right of decimal separator:
165 			for (byte b = 0; b < value.length(); b++) {
166 				if (value.charAt(b) == separator) {
167 					break;
168 				} else if (value.charAt(b) != StringUtils.DASH) {
169 					significants++;
170 				}
171 			}
172 
173 			return significants;
174 		}
175 	}
176 
177 	/**
178 	 * Returns the exponent part of the double number.
179 	 *
180 	 * @param number Value of which the exponent is of interest
181 	 * @return Exponent of the number or zero.
182 	 */
183 	private static short findExponent(final double number) {
184 		return new Short(findExponent((new Double(number)).toString()));
185 	}
186 
187 	/**
188 	 * Finds the exponent of a number.
189 	 *
190 	 * @param value Value where an exponent is to be searched
191 	 * @return Exponent, if it exists, or ""0"".
192 	 */
193 	private static String findExponent(final String value) {
194 		final short exponentAt = (short) value.indexOf(EXPONENT);
195 
196 		if (exponentAt < 0) { return ZERO; }
197 		else {
198 			return value.substring(exponentAt + 1);
199 		}
200 	}
201 
202 	/**
203 	 * Finds the mantissa of a number.
204 	 *
205 	 * @param separator Language-specific decimal separator
206 	 * @param value Value where the mantissa is to be found
207 	 * @return Mantissa of the number
208 	 */
209 	private static String findMantissa(final char separator,
210 										final String value) {
211 
212 		String strValue = value;
213 
214 		final short exponentAt = (short) strValue.indexOf(EXPONENT);
215 
216 		if (exponentAt > -1) {
217 			strValue = strValue.substring(0, exponentAt);
218 		}
219 		return strValue;
220 	}
221 
222 	/**
223 	 * Retrieves the digits of the value without decimal separator or sign.
224 	 *
225 	 * @param separator
226 	 * @param number Mantissa to be scrutinised
227 	 * @return The digits only
228 	 */
229 	private static String retrieveDigits(final char separator, String number) {
230 		// Strip off exponent part, if it exists:
231 		short eAt = (short)number.indexOf(EXPONENT);
232 
233 		if (eAt > -1) {
234 			number = number.substring(0, eAt);
235 		}
236 
237 		return number.replace((new Character(StringUtils.DASH)).toString(), """").
238 				replace((new Character(separator)).toString(), """");
239 	}
240 
241 
242 	// ---- Public methods ----------------------
243 
244 	/**
245 	 * Returns the number of digits in the long value.
246 	 *
247 	 * @param value the value
248 	 * @return the byte
249 	 */
250 	public static byte digits(final long value) {
251 		return (byte) StringUtils.filter(Long.toString(value), "".,"").length();
252 	}
253 
254 	/**
255 	 * Finds the significant digits after the decimal separator of a mantissa.
256 	 *
257 	 * @param separator Language-specific decimal separator
258 	 * @param number Value to be scrutinised
259 	 * @return Number of significant zeros after decimal separator.
260 	 */
261 	public static byte findSignificantsAfterDecimal(final char separator,
262 													final double number) {
263 
264 		if (number == 0) { return 1; }
265 		else {
266 			String value = (new Double(number)).toString();
267 
268 			final short separatorAt = (short) value.indexOf(separator);
269 
270 			if (separatorAt > -1) {
271 				value = value.substring(separatorAt + 1);
272 			}
273 
274 			final short exponentAt = (short) value.indexOf(EXPONENT);
275 
276 			if (exponentAt > 0) {
277 				value = value.substring(0, exponentAt);
278 			}
279 
280 			final Long longValue = new Long(value).longValue();
281 
282 			if (Math.abs(number) < 1) {
283 				return (byte) longValue.toString().length();
284 			} else if (longValue == 0) {
285 				return 0;
286 			} else {
287 				return (byte) ((""0."" + value).length() - 2);
288 			}
289 		}
290 	}
291 
292 	/**
293 	 * Calculates the power of the base to the exponent without changing the
294 	 * least-significant digits of a number.
295 	 *
296 	 * @param basis
297 	 * @param exponent
298 	 * @return basis to power of exponent
299 	 */
300 	public static double power(final int basis, final short exponent) {
301 		return power((short) basis, exponent);
302 	}
303 
304 	/**
305 	 * Calculates the power of the base to the exponent without changing the
306 	 * least-significant digits of a number.
307 	 *
308 	 * @param basis the basis
309 	 * @param exponent the exponent
310 	 * @return basis to power of exponent
311 	 */
312 	public static double power(final short basis, final short exponent) {
313 		if (basis == 0) {
314 			return (exponent != 0) ? 1 : 0;
315 		} else {
316 			if (exponent == 0) {
317 				return 1;
318 			} else {
319 				// The Math method power does change the least significant
320 				// digits after the decimal separator and is therefore useless.
321 				double result = 1;
322 				short s = 0;
323 
324 				if (exponent > 0) {
325 					for (; s < exponent; s++) {
326 						result *= basis;
327 					}
328 				} else if (exponent < 0) {
329 					for (s = exponent; s < 0; s++) {
330 						result /= basis;
331 					}
332 				}
333 
334 				return result;
335 			}
336 		}
337 	}
338 
339 	/**
340 	 * Rounds a number to the decimal places.
341 	 *
342 	 * @param significantsAfter Requested significant digits after decimal
343 	 * @param separator Language-specific decimal separator
344 	 * @param number Number to be rounded
345 	 * @return Rounded number to the requested decimal places
346 	 */
347 	public static double round(final byte significantsAfter,
348 								final char separator,
349 								final double number) {
350 
351 		if (number == 0) { return 0; }
352 		else {
353 			final double constant = power(10, (short)
354 					(findInsignificantZerosAfterDecimal(separator, number)
355 							+ significantsAfter));
356 			final short dExponent = findExponent(number);
357 
358 			short exponent = dExponent;
359 
360 			double value = number*constant*Math.pow(10, -exponent);
361 			final String exponentSign =
362 					(exponent < 0) ? String.valueOf(StringUtils.DASH) : """";
363 
364 			if (exponent != 0) {
365 				exponent = (short) Math.abs(exponent);
366 
367 				value = round(value);
368 			} else {
369 				value = round(value)/constant;
370 			}
371 
372 			// Power method cannot be used, as the exponentiated number may
373 			// exceed the maximal long value.
374 			exponent -= Math.signum(dExponent)*(findSignificantDigits
375 					(significantsAfter, separator, value) - 1);
376 
377 			if (dExponent != 0) {
378 				String strValue = Double.toString(value);
379 
380 				strValue = strValue.substring(0, strValue.indexOf(separator))
381 						+ EXPONENT + exponentSign + Short.toString(exponent);
382 
383 				value = new Double(strValue);
384 			}
385 
386 			return value;
387 		}
388 	}
389 
390 	/**
391 	 * Rounds a number according to mathematical rules.
392 	 *
393 	 * @param value the value
394 	 * @return the double
395 	 */
396 	public static double round(final double value) {
397 		return (long) (value + .5);
398 	}
399 
400 	/**
401 	 * Rounds to a fixed number of significant digits.
402 	 *
403 	 * @param significantDigits Requested number of significant digits
404 	 * @param separator Language-specific decimal separator
405 	 * @param dNumber Number to be rounded
406 	 * @return Rounded number
407 	 */
408 	public static String roundToString(final byte significantDigits,
409 										final char separator,
410 										double dNumber) {
411 										
412 		// Number of significants that *are* before the decimal separator:
413 		final byte significantsBefore =
414 			findSignificantsBeforeDecimal(separator, dNumber);
415 		// Number of decimals that *should* be after the decimal separator:
416 		final byte significantsAfter = findSignificantsAfterDecimal(
417 				significantsBefore, significantDigits);
418 		// Round to the specified number of digits after decimal separator:
419 		final double rounded = MathsUtils.round(significantsAfter, separator, dNumber);
420 
421 		final String exponent = findExponent((new Double(rounded)).toString());
422 		final String mantissa = findMantissa(separator,
423 						(new Double(rounded)).toString());
424 
425 		final double dMantissa = new Double(mantissa).doubleValue();
426 		final StringBuilder result = new StringBuilder(mantissa);
427 		// Determine the significant digits in this number:
428 		final byte significants = findSignificantDigits(significantsAfter,
429 				separator, dMantissa);
430 		// Add lagging zeros, if necessary:
431 		if (significants <= significantDigits) {
432 			if (significantsAfter != 0) {
433 				result.append(ZEROS.substring(0,
434 						calculateMissingSignificantZeros(significantsAfter,
435 								separator, dMantissa)));
436 			} else {
437 				// Cut off the decimal separator & after decimal digits:
438 				final short decimal = (short) result.indexOf(
439 						new Character(separator).toString());
440 
441 				if (decimal > -1) {
442 					result.setLength(decimal);
443 				}
444 			}
445 		} else if (significantsBefore > significantDigits) {
446 			dNumber /= power(10, (short) (significantsBefore - significantDigits));
447 
448 			dNumber = round(dNumber);
449 
450 			final short digits =
451 					(short) (significantDigits + ((dNumber < 0) ? 1 : 0));
452 
453 			final String strDouble = (new Double(dNumber)).toString().substring(0, digits);
454 
455 			result.setLength(0);
456 			result.append(strDouble + ZEROS.substring(0,
457 					significantsBefore - significantDigits));
458 		}
459 
460 		if (new Short(exponent) != 0) {
461 			result.append(EXPONENT + exponent);
462 		}
463 
464 		return result.toString();
465 	} // public static String roundToString(…)
466 
467 	/**
468 	 * Rounds to a fixed number of significant digits.
469 	 *
470 	 * @param separator Language-specific decimal separator
471 	 * @param significantDigits Requested number of significant digits
472 	 * @param value Number to be rounded
473 	 * @return Rounded number
474 	 */
475 	public static String roundToString(final char separator,
476 										final int significantDigits,
477 										float value) {
478 
479 		return roundToString((byte)significantDigits, separator,
480 				(double)value);
481 	}
482 } // class MathsUtils
",Rounding number example[edit],code_fragment
978,"The code is tested with the following JUnit test:
",Rounding number example[edit],plain_text
979,"  1 package string;
  2 
  3 import static org.junit.Assert.assertEquals;
  4 import static org.junit.Assert.assertFalse;
  5 import static org.junit.Assert.assertTrue;
  6 
  7 import java.util.Vector;
  8 
  9 import org.junit.Test;
 10 
 11 /**
 12  * The JUnit test for the <code>MathsUtils</code> class.
 13  *
 14  * @since 2013-03-26
 15  * @version 2014-10-14
 16  */
 17 public class MathsUtilsTest {
 18 
 19 	/**
 20 	 * Method that adds a negative and a positive value to values.
 21 	 *
 22 	 * @param d the double value
 23 	 * @param values the values
 24 	 */
 25 	private static void addValue(final double d, Vector<Double> values) {
 26 		values.add(-d);
 27 		values.add(d);
 28 	}
 29 
 30 	// Public methods ------
 31 
 32 	/**
 33 	 * Tests the round method with a double parameter.
 34 	 */
 35 	@Test
 36 	public void testRoundToStringDoubleByteCharDouble() {
 37 		// Test rounding
 38 		final Vector<Double> values = new Vector<Double>();
 39 		final Vector<String> strValues = new Vector<String>();
 40 
 41 		values.add(0.0);
 42 		strValues.add(""0.00000"");
 43 		addValue(1.4012984643248202e-45, values);
 44 		strValues.add(""-1.4012E-45"");
 45 		strValues.add(""1.4013E-45"");
 46 		addValue(1.999999757e-5, values);
 47 		strValues.add(""-1.9999E-5"");
 48 		strValues.add(""2.0000E-5"");
 49 		addValue(1.999999757e-4, values);
 50 		strValues.add(""-1.9999E-4"");
 51 		strValues.add(""2.0000E-4"");
 52 		addValue(1.999999757e-3, values);
 53 		strValues.add(""-0.0019999"");
 54 		strValues.add(""0.0020000"");
 55 		addValue(0.000640589, values);
 56 		strValues.add(""-6.4058E-4"");
 57 		strValues.add(""6.4059E-4"");
 58 		addValue(0.3396899998188019, values);
 59 		strValues.add(""-0.33968"");
 60 		strValues.add(""0.33969"");
 61 		addValue(0.34, values);
 62 		strValues.add(""-0.33999"");
 63 		strValues.add(""0.34000"");
 64 		addValue(7.07, values);
 65 		strValues.add(""-7.0699"");
 66 		strValues.add(""7.0700"");
 67 		addValue(118.188, values);
 68 		strValues.add(""-118.18"");
 69 		strValues.add(""118.19"");
 70 		addValue(118.2, values);
 71 		strValues.add(""-118.19"");
 72 		strValues.add(""118.20"");
 73 		addValue(123.405009, values);
 74 		strValues.add(""-123.40"");
 75 		strValues.add(""123.41"");
 76 		addValue(30.76994323730469, values);
 77 		strValues.add(""-30.769"");
 78 		strValues.add(""30.770"");
 79 		addValue(130.76994323730469, values);
 80 		strValues.add(""-130.76"");
 81 		strValues.add(""130.77"");
 82 		addValue(540, values);
 83 		strValues.add(""-539.99"");
 84 		strValues.add(""540.00"");
 85 		addValue(12345, values);
 86 		strValues.add(""-12344"");
 87 		strValues.add(""12345"");
 88 		addValue(123456, values);
 89 		strValues.add(""-123450"");
 90 		strValues.add(""123460"");
 91 		addValue(540911, values);
 92 		strValues.add(""-540900"");
 93 		strValues.add(""540910"");
 94 		addValue(9.223372036854776e56, values);
 95 		strValues.add(""-9.2233E56"");
 96 		strValues.add(""9.2234E56"");
 97 
 98 		byte i = 0;
 99 		final byte significants = 5;
100 
101 		for (final double element : values) {
102 			final String strValue;
103 
104 			try {
105 				strValue = MathsUtils.roundToString(significants, StringUtils.PERIOD, element);
106 
107 				System.out.println("" MathsUtils.round("" + significants  + "", '""
108 						+ StringUtils.PERIOD + ""', "" + element + "") ==> ""
109 						+ strValue + "" = "" + strValues.get(i));
110 				assertEquals(""Testing roundToString"", strValue, strValues.get(i++));
111 			} catch (final Exception e) {
112 				// TODO Auto-generated catch block
113 				e.printStackTrace();
114 			}
115 		}
116 	}
117 
118 }	// class MathsUtilsTest
",Rounding number example[edit],code_fragment
980,"The output of the JUnit test follows:
",Rounding number example[edit],plain_text
981,"If you are interested in a comparison with C#, take a look at the rounding number example there. If you are interested in a comparison with C++, you can compare this code here with the same example over there.
",Rounding number example[edit],plain_text
982,"Notice that in the expression starting with if ((D == 0), I have to use OR instead of the || because of a bug in the source template.
",Rounding number example[edit],plain_text
983,"
The integer primitive type with the largest range of value is the long, from -263 to 263-1. If you need greater or lesser values, you have to use the BigInteger class in the package java.math. A BigInteger object can represent any integer (as large as the RAM on the computer can hold) as it is not mapped on a primitive type. Respectively, you need to use the BigDecimal class for great decimal numbers.
",Large numbers,plain_text
984,"However, as these perform much slower than primitive types, it is recommended to use primitive types when it is possible.
",Large numbers,plain_text
985,,BigInteger[edit],
986,"The BigInteger class represents integers of almost any size. As with other objects, they need to be constructed.  Unlike regular numbers, the BigInteger represents an immutable object - methods in use by the BigInteger class will return a new copy of a BigInteger.  
",BigInteger[edit],plain_text
987,"To instantiate a BigInteger, you can create it from either byte array, or from a string.  For example:
",BigInteger[edit],plain_text
988,"1 BigInteger i = new BigInteger(""1000000000000000000"");
",BigInteger[edit],code_fragment
989,"BigInteger cannot use the normal Java operators. They use the methods provided by the class.
",BigInteger[edit],plain_text
990,"1 BigInteger a = new BigInteger(""3"");
2 BigInteger b = new BigInteger(""4"");
3 
4 // c = a^2 + b^2
5 BigInteger c = a.multiply(a).add(b.multiply(b));
",BigInteger[edit],code_fragment
991,"It is possible to convert to a long, but the long may not be large enough.
",BigInteger[edit],plain_text
992,"1 BigInteger aBigInteger = new BigInteger(""3"");
2 long aLong = aBigInteger.longValue();
",BigInteger[edit],code_fragment
993,,BigDecimal[edit],
994,"The BigInteger class cannot handle decimal numbers. The BigDecimal class represents a floating point value of arbitrary precision.  It is composed of both a BigInteger, and a scale value (represented by a 32-bit integer).
",BigDecimal[edit],plain_text
995,"
To generate random numbers the Math.random() method can be used, which returns a double, greater than or equal to 0.0 and less than 1.0.
",Random numbers,plain_text
996,"The following code returns a random integer between n and m (where n <= randomNumber < m):
",Random numbers,plain_text
997,"1   int randomNumber = n + (int)(Math.random() * ( m - n ));
",Random numbers,code_fragment
998,"Alternatively, the java.util.Random class provides methods for generating random booleans, bytes, floats, ints, longs and 'Gaussians' (doubles from a normal distribution with mean 0.0 and standard deviation 1.0). For example, the following code is equivalent to that above:
",Random numbers,plain_text
999,"1   Random random = new Random();
2   int randomNumber = n + random.nextInt(m - n);
",Random numbers,code_fragment
1000,"As an example using random numbers, we can make a program that uses a Random object to simulate flipping a coin 20 times:
",Random numbers,plain_text
1001," 1 import java.util.Random;
 2 
 3 public class CoinFlipper {
 4 
 5   public static void main(String[] args) {
 6     // The number of times to flip the coin
 7     final int TIMES_TO_FLIP = 20;
 8     int heads = 0;
 9     int tails = 0;
10     // Create a Random object
11     Random random = new Random();
12     for (int i = 0; i < TIMES_TO_FLIP; i++) {
13       // 0 or 1
14       int result = random.nextInt(2);
15       if (result == 1) {
16         System.out.println(""Heads"");
17         heads++;
18       } else {
19         System.out.println(""Tails"");
20         tails++;
21       }
22     }
23     System.out.println(""There were ""
24             + heads
25             + "" heads and ""
26             + tails
27             + "" tails"");
28   }
29 }
",Random numbers,code_fragment
1002,"Of course, if you run the program you will probably get different results.
",Random numbers,plain_text
1003,,Truly random numbers[edit],
1004,"Both Math.random() and the Random class produce pseudorandom numbers. This is good enough for a lot of applications, but remember that it is not truly random. If you want a more secure random number generator, Java provides the java.security.SecureRandom package. What happens with Math.random() and the Random class is that a 'seed' is chosen from which the pseudorandom numbers are generated. SecureRandom increases the security to ensure that the seed which is used by the pseudorandom number generator is non-deterministic — that is, you cannot simply put the machine in the same state to get the same set of results. Once you have created a SecureRandom instance, you can use it in the same way as you can the Random class.
",Truly random numbers[edit],plain_text
1005,"If you want truly random numbers, you can get a hardware random number generator or use a randomness generation service.
",Truly random numbers[edit],plain_text
1006,"
Most Java program text consists of ASCII characters, but any Unicode character can be used as part of identifier names, in comments, and in character and string literals. For example, π (which is the Greek Lowercase Letter pi) is a valid Java identifier:
",Unicode,plain_text
1007,"1 double π = Math.PI;
",Unicode,code_fragment
1008,"and in a string literal:
",Unicode,plain_text
1009,"1 String pi = ""π"";
",Unicode,code_fragment
1010,,Unicode escape sequences[edit],
1011,"Unicode characters can also be expressed through Unicode Escape Sequences. Unicode escape sequences may appear anywhere in a Java source file (including inside identifiers, comments, and string literals).
",Unicode escape sequences[edit],plain_text
1012,"Unicode escape sequences consist of
",Unicode escape sequences[edit],plain_text
1013,"Such sequences represent the UTF-16 encoding of a Unicode character. For example, 'a' is equivalent to '\u0061'. This escape method does not support characters beyond U+FFFF or you have to make use of surrogate pairs.[1]
",Unicode escape sequences[edit],plain_text
1014,"Any and all characters in a program may be expressed in Unicode escape characters, but such programs are not very readable, except by the Java compiler - in addition, they are not very compact.
",Unicode escape sequences[edit],plain_text
1015,"One can find a full list of the characters here.
",Unicode escape sequences[edit],plain_text
1016,"π may also be represented in Java as the Unicode escape sequence \u03C0. Thus, the following is a valid, but not very readable, declaration and assignment:
",Unicode escape sequences[edit],plain_text
1017,"1 double \u03C0 = Math.PI;
",Unicode escape sequences[edit],code_fragment
1018,"The following demonstrates the use of Unicode escape sequences in other Java syntax:
",Unicode escape sequences[edit],plain_text
1019,"1 // Declare Strings pi and quote which contain \u03C0 and \u0027 respectively:
2 String pi = ""\u03C0"";
3 String quote = ""\u0027"";
",Unicode escape sequences[edit],code_fragment
1020,"Note that a Unicode escape sequence functions just like any other character in the source code. E.g., \u0022 (double quote, "") needs to be quoted in a string just like "".
",Unicode escape sequences[edit],plain_text
1021,"1 // Declare Strings doubleQuote1 and doubleQuote2 which both contain "" (double quote):
2 String doubleQuote1 = ""\"""";
3 String doubleQuote2 = ""\\u0022""; // ""\u0022"" doesn't work since """""" doesn't work.
",Unicode escape sequences[edit],code_fragment
1022,,International language support[edit],
1023,"The language distinguishes between bytes and characters. Characters are stored internally using UCS-2, although as of J2SE 5.0, the language also supports using UTF-16 and its surrogates. Java program source may therefore contain any Unicode character.
",International language support[edit],plain_text
1024,"The following is thus perfectly valid Java code; it contains Chinese characters in the class and variable names as well as in a string literal:
",International language support[edit],plain_text
1025,"1 public class 哈嘍世界 {
2     private String 文本 = ""哈嘍世界"";
3 }
",International language support[edit],code_fragment
1026,,References[edit],
1027,"
",References[edit],plain_text
1028,"
A comment allows to insert text that will not be compiled nor interpreted. It can appear anywhere in the source code where whitespaces are allowed.
",Comments,plain_text
1029,"It is useful for explaining what the source code does by:
",Comments,plain_text
1030,"explaining the adopted technical choice: why this given algorithm and not another, why calling this given method...
explaining what should be done in the next steps (the TODO list): improvement, issue to fix...
giving the required explanation to understand the code and be able to update it yourself later or by other developers.",Comments,plain_text
1031,"It can also be used to make the compiler ignore a portion of code: temporary code for debugging, code under development...
",Comments,plain_text
1032,,Syntax[edit],
1033,"The comments in Java use the same syntax as in C++.
",Syntax[edit],plain_text
1034,"An end-of-line comment starts with two slashes and ends with the end of the line. This syntax can be used on a single line too.
",Syntax[edit],plain_text
1035,"1 // A comment to give an example
2 
3 int n = 10; // 10 articles
",Syntax[edit],code_fragment
1036,"A comment on several lines is framed with '/' + '*' and '*' + '/'.
",Syntax[edit],plain_text
1037," 1 /*
 2  * This is a comment
 3  * on several lines.
 4  */
 5 
 6 /* This also works; slash-star comments may be on a single line. */
 7 
 8 /*
 9 Disable debugging code:
10 
11 int a = 10;
12 while (a-- > 0) System.out.println(""DEBUG: tab[""+a+""]="" + tab[a]);
13 */
",Syntax[edit],code_fragment
1038,"By convention, subsequent lines of slash-star comments begin with a star aligned under the star in the open comment sequence, but this is not required. Never nest a slash-star comment in another slash-star comment. If you accidentally nest such comments, you will probably get a syntax error from the compiler soon after the first star-slash sequence.
",Syntax[edit],plain_text
1039,"1 /* This comment appears to contain /* a nested comment. */
2  * The comment ends after the first star-slash and
3  * everything after the star-slash sequence is parsed
4  * as non-comment source.
5  */
",Syntax[edit],code_fragment
1040,"If you need to have the sequence */ inside a comment you can use html numeric entities: *&#47;.
",Syntax[edit],plain_text
1041,"Slash-star comments may also be placed between any Java tokens, though not recommended:
",Syntax[edit],plain_text
1042,"1 int i = /* maximum integer */ Integer.MAX_VALUE;
",Syntax[edit],code_fragment
1043,"However, comments are not parsed as comments when they occur in string literals.
",Syntax[edit],plain_text
1044,"1 String text = ""/* This is not a comment. */"";
",Syntax[edit],code_fragment
1045,"It results in a 33 character string.
",Syntax[edit],plain_text
1046," 1 int a = 0;
 2 // a = a + 1;
 3 a = a + 1;
 4 /*
 5 a = a + 1;
 6 */
 7 a = a + 1;
 8 // /*
 9 a = a + 1;
10 // */
11 a = a /*+ 1*/;
12 a = a + 1; // a = a + 1;
13 System.out.println(""a="" + a);
",Syntax[edit],code_fragment
1047,,Comments and unicode[edit],
1048,"Be aware that Java still interprets Unicode sequences within comments. For example, the Unicode sequence \u002a\u002f (whose codepoints correspond to */) is processed early in the Java compiler's lexical scanning of the source file, even before comments are processed, so this is a valid star-slash comment in Java:
",Comments and unicode[edit],plain_text
1049,"1 /* This is a comment. \u002a\u002f
2 String statement = ""This is not a comment."";
",Comments and unicode[edit],code_fragment
1050,"and is lexically equivalent to
",Comments and unicode[edit],plain_text
1051,"1 /* This is a comment. */
2 String statement = ""This is not a comment."";
",Comments and unicode[edit],code_fragment
1052,"(The '*' character is Unicode 002A and the '/' character is Unicode 002F.)
",Comments and unicode[edit],plain_text
1053,"Similar caveats apply to newline characters in slash-slash comments.
",Comments and unicode[edit],plain_text
1054,"For example:
",Comments and unicode[edit],plain_text
1055,"1 // This is a single line comment \u000a This is code
",Comments and unicode[edit],code_fragment
1056,"That is because \u000a is Unicode for a new line, making the compiler think that you have added a new line when you haven't.
",Comments and unicode[edit],plain_text
1057,,Javadoc comments[edit],
1058,"Javadoc comments are a special case of slash-star comments.
",Javadoc comments[edit],plain_text
1059,"1 /**
2  * Comments which start with slash-star-star are Javadoc comments.
3  * These are used to extract documentation from the Java source.
4  * More on javadoc will be covered later.
5  */
",Javadoc comments[edit],code_fragment
1060,"Keywords are special tokens in the language which have reserved use in the language. Keywords may not be used as identifiers in Java — you cannot declare a field whose name is a keyword, for instance.
",Keywords,plain_text
1061,"Examples of keywords are the primitive types, int and boolean; the control flow statements for and if; access modifiers such as public, and special words which mark the declaration and definition of Java classes, packages, and interfaces: class, package, interface.
",Keywords,plain_text
1062,"Below are all the Java language keywords:
",Keywords,plain_text
1063,"In addition, the identifiers null, true, and false denote literal values and may not be used to create identifiers.
",Keywords,plain_text
1064,,abstract[edit],
1065,"abstract is a Java keyword. It can be applied to a class and methods. An abstract class cannot be directly instantiated. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword. A non-abstract class is a concrete class. An abstract class cannot be final.
",abstract[edit],plain_text
1066,"Only an abstract class can have abstract methods. An abstract method is only declared, not implemented:
",abstract[edit],plain_text
1067,"1 public abstract class AbstractClass {
2     // This method does not have a body; it is abstract.
3     public abstract void abstractMethod();
4  
5     // This method does have a body; it is implemented in the abstract class and gives a default behavior.
6     public void concreteMethod() {
7         System.out.println(""Already coded."");
8     }
9 }
",abstract[edit],code_fragment
1068,"An abstract method cannot be final, static nor native. Either you instantiate a concrete sub-class, either you instantiate the abstract class by implementing its abstract methods alongside a new statement:
",abstract[edit],plain_text
1069,"1 AbstractClass myInstance = new AbstractClass() {
2     public void abstractMethod() {
3         System.out.println(""Implementation."");
4     }
5 };
",abstract[edit],code_fragment
1070,"A private method cannot be abstract.
",abstract[edit],plain_text
1071,"
",abstract[edit],plain_text
1072,,assert[edit],
1073,"assert is a Java keyword used
to define an assert statement.
An assert statement is used to declare an expected boolean condition in a program.
If the program is running with assertions enabled, then the condition
is checked at runtime. If the condition is false, the Java runtime system
throws an AssertionError.
",assert[edit],plain_text
1074,"Assertions may be declared using the following syntax:
",assert[edit],plain_text
1075,"assert expression1 [: expression2];
",assert[edit],code_fragment
1076,"expression1 is a boolean that will throw the assertion if it is false.  When it is thrown, the assertion error exception is created with the parameter expression2 (if applicable). 
",assert[edit],plain_text
1077,"An example: 
",assert[edit],plain_text
1078,"assert list != null && list.size() > 0 : ""list variable is null or empty"";
Object value = list.get(0);
",assert[edit],code_fragment
1079,"Assertions are usually used as a debugging aid.  They should not be used instead of validating arguments to public methods, or in place of a more precise runtime error exception. 
",assert[edit],plain_text
1080,"Assertions are enabled with the Java -ea or -enableassertions
runtime option. See your Java environment documentation for additional options
for controlling assertions.
",assert[edit],plain_text
1081,,boolean[edit],
1082,"boolean is a keyword which designates the boolean primitive type. There are only two possible boolean values: true and false. The default value for boolean fields is false.
",boolean[edit],plain_text
1083,"The following is a declaration of a private boolean field named initialized, and its use in a method named synchronizeConnection.
",boolean[edit],plain_text
1084,"1 private boolean initialized = false;
2 
3 public void synchronizeConnection() {
4    if (!initialized) {
5       connection = connect();
6       initialized = true;
7    }
8 }
",boolean[edit],code_fragment
1085,"The previous code only creates a connection once (at the first method call). Note that there is no automatic conversion between integer types (such as int) to boolean as is possible in some languages like C. Instead, one must use an equivalent expression such as (i != 0) which evaluates to true if i is not zero.
",boolean[edit],plain_text
1086,,break[edit],
1087,"break is a Java keyword.
",break[edit],plain_text
1088,"Jumps (breaks) out from a loop. Also used at switch statement.
",break[edit],plain_text
1089,"For example:
",break[edit],plain_text
1090,"for ( int i=0; i < maxLoopIter; i++ ) {
   System.out.println(""Iter="" +i);
   if ( i == 5 ) {
      break;  // -- 5 iteration is enough --
   }
}
",break[edit],code_fragment
1091,"
See also: 
",break[edit],plain_text
1092,Java Programming/Keywords/switch,break[edit],plain_text
1093,,byte[edit],
1094,"byte is a keyword which designates
the 8 bit signed integer primitive type.
",byte[edit],plain_text
1095,"The java.lang.Byte class is the nominal
wrapper class when you need to store a byte value
but an object reference is required.
",byte[edit],plain_text
1096,"Syntax:
",byte[edit],plain_text
1097,"byte <variable-name> = <integer-value>;
",byte[edit],plain_text
1098,"For example:
",byte[edit],plain_text
1099,"byte b = 65;
",byte[edit],code_fragment
1100,"or 
",byte[edit],plain_text
1101,"byte b = 'A'
",byte[edit],code_fragment
1102,"The number 65 is the code for 'A' in ASCII.
",byte[edit],plain_text
1103,"See also: 
",byte[edit],plain_text
1104,Java Programming/Primitive Types,byte[edit],plain_text
1105,,case[edit],
1106,"case is a Java keyword.
",case[edit],plain_text
1107,"This is part of the switch statement, to find if the value passed to the switch statement matches a value followed by case.
",case[edit],plain_text
1108,"For example:
",case[edit],plain_text
1109,"int i = 3;
switch(i) {
case 1:
   System.out.println(""The number is 1."");
   break;
case 2:
   System.out.println(""The number is 2."");
   break;
case 3:
   System.out.println(""The number is 3.""); // this line will print
   break;
case 4:
   System.out.println(""The number is 4."");
   break;
case 5:
   System.out.println(""The number is 5."");
   break;
default:
  System.out.println(""The number is not 1, 2, 3, 4, or 5."");
}
",case[edit],code_fragment
1110,,catch[edit],
1111,"catch is a keyword.
",catch[edit],plain_text
1112,"It's part of a try block. If an exception is thrown inside a try block, the exception will be compared to any of the catch part of the block. If the exception match with one of the exception in the catch part, the exception will be handled there.
",catch[edit],plain_text
1113,"For example:
",catch[edit],plain_text
1114,"try {
   //...
     throw new MyException_1();
   //...
} catch ( MyException_1 e ) {
   // --- Handle the Exception_1 here --
} catch ( MyException_2 e ) {
   // --- Handle the Exception_2 here --
}
",catch[edit],code_fragment
1115,"
See also: 
",catch[edit],plain_text
1116,Java Programming/Keywords/try,catch[edit],plain_text
1117,,char[edit],
1118,"char is a keyword. It defines a character primitive type. char can be created from character literals and numeric representation. Character literals consist of a single quote character (') (ASCII 39, hex 0x27), a single character, and a close quote ('), such as 'w'. Instead of a character, you can also use unicode escape sequences, but there must be exactly one.
",char[edit],plain_text
1119,"Syntax:
",char[edit],plain_text
1120,"1 char oneChar1 = 'A';
2 char oneChar2 = 65;
3 char oneChar3 = '\u0041';
4 System.out.println(oneChar1);
5 System.out.println(oneChar2);
6 System.out.println(oneChar3);
",char[edit],code_fragment
1121,"65 is the numeric representation of character 'A' , or its ASCII code.
",char[edit],plain_text
1122,"The nominal wrapper class is the java.lang.Character class when you need to store a char value but an object reference is required.
",char[edit],plain_text
1123,"1 char aCharPrimitiveType = 'A';
2 Character aCharacterObject = aCharPrimitiveType;
",char[edit],code_fragment
1124,"See also:
",char[edit],plain_text
1125,Java Programming/Primitive Types,char[edit],plain_text
1126,,class[edit],
1127,"class is a Java keyword
which begins the declaration and definition of a class.
",class[edit],plain_text
1128,"The general syntax of a class declaration, using Extended Backus-Naur Form, is
",class[edit],plain_text
1129,"class-declaration ::= [access-modifiers] class identifier
                      [extends-clause] [implements-clause] 
                      class-body

extends-clause ::= extends class-name
implements-clause ::= implements interface-names 
interface-names ::= interface-name [, interface-names]
class-body ::= { [member-declarations] }
member-declarations = member-declaration [member-declarations]
member-declaration = field-declaration 
                     | initializer 
                     | constructor 
                     | method-declaration
                     | class-declaration
",class[edit],plain_text
1130,"The extends word is optional. If omitted, the class extends the Object class, as all Java classes inherit from it.
",class[edit],plain_text
1131,"See also: 
",class[edit],plain_text
1132,Java Programming/Keywords/new,class[edit],plain_text
1133,,const[edit],
1134,"const is a reserved keyword, presently not being used.
",const[edit],plain_text
1135,"In other programming languages, such as C, const is often used to declare a constant. However, in Java, final is used instead.
",const[edit],plain_text
1136,,continue[edit],
1137,"continue is a Java keyword. It skips the remainder of the loop and continues with the next iteration. 
",continue[edit],plain_text
1138,"For example:
",continue[edit],plain_text
1139,"int maxLoopIter = 7;

for (int i = 0; i < maxLoopIter; i++ ) {
   if (i == 5) {
      continue;  // -- 5 iteration is skipped --
   }
   System.println(""Iteration = "" + i);
}
",continue[edit],code_fragment
1140,"
results in
",continue[edit],plain_text
1141,"0
1
2
3
4
6
7
",continue[edit],plain_text
1142,,See also[edit],
1143,Java Programming/Statements,See also[edit],plain_text
1144,,default[edit],
1145,"default is a Java keyword.
",default[edit],plain_text
1146,"This is an optional part of the switch statement, which only executes if none of the above cases are matched.
",default[edit],plain_text
1147,"See also: 
",default[edit],plain_text
1148,Java Programming/Keywords/switch,default[edit],plain_text
1149,,do[edit],
1150,"do is a Java keyword.
",do[edit],plain_text
1151,"It starts a do-while looping block. The do-while loop is functionally similar to the while loop, except the condition is evaluated after the statements execute
",do[edit],plain_text
1152,"Syntax:
",do[edit],plain_text
1153,"do {
    //statements;
} while (condition);
",do[edit],code_fragment
1154,"For example:
",do[edit],plain_text
1155,"do {
    i++;
} while ( i < maxLoopIter );
",do[edit],code_fragment
1156,"See also: 
",do[edit],plain_text
1157,"Java Programming/Statements
Java Programming/Keywords/for
Java Programming/Keywords/while",do[edit],plain_text
1158,,double[edit],
1159,"double is a keyword which designates
the 64 bit float primitive type.
",double[edit],plain_text
1160,"The java.lang.Double class is the nominal wrapper class when you need to store a double value but an object reference is required.
",double[edit],plain_text
1161,"Syntax:
",double[edit],plain_text
1162,"double <variable-name> = <float-value>;
",double[edit],plain_text
1163,"For example:
",double[edit],plain_text
1164,"double d = 65.55;
",double[edit],code_fragment
1165,"
See also: 
",double[edit],plain_text
1166,Java Programming/Primitive Types,double[edit],plain_text
1167,,else[edit],
1168,"else is a Java keyword. It is an optional part of a branching statement. It starts the 'false' statement block.
",else[edit],plain_text
1169,"The general syntax of a if, using Extended Backus-Naur Form, is
",else[edit],plain_text
1170,"branching-statement ::= if condition-clause 
                                    single-statement | block-statement
                       [ else 
                                    single-statement | block-statement ]
 
condition-clause    ::= ( Boolean Expression )
single-statement    ::= Statement
block-statement     ::= { Statement [ Statement ] }
",else[edit],plain_text
1171,"For example:
",else[edit],plain_text
1172,"if ( expression ) {
   System.out.println(""'True' statement block"");
} else {
   System.out.println(""'False' statement block"");
}
",else[edit],code_fragment
1173,"
See also: 
",else[edit],plain_text
1174,Java Programming/Keywords/if,else[edit],plain_text
1175,,enum[edit],
1176,"/** Grades of courses */
  enum Grade { A, B, C, D, F };
  // ...
  private Grade gradeA = Grade.A;
",enum[edit],code_fragment
1177,"
This enumeration constant then can be passed in to methods:
",enum[edit],plain_text
1178,"student.assignGrade(gradeA);
  /**
   * Assigns the grade for this course to the student
   * @param GRADE  Grade to be assigned
   */
  public void assignGrade(final Grade GRADE) {
    grade = GRADE;
  }
",enum[edit],code_fragment
1179,"
An enumeration may also have parameters:
",enum[edit],plain_text
1180,"public enum DayOfWeek {
  /** Enumeration constants */
  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(0);

  /** Code for the days of the week */
  private byte dayCode = 0;

  /**
   * Private constructor
   * @param VALUE  Value that stands for a day of the week.
   */
  private DayOfWeek(final byte VALUE) {
    dayCode = java.lang.Math.abs(VALUE%7);
  }
 
  /**
   * Gets the day code
   * @return  The day code
   */
  public byte getDayCode() {
    return dayCode;
  }
}
",enum[edit],code_fragment
1181,"
It is also possible to let an enumeration implement interfaces other than java.lang.Comparable and java.io.Serializable, which are already implicitly implemented by each enumeration:
",enum[edit],plain_text
1182,"public enum DayOfWeek implements Runnable {
  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
 
  /**
   * Run method prints all elements
   */
  public void run() {
    System.out.println(""name() = "" + name() +
      "", toString() = \"""" + toString() + ""\"""");
  }
}
",enum[edit],code_fragment
1183,,extends[edit],
1184,"extends is a Java keyword. 
",extends[edit],plain_text
1185,"Used in class and interface definition to declare the class or interface that is to be extended.
",extends[edit],plain_text
1186,"Syntax:
",extends[edit],plain_text
1187,"public class MyClass extends SuperClass 
{
  //...
}
 
public interface MyInterface extends SuperInterface
{
  //...
}
",extends[edit],code_fragment
1188,"
In Java 1.5 and later, the ""extends"" keyword is also used to specify an upper bound on a type parameter in Generics.
",extends[edit],plain_text
1189,"class Foo<T extends Number> { /*...*/ }
",extends[edit],code_fragment
1190,"
See also: 
",extends[edit],plain_text
1191,"Java Programming/Creating Objects
Java Programming/Keywords/class",extends[edit],plain_text
1192,,final[edit],
1193,"final is a keyword. Beware! It has distinct meanings depending whether it is used for a class, a method, or for a variable. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword.
",final[edit],plain_text
1194,"1 private static final long serialVersionUID = -5437975414336623381L;
",final[edit],code_fragment
1195,,For a variable[edit],
1196,"The final keyword only allows a single assignment for the variable. That is to say, once the variable has been assigned, its value is in read-only. If the variable is a primitive type, its value will no longer change. If it is an object, only its reference will no longer change. Keep in mind that its value can still be changed.
",For a variable[edit],plain_text
1197,"1 final int a = 1;
2 a = 2;
",For a variable[edit],code_fragment
1198,"1 final ArrayList list = new ArrayList();
2 System.out.println(list.size());
3 list.add(""One item"");
4 System.out.println(list.size());
",For a variable[edit],code_fragment
1199,"A final variable is often used for universal constants, such as pi:
",For a variable[edit],plain_text
1200,"1 static final double PI = 3.1415926;
",For a variable[edit],code_fragment
1201,"The final keyword can also be used for method parameters:
",For a variable[edit],plain_text
1202,"1 public int method(final int inputInteger) {
2    int outputInteger = inputInteger + 1;
3    return outputInteger;
4 }
",For a variable[edit],code_fragment
1203,"It is useful for methods that use side effects to update some objects. Such methods modify the content of an object passed in parameter. The method caller will receive the object update. This will fail if the object parameter has been reassigned in the method. Another object will be updated instead. Final method parameter can also be used to keep the code clean.
",For a variable[edit],plain_text
1204,"The final keyword is similar to const in other languages and the readonly keyword in C#. A final variable cannot be volatile.
",For a variable[edit],plain_text
1205,,For a class[edit],
1206,"The final keyword forbids the creation of a subclass. It is the case of the Integer or String class.
",For a class[edit],plain_text
1207,"1 public final class SealedClass {
2   public static void main(String[] args) {
3   }
4 }
",For a class[edit],code_fragment
1208,"A final class cannot be abstract. The final keyword is similar to sealed keyword in C#.
",For a class[edit],plain_text
1209,,For a method[edit],
1210,"The final keyword forbids to overwrite the method in a subclass. It is useless if the class is already final and a private method is implicitly final. A final method cannot be abstract.
",For a method[edit],plain_text
1211,"1 public class NoOverwriting {
2   public final void sealedMethod() {
3   }
4 }
",For a method[edit],code_fragment
1212,,Interest[edit],
1213,"The final keyword is mostly used to guarantee a good usage of the code. For instance (non-static) methods, this allows the compiler to expand the method (similar to an inline function) if the method is small enough. Sometimes it is required to use it. For instance, a nested class can only access the members of the top-level class if they are final.
",Interest[edit],plain_text
1214,,finally[edit],
1215,"finally is a keyword which is an optional ending part of the try block.
",finally[edit],plain_text
1216,"1 try {
2   // ...
3 } catch (MyException1 e) {
4   // Handle the Exception1 here
5 } catch (MyException2 e) {
6   // Handle the Exception2 here
7 } finally {
8   // This will always be executed no matter what happens
9 }
",finally[edit],code_fragment
1217,"The code inside the finally block will always be executed. This is also true for cases when there is an exception or even executed return statement in the try block.
",finally[edit],plain_text
1218,"Three things can happen in a try block. First, no exception is thrown:
",finally[edit],plain_text
1219," 1 System.out.println(""Before the try block"");
 2 try {
 3   System.out.println(""Inside the try block"");
 4 } catch (MyException1 e) {
 5   System.out.println(""Handle the Exception1"");
 6 } catch (MyException2 e) {
 7   System.out.println(""Handle the Exception2"");
 8 } finally {
 9   System.out.println(""Execute the finally block"");
10 }
11 System.out.println(""Continue"");
",finally[edit],code_fragment
1220,"You can see that we have passed in the try block, then we have executed the finally block and we have continued the execution. Now, a caught exception is thrown:
",finally[edit],plain_text
1221," 1 System.out.println(""Before the try block"");
 2 try {
 3   System.out.println(""Enter inside the try block"");
 4   throw new MyException1();
 5   System.out.println(""Terminate the try block"");
 6 } catch (MyException1 e) {
 7   System.out.println(""Handle the Exception1"");
 8 } catch (MyException2 e) {
 9   System.out.println(""Handle the Exception2"");
10 } finally {
11   System.out.println(""Execute the finally block"");
12 }
13 System.out.println(""Continue"");
",finally[edit],code_fragment
1222,"We have passed in the try block until where the exception occurred, then we have executed the matching catch block, the finally block and we have continued the execution. Now, an uncaught exception is thrown:
",finally[edit],plain_text
1223," 1 System.out.println(""Before the try block"");
 2 try {
 3   System.out.println(""Enter inside the try block"");
 4   throw new Exception();
 5   System.out.println(""Terminate the try block"");
 6 } catch (MyException1 e) {
 7   System.out.println(""Handle the Exception1"");
 8 } catch (MyException2 e) {
 9   System.out.println(""Handle the Exception2"");
10 } finally {
11   System.out.println(""Execute the finally block"");
12 }
13 System.out.println(""Continue"");
",finally[edit],code_fragment
1224,"We have passed in the try block until where the exception occurred and we have executed the finally block. NO CODE after the try-catch block has been executed. If there is an exception that happens before the try-catch block, the finally block is not executed.
",finally[edit],plain_text
1225,"If return statement is used inside finally, it overrides the return statement in the try-catch block.  For instance, the construct
",finally[edit],plain_text
1226,"1  try {
2    return 11;
3  }  finally {
4    return 12;
5  }
",finally[edit],code_fragment
1227,"will return 12, not 11. Professional code almost never contains statements that alter execution order (like return, break, continue) inside the finally block, as such code is more difficult to read and maintain.
",finally[edit],plain_text
1228,,float[edit],
1229,"float is a keyword which designates the 32 bit float primitive type.
",float[edit],plain_text
1230,"The java.lang.Float class is the nominal wrapper class when you need to store a float value but an object reference is required.
",float[edit],plain_text
1231,"Syntax:
",float[edit],plain_text
1232,"float <variable-name> = <float-value>;
",float[edit],plain_text
1233,"For example:
",float[edit],plain_text
1234,"float price = 49.95;
",float[edit],code_fragment
1235,"
See also: 
",float[edit],plain_text
1236,Java Programming/Primitive Types,float[edit],plain_text
1237,,for[edit],
1238,"for is a Java keyword.
",for[edit],plain_text
1239,"It starts a looping block.
",for[edit],plain_text
1240,"The general syntax of a for, using Extended Backus-Naur Form, is
",for[edit],plain_text
1241,"for-looping-statement ::= for condition-clause 
                                    single-statement | block-statement
 
condition-clause    ::= ( before-statement;  Boolean Expression ; after-statement )
single-statement    ::= Statement
block-statement     ::= { Statement [ Statement ] }
",for[edit],plain_text
1242,"For example:
",for[edit],plain_text
1243,"for ( int i=0; i < maxLoopIter; i++ ) {
    System.println(""Iter: "" +i);
}
",for[edit],code_fragment
1244,"
See also: 
",for[edit],plain_text
1245,"Java Programming/Keywords/while
Java Programming/Keywords/do",for[edit],plain_text
1246,,goto[edit],
1247,"goto is a reserved keyword, presently not being used.
",goto[edit],plain_text
1248,,if[edit],
1249,"if is a Java keyword. It starts a branching statement.
",if[edit],plain_text
1250,"The general syntax of a if, using Extended Backus-Naur Form, is
",if[edit],plain_text
1251,"branching-statement ::= if condition-clause 
                                    single-statement | block-statement
                       [ else 
                                    single-statement | block-statement ]
 
condition-clause    ::= ( Boolean Expression )
single-statement    ::= Statement
block-statement     ::= { Statement [ Statements ] }
",if[edit],plain_text
1252,"For example:
",if[edit],plain_text
1253,"if ( boolean Expression )
{
   System.out.println(""'True' statement block"");
}
else
{
   System.out.println(""'False' statement block"");
}
",if[edit],code_fragment
1254,"See also: 
",if[edit],plain_text
1255,Java Programming/Keywords/else,if[edit],plain_text
1256,,implements[edit],
1257,"implements is a Java keyword. 
",implements[edit],plain_text
1258,"Used in class definition to declare the Interfaces that are to be implemented by the class.
",implements[edit],plain_text
1259,"Syntax:
",implements[edit],plain_text
1260,"public class MyClass implements MyInterface1, MyInterface2
 {
   ...
 }
",implements[edit],code_fragment
1261,"
See also: 
",implements[edit],plain_text
1262,"Java Programming/Creating Objects
Java Programming/Keywords/class
Java Programming/Keywords/interface",implements[edit],plain_text
1263,,import[edit],
1264,"import is a Java keyword. 
",import[edit],plain_text
1265,"It declares a Java class to use in the code below the import statement.  Once a Java class is declared, then the class name can be used in the code without specifying the package the class belongs to.  
",import[edit],plain_text
1266,"Use the '*' character to declare all the classes belonging to the package.
",import[edit],plain_text
1267,"Syntax:
",import[edit],plain_text
1268,"import package.JavaClass;
import package.*;
",import[edit],code_fragment
1269,"
The static import construct allows unqualified access to static members without inheriting from the type containing the static members:
",import[edit],plain_text
1270,"   import static java.lang.Math.PI;
",import[edit],plain_text
1271,"Once the static members have been imported, they may be used without qualification:
",import[edit],plain_text
1272,"   double r = cos(PI * theta);
",import[edit],plain_text
1273,"Caveat: use static import very sparingly to avoid polluting the program's namespace!
",import[edit],plain_text
1274,"See also: 
",import[edit],plain_text
1275,Java Programming/Packages,import[edit],plain_text
1276,,instanceof[edit],
1277,"instanceof is a keyword.
",instanceof[edit],plain_text
1278,"It checks if an object reference is an instance of a type, and returns a boolean value;
",instanceof[edit],plain_text
1279,"The <object-reference> instanceof Object will return true for all non-null object references, since all Java objects are inherited from Object. instanceof will always return false if <object-reference> is null.
",instanceof[edit],plain_text
1280,"Syntax:
",instanceof[edit],plain_text
1281,"<object-reference> instanceof TypeName
",instanceof[edit],plain_text
1282,"For example:
",instanceof[edit],plain_text
1283,"class Fruit
 {
  //...	
 } 
 class Apple extends Fruit
 {
  //...
 }
 class Orange extends Fruit
 {
  //...
 }
 public class Test 
 {
    public static void main(String[] args) 
    {
       Collection<Object> coll = new ArrayList<Object>();
 
       Apple app1 = new Apple();
       Apple app2 = new Apple();
       coll.add(app1);
       coll.add(app2);
 
       Orange or1 = new Orange();
       Orange or2 = new Orange();
       coll.add(or1);
       coll.add(or2);
 
       printColl(coll);
    }
 
    private static String printColl( Collection<?> coll )
    {
       for (Object obj : coll)
       {
          if ( obj instanceof Object )
          {
             System.out.print(""It is a Java Object and"");
          }
          if ( obj instanceof Fruit )
          {
             System.out.print(""It is a Fruit and"");
          }
          if ( obj instanceof Apple )
          {
             System.out.println(""it is an Apple"");
          } 
          if ( obj instanceof Orange )
          {
             System.out.println(""it is an Orange"");
          }
       }
    }
 }
",instanceof[edit],code_fragment
1284,"Run the program:
",instanceof[edit],plain_text
1285,"java Test
",instanceof[edit],plain_text
1286,"The output:
",instanceof[edit],plain_text
1287,"""It is a Java Object and It is a Fruit and it is an Apple""
""It is a Java Object and It is a Fruit and it is an Apple""
""It is a Java Object and It is a Fruit and it is an Orange""
""It is a Java Object and It is a Fruit and it is an Orange""
",instanceof[edit],plain_text
1288,"Note that the instanceof operator can also be applied to interfaces. 
For example, if the example above was enhanced with the interface
",instanceof[edit],plain_text
1289,"
",instanceof[edit],plain_text
1290,"interface Edible 
{
 //...
}
",instanceof[edit],code_fragment
1291,"
and the classes modified such that they implemented this interface
",instanceof[edit],plain_text
1292,"
",instanceof[edit],plain_text
1293,"class Orange extends Fruit implements Edible
 {
  ...
 }
",instanceof[edit],code_fragment
1294,"
we could ask if our object were edible.
",instanceof[edit],plain_text
1295,"
",instanceof[edit],plain_text
1296,"if ( obj instanceof Edible )
 {
   System.out.println(""it is edible"");
 }
",instanceof[edit],code_fragment
1297,,int[edit],
1298,"int is a keyword which designates the 32 bit signed integer primitive type.
",int[edit],plain_text
1299,"The java.lang.Integer class is the nominal wrapper class when you need to store an int value but an object reference is required.
",int[edit],plain_text
1300,"Syntax:
",int[edit],plain_text
1301,"int <variable-name> = <integer-value>;
",int[edit],plain_text
1302,"For example:
",int[edit],plain_text
1303,"int i = 65;
",int[edit],code_fragment
1304,"
See also: 
",int[edit],plain_text
1305,Java Programming/Primitive Types,int[edit],plain_text
1306,,interface[edit],
1307,"interface is a Java keyword. It starts the declaration of a Java Interface.
",interface[edit],plain_text
1308,"For example:
",interface[edit],plain_text
1309,"public interface SampleInterface
{
   public void method1();
   //...
}
",interface[edit],code_fragment
1310,"See also: 
",interface[edit],plain_text
1311,Java Programming/Keywords/new,interface[edit],plain_text
1312,,long[edit],
1313,"long is a keyword which designates the 64 bit signed integer primitive type.
",long[edit],plain_text
1314,"The java.lang.Long class is the nominal wrapper class when you need to store a long value but an object reference is required.
",long[edit],plain_text
1315,"Syntax:
",long[edit],plain_text
1316,"long <variable-name> = <integer-value>;
",long[edit],plain_text
1317,"For example:
",long[edit],plain_text
1318,"long timestamp = 1269898201;
",long[edit],code_fragment
1319,"
See also: 
",long[edit],plain_text
1320,Java Programming/Primitive Types,long[edit],plain_text
1321,,native[edit],
1322,"native is a java keyword. It marks a method, that it will be implemented in other languages, not in Java. The method is declared without a body and cannot be abstract. It works together with JNI (Java Native Interface).
",native[edit],plain_text
1323,"Syntax:
",native[edit],plain_text
1324,"[public|protected|private] native method();
",native[edit],plain_text
1325,"Native methods were used in the past to write performance critical sections but with java getting faster this is now less common. Native methods are currently needed when
",native[edit],plain_text
1326,"You need to call from java a library, written in another language.
You need to access system or hardware resources that are only reachable from the other language (typically C). Actually, many system functions that interact with real computer (disk and network IO, for instance) can only do this because they call native code.",native[edit],plain_text
1327,"To complete writing native method, you need to process your class with javah tool that will generate a header code in C. You then need to provide implementation of the header code, produce dynamically loadable library (.so under Linux, .dll under Windows) and load it (in the simplest case with System.load(library_file_name) . The code completion is trivial if only primitive types like integers are passed but gets more complex if it is needed to exchange strings or objects from the C code. In general, everything can be on C level, including creation of the new objects and calling back methods, written in java.
",native[edit],plain_text
1328,"To call the code in some other language (including C++), you need to write a bridge from C to that language. This is usually trivial as most of languages are callable from C.
",native[edit],plain_text
1329,,See also[edit],
1330,"[1] - JNI programming tutorial.
[2] - JNI specification.",See also[edit],plain_text
1331,,new[edit],
1332,"new is a Java keyword. It creates a Java object and allocates memory for it on the heap. new is also used for array creation, as arrays are also objects.
",new[edit],plain_text
1333,"Syntax:
",new[edit],plain_text
1334,"<JavaType> <variable> = new <JavaObject>();
",new[edit],plain_text
1335,"For example:
",new[edit],plain_text
1336,"LinkedList list = new LinkedList();
int[] intArray = new int[10];
String[][] stringMatrix = new String[5][10];
",new[edit],code_fragment
1337,"
See also: 
",new[edit],plain_text
1338,Java Programming/Creating Objects,new[edit],plain_text
1339,,package[edit],
1340,"package is a Java keyword. It declares a 'name space' for the Java class.  It must be put at the top of the Java file, it should be the first Java statement line.
",package[edit],plain_text
1341,"To ensure that the package name will be unique across vendors, usually the company url is used starting in backword.
",package[edit],plain_text
1342,"Syntax:
",package[edit],plain_text
1343,"package package;
",package[edit],plain_text
1344,"For example:
",package[edit],plain_text
1345,"package com.mycompany.myapplication.mymodule;
",package[edit],code_fragment
1346,"
See also: 
",package[edit],plain_text
1347,"Java Programming/Packages
Java Programming/Keywords/import",package[edit],plain_text
1348,,private[edit],
1349,"private is a Java keyword
which declares a member's access
as private. That is, the member is only visible within the class,
not from any other class (including subclasses). The visibility of 
private members extends to nested classes.
",private[edit],plain_text
1350,"Please note: Because access modifiers are not handled at instance level but at class level, private members of an object are visible from other instances of the same class!
",private[edit],plain_text
1351,"
Syntax:
",private[edit],plain_text
1352,"private void method();
",private[edit],plain_text
1353,"See also: 
",private[edit],plain_text
1354,Java Programming/Access Modifiers,private[edit],plain_text
1355,,protected[edit],
1356,"protected is a Java keyword. 
",protected[edit],plain_text
1357,"This keyword is an access modifier, used before a method or other class member to signify that the method or variable can only be accessed by elements residing in its own class or classes in the same package (as it would be for the default visibility level) but moreover from subclasses of its own class, including subclasses in foreign packages (if the access is made on an expression, whose type is the type of this subclass).
",protected[edit],plain_text
1358,"Syntax:
",protected[edit],plain_text
1359,"protected <returnType> <methodName>(<parameters>);
",protected[edit],plain_text
1360,"For example:
",protected[edit],plain_text
1361,"protected int getAge();

protected void setYearOfBirth(int year);
",protected[edit],code_fragment
1362,"
See also: 
",protected[edit],plain_text
1363,Java Programming/Scope#Access modifiers,protected[edit],plain_text
1364,,public[edit],
1365,"public is a Java keyword which declares a member's access as public. Public members are visible to all other classes. This means that any other class can access a public field or method. Further, other classes can modify public fields unless the field is declared as final.
",public[edit],plain_text
1366,"A best practice is to give fields private access and reserve public access to only the set of methods and final fields that define the class' public constants. This helps with encapsulation and information hiding, since it allows you to change the implementation of a class without affecting the consumers who use only the public API of the class.
",public[edit],plain_text
1367,"Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.
",public[edit],plain_text
1368," 1 package org.wikibooks.java;
 2 
 3 public class Length {
 4    private double magnitude;
 5    private String units;
 6 
 7    public Length(double magnitude, String units) {
 8       if ((units == null) || (units.trim().length() == 0)) {
 9           throw new IllegalArgumentException(""non-null, non-empty units required."");
10       }
11 
12       this.magnitude = magnitude;
13       this.units = units;
14    }
15 
16    public double getMagnitude() {
17       return magnitude;
18    }
19 
20    public String getUnits() {
21       return units;
22    }
23 }
",public[edit],code_fragment
1369,,return[edit],
1370,"return is a Java keyword.
",return[edit],plain_text
1371,"Returns a primitive value, or an object reference, or nothing(void).  It does not return object values, only object references.
",return[edit],plain_text
1372,"Syntax:
",return[edit],plain_text
1373,"return variable;  // --- Returns variable
or
return;           // --- Returns nothing
",return[edit],plain_text
1374,,short[edit],
1375,"short is a keyword. It defines a 16 bit signed integer primitive type.
",short[edit],plain_text
1376,"Syntax:
",short[edit],plain_text
1377,"short <variable-name> = <integer-value>;
",short[edit],plain_text
1378,"For example:
",short[edit],plain_text
1379,"short age = 65;
",short[edit],code_fragment
1380,"
See also: 
",short[edit],plain_text
1381,Java Programming/Primitive Types,short[edit],plain_text
1382,,static[edit],
1383,"static is a Java keyword. It can be applied to a field, a method or an inner class. A static field, method or class has a single instance for the whole class that defines it, even if there is no instance of this class in the program. For instance, a Java entry point (main()) has to be static. A static method cannot be abstract. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and before the final keyword:
",static[edit],plain_text
1384,"1 public static final double PI = 3.1415926535;
2 
3 public static void main(final String[] arguments) {
4    //…
5 }
",static[edit],code_fragment
1385,"The static items can be called on an instantiated object or directly on the class:
",static[edit],plain_text
1386,"1 double aNumber = MyClass.PI;
2 MyClass.main(new String[0]);
",static[edit],code_fragment
1387,"Static methods cannot call nonstatic methods. The this current object reference is also not available in static methods.
",static[edit],plain_text
1388,,Interest[edit],
1389,Static variables can be used as data sharing amongst objects of the same class. For example to implement a counter that stores the number of objects created at a given time can be defined as so:,Interest[edit],plain_text
1390," 1 public CountedObject {
 2    private static int counter;
 3    …
 4    public AClass() {
 5       …
 6       counter++;
 7    }
 8    …
 9    public int getNumberOfObjectsCreated() {
10       return counter;
11    }
12 }
",Interest[edit],code_fragment
1391,"The counter variable is incremented each time an object is created.
",Interest[edit],plain_text
1392,"Public static variable should not be used, as these become global variables that can be accessed from everywhere in the program. Global constants can be used, however. See below:
",Interest[edit],plain_text
1393,"1 public static final String CONSTANT_VAR = ""Const"";
",Interest[edit],code_fragment
1394,Static methods can be used for utility functions or for functions that do not belong to any particular object. For example:,Interest[edit],plain_text
1395,"1 public ArithmeticToolbox {
2    …
3    public static int addTwoNumbers(final int firstNumber, final int secondNumber) {
4         return firstNumber + secondNumber;
5    }
6 }
",Interest[edit],code_fragment
1396,,strictfp[edit],
1397,"strictfp is a java keyword, since Java 1.2 .
",strictfp[edit],plain_text
1398,"It makes sure that floating point calculations result precisely the same regardless of the underlying operating system and hardware platform, even if more precision could be obtained.  This is compatible with the earlier version of Java 1.1 .  If you need that use it. 
",strictfp[edit],plain_text
1399,"Syntax for classes:
",strictfp[edit],plain_text
1400,"public strictfp class MyClass 
{ 
  //...
}
",strictfp[edit],plain_text
1401,"Syntax for methods: 
",strictfp[edit],plain_text
1402,"public strictfp void method() 
{ 
  ...
}

",strictfp[edit],plain_text
1403,"See also:
",strictfp[edit],plain_text
1404,http://en.wikipedia.org/wiki/Strictfp,strictfp[edit],plain_text
1405,,super[edit],
1406,"super is a keyword.
",super[edit],plain_text
1407,"It is used inside a sub-class method definition to call a method defined in the super class. Private methods of the super-class cannot be called. Only public and protected methods can be called by the super keyword.
It is also used by class constructors to invoke constructors of its parent class.
Super keyword are not used in static Method.",super[edit],plain_text
1408,"Syntax:
",super[edit],plain_text
1409,"super.<method-name>([zero or more arguments]);
",super[edit],plain_text
1410,"or:
",super[edit],plain_text
1411,"super([zero or more arguments]);
",super[edit],plain_text
1412,"For example:
",super[edit],plain_text
1413,"1 public class SuperClass {
2    public void printHello() {
3       System.out.println(""Hello from SuperClass"");
4       return;
5    }
6 }
",super[edit],code_fragment
1414," 1 public class SubClass extends SuperClass {
 2    public void printHello() {
 3       super.printHello();
 4       System.out.println(""Hello from SubClass"");
 5       return;
 6    }
 7    public static main(String[] args) {
 8       SubClass obj = new SubClass();
 9       obj.printHello();
10    }
11 }
",super[edit],code_fragment
1415,"Running the above program:
",super[edit],plain_text
1416,"In Java 1.5 and later, the ""super"" keyword is also used to specify a lower bound on a wildcard type parameter in Generics.
",super[edit],plain_text
1417,"1 public void sort(Comparator<? super T> comp) {
2   ...
3 }
",super[edit],code_fragment
1418,"See also: 
",super[edit],plain_text
1419,extends,super[edit],plain_text
1420,"
",super[edit],plain_text
1421,,switch[edit],
1422,"switch is a Java keyword.
",switch[edit],plain_text
1423,"It is a branching operation, based on a number. The 'number' must be either char, byte, short, or int primitive type.
",switch[edit],plain_text
1424,"Syntax:
",switch[edit],plain_text
1425,"switch ( <integer-var> )
{
   case <label1>: <statements>;
   case <label2>: <statements>;
   ...
   case <labeln>: <statements>;
   default: <statements>;
}
",switch[edit],plain_text
1426,"When the <integer-var> value match one of the <label>, then:
The statements after the matched label will be executed including the following label's statements, until the end of the switch block, or until a break keyword is reached.
",switch[edit],plain_text
1427,"For example:
",switch[edit],plain_text
1428,"int var = 3;
switch ( var )
{
   case 1: 
      System.out.println( ""Case: 1"" );
      System.out.println( ""Execute until break"" );
      break;		  	
   case 2: 
      System.out.println( ""Case: 2"" );
      System.out.println( ""Execute until break"" );
      break;
   case 3:
      System.out.println( ""Case: 3"" );
      System.out.println( ""Execute until break"" );
      break;  	
   case 4:
      System.out.println( ""Case: 4"" );
      System.out.println( ""Execute until break"" );
      break;      
   default:
      System.out.println( ""Case: default"" );
      System.out.println( ""Execute until break"" );
      break;	      
}
",switch[edit],code_fragment
1429,"The output from the above code is:
",switch[edit],plain_text
1430,"Case: 3
Execute until break
",switch[edit],plain_text
1431,"The same code can be written with if-else blocks"":
",switch[edit],plain_text
1432,"int var = 3;
if ( var == 1 ) {
   System.out.println( ""Case: 1"" );
   System.out.println( ""Execute until break"" );
} else if ( var == 2 ) {
   System.out.println( ""Case: 2"" );
   System.out.println( ""Execute until break"" );
} else if ( var == 3 ) {
   System.out.println( ""Case: 3"" );
   System.out.println( ""Execute until break"" );
} else if ( var == 4 ) {
   System.out.println( ""Case: 4"" );
   System.out.println( ""Execute until break"" );
} else {
   // -- This is the default part -- 
   System.out.println( ""Case: default"" );
   System.out.println( ""Execute until break"" );
}
",switch[edit],code_fragment
1433,"
See also: 
",switch[edit],plain_text
1434,Java Programming/Keywords/if,switch[edit],plain_text
1435,,synchronized[edit],
1436,"synchronized is a keyword.
",synchronized[edit],plain_text
1437,"It marks a critical section.  A critical section is where one and only one thread is executing.  So to enter into the marked code the threads are synchronized, only one can enter, the others have to wait. For more information see Synchronizing Threads Methods or [3].
",synchronized[edit],plain_text
1438,"The synchronized keyword can be used in two ways:
",synchronized[edit],plain_text
1439,"Create a synchronized block
Mark a method synchronized",synchronized[edit],plain_text
1440,"A synchronized block is marked as:
",synchronized[edit],plain_text
1441,"1 synchronized(<object_reference>) {
2    // Thread.currentThread() has a lock on object_reference. All other threads trying to access it will
3    // be blocked until the current thread releases the lock.
4 }
",synchronized[edit],code_fragment
1442,"The syntax to mark a method synchronized is:
",synchronized[edit],plain_text
1443,"1 public synchronized void method() {
2    // Thread.currentThread() has a lock on this object, i.e. a synchronized method is the same as
3    // calling { synchronized(this) {…} }.
4 }
",synchronized[edit],code_fragment
1444,"The synchronization is always associated to an object. If the method is static, the associated object is the class. If the method is non-static, the associated object is the instance. While it is allowed to declare an abstract method as synchronized, it is meaningless to do so since synchronization is an aspect of the implementation, not the declaration, and abstract methods do not have an implementation.
",synchronized[edit],plain_text
1445,,Singleton example[edit],
1446,"As an example, we can show a thread-safe version of a singleton:
",Singleton example[edit],plain_text
1447," 1 /**
 2  * The singleton class that can be instantiated only once with lazy instantiation
 3  */
 4 public class Singleton {
 5     /** Static class instance */
 6     private volatile static Singleton instance = null;
 7 
 8     /**
 9      * Standard private constructor
10      */
11     private Singleton() {
12         // Some initialisation
13     }
14    
15     /**
16      * Getter of the singleton instance
17      * @return The only instance
18      */
19     public static Singleton getInstance() {
20         if (instance == null) {
21             // If the instance does not exist, go in time-consuming
22             // section:
23             synchronized (Singleton.class) {
24                 if (instance == null) {
25                     instance = new Singleton();
26                 }
27             }
28         }
29 
30         return instance;
31     }
32  }
",Singleton example[edit],code_fragment
1448,,this[edit],
1449,"this is a Java keyword. It contains the current object reference.
",this[edit],plain_text
1450,"Syntax:
",this[edit],plain_text
1451,"this.method();
or
this.variable;

",this[edit],plain_text
1452,"Example #1 for case 1:
",this[edit],plain_text
1453,"public class MyClass
 { 
    //...
    private String value;
    //...
    public void setMemberVar( String value )
    {
        this.value= value;
    }
 }
",this[edit],code_fragment
1454,"Example #2 for case 1:
",this[edit],plain_text
1455,"public class MyClass
 { 
    MyClass(int a, int b) {
        System.out.println(""int a: "" + a);
        System.out.println(""int b: "" + b);
    }
    MyClass(int a) {
        this(a, 0);
    }
    //...
    public static void main(String[] args) {
        new MyClass(1, 2);
        new MyClass(5);
    }
 }
",this[edit],code_fragment
1456,,throw[edit],
1457,"throw is a keyword; it 'throws' an exception. In a throw statement, the three types of objects that can be thrown are: Exception, java:Throwable, and java:Error
",throw[edit],plain_text
1458,"Syntax:
",throw[edit],plain_text
1459,"throw <Exception Ref>;
",throw[edit],plain_text
1460,"For example:
",throw[edit],plain_text
1461,"public Customer findCustomer( String name ) throws '''CustomerNotFoundException'''
 {
    Customer custRet = null;
 
    Iterator iter = _customerList.iterator();
    while ( iter.hasNext() )
    {
        Customer cust = (Customer) iter.next();
        if ( cust.getName().equals( name ) )
        {
           // --- Customer find --
           custRet = cust;
           break;
        }
     }
     if ( custRet == null )
     {
        // --- Customer not found ---
        throw new '''CustomerNotFoundException'''( ""Customer ""+ name + "" was not found"" );
     }
 
    return custRet
  }
",throw[edit],code_fragment
1462,"
",throw[edit],plain_text
1463,,See also[edit],
1464,Java Programming/Keywords/throws,See also[edit],plain_text
1465,,throws[edit],
1466,"throws is a Java keyword. It is used in a method definition to declare the Exceptions to be thrown by the method. 
",throws[edit],plain_text
1467,"Syntax:
",throws[edit],plain_text
1468,"public myMethod() throws MyException1, MyException2
{MyException1
  ...
}
",throws[edit],plain_text
1469,"Example:
",throws[edit],plain_text
1470,"class MyDefinedException extends Exception
 {
  public MyDefinedException(String str) 
  {
     super(str);
  }   
 }

 public class MyClass
 {
    public static void showMyName(String str) throws MyDefinedException
    {
          if(str.equals(""What is your Name?""))
                throw new MyDefinedException(""My name is Blah Blah"");
    }
    public static void main(String a[])
    {
       try
       {
          showMyName(""What is your Name?"");
       }
       catch(MyDefinedException mde)
       {
          mde.printStackTrace();
       }
     }
 }
",throws[edit],code_fragment
1471,,transient[edit],
1472,"transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes.  When an object is transferred through the network, the object needs to be 'serialized'.  Serialization converts the object state to serial bytes. Those bytes are sent over the network and the object is recreated from those bytes.  Member variables marked by the java transient keyword are not transferred; they are lost intentionally.
",transient[edit],plain_text
1473,"Syntax:
",transient[edit],plain_text
1474,"private transient <member-variable>;
or 
transient private <member-variable>;
",transient[edit],plain_text
1475,"
For example:
",transient[edit],plain_text
1476,"public class Foo implements Serializable
 {
   private String saveMe;
   private transient String dontSaveMe;
   private transient String password;
   //...
 }
",transient[edit],code_fragment
1477,"See also: 
",transient[edit],plain_text
1478,"Java language specification reference: jls
Serializable Interface. Serializable",transient[edit],plain_text
1479,,try[edit],
1480,"try is a keyword.
",try[edit],plain_text
1481,"It starts a try block. If an Exception is thrown inside a try block, the Exception will be compared to any of the catch part of the block. If the Exception matches with one of the Exceptions in the catch part, the exception will be handled there.
",try[edit],plain_text
1482,"Three things can happen in a try block:
",try[edit],plain_text
1483,"No exception is thrown:
the code in the try block
plus the code in the finally block will be executed
plus the code after the try-catch block is executed
An exception is thrown and a match is found among the catch blocks:
the code in the try block until the exception occurred is executed
plus the matched catch block is executed
plus the finally block is executed
plus the code after the try-catch block is executed
An exception is thrown and no match found among the catch blocks:
the code in the try block until the exception occurred is executed
plus the finally block is executed
NO CODE after the try-catch block is executed",try[edit],plain_text
1484,"For example:
",try[edit],plain_text
1485,"public void method() throws NoMatchedException
 {
   try {
     //...
     throw new '''MyException_1'''();
     //...
   } catch ( MyException_1 e ) {
     // --- '''Handle the Exception_1 here''' --
   } catch ( MyException_2 e ) {
     // --- Handle the Exception_2 here --
   } finally {
     // --- This will always be executed no matter what --
   }
   // --- Code after the try-catch block
 }
",try[edit],code_fragment
1486,"How the catch-blocks are evaluated see Catching Rule
",try[edit],plain_text
1487,"See also: 
",try[edit],plain_text
1488,"Java Programming/Keywords/catch
Java Programming/Keywords/finally
Java Programming/Throwing and Catching Exceptions#Catching Rule",try[edit],plain_text
1489,,void[edit],
1490,"void is a Java keyword.
",void[edit],plain_text
1491,"Used at method declaration and definition to specify that the method does not return any type, the method returns void. It is not a type and there is no void references/pointers as in C/C++.
",void[edit],plain_text
1492,"For example:
",void[edit],plain_text
1493,"public void method()
 {
   //...
   return;   // -- In this case the return is optional
 }
",void[edit],code_fragment
1494,"See also: 
",void[edit],plain_text
1495,Java Programming/Keywords/return,void[edit],plain_text
1496,,volatile[edit],
1497,"volatile is a keyword.
",volatile[edit],plain_text
1498,"When member variables are marked with this keyword, it changes the runtime behavior in a way that is noticeable when multiple threads access these variables. Without the volatile keyword, one thread could observe another thread update member variables in an order that is not consistent with what is specified in sourcecode. Unlike the synchronized keyword, concurrent access to a volatile field is allowed.
",volatile[edit],plain_text
1499,"Syntax:
",volatile[edit],plain_text
1500,"private volatile <member-variable>;
or 
volatile private <member-variable>;
",volatile[edit],plain_text
1501,"
For example:
",volatile[edit],plain_text
1502,"private volatile changingVar;
",volatile[edit],code_fragment
1503,"
See also: 
",volatile[edit],plain_text
1504,Java Programming/Keywords/synchronized,volatile[edit],plain_text
1505,,while[edit],
1506,"while is a Java keyword.
",while[edit],plain_text
1507,"It starts a looping block.
",while[edit],plain_text
1508,"The general syntax of a while, using Extended Backus-Naur Form, is
",while[edit],plain_text
1509,"while-looping-statement ::= while condition-clause 
                                    single-statement | block-statement
 
condition-clause    ::= ( Boolean Expression )
single-statement    ::= Statement
block-statement     ::= { Statement [ Statements ] }
",while[edit],plain_text
1510,"For example:
",while[edit],plain_text
1511,"while ( i < maxLoopIter )
 {
    System.println(""Iter="" +i++);
 }
",while[edit],code_fragment
1512,"See also: 
",while[edit],plain_text
1513,"Java Programming/Statements
Java Programming/Keywords/for
Java Programming/Keywords/do",while[edit],plain_text
1514,"
",while[edit],plain_text
1515,"
The Java code conventions are defined by Oracle in the coding conventions document. In short, these conventions ask the user to use camel case when defining classes, methods, or variables. Classes start with a capital letter and should be nouns, like CalendarDialogView. For methods, the names should be verbs in imperative form, like getBrakeSystemType, and should start with a lowercase letter.
",Coding conventions,plain_text
1516,"It is important to get used to and follow coding conventions, so that code written by multiple programmers will appear the same. Projects may re-define the standard code conventions to better fit their needs. Examples include a list of allowed abbreviations, as these can often make the code difficult to understand for other designers. Documentation should always accompany code.
",Coding conventions,plain_text
1517,"One example from the coding conventions is how to define a constant. Constants should be written with capital letters in Java, where the words are separated by an underscore ('_') character. In the Java coding conventions, a constant is a static final field in a class.
",Coding conventions,plain_text
1518,"The reason for this diversion is that Java is not 100% object-oriented and discerns between ""simple"" and ""complex"" types. These will be handled in detail in the following sections. An example for a simple type is the byte type. An example for a complex type is a class. A subset of the complex types are classes that cannot be modified after creation, like a String, which is a concatenation of characters.
",Coding conventions,plain_text
1519,"For instance, consider the following ""constants"":
",Coding conventions,plain_text
1520,"
",Coding conventions,plain_text
1521,,Fundamentals[edit],
1522,"Every class in Java can be composed of the following elements:
",Fundamentals[edit],plain_text
1523,"fields, member variables or instance variables — Fields are variables that hold data specific to each object.  For example, an employee might have an ID number. There is one field for each object of a class.
member methods or instance methods — Member methods perform operations on an object.  For example, an employee might have a method to issue his paycheck or to access his name.
static fields or class fields — Static fields are common to any object of the same class.  For example, a static field within the Employee class could keep track of the last ID number issued. Each static field exists only once in the class, regardless of how many objects are created for that class.
static methods or class methods — Static methods are methods that do not affect a specific object.
inner classes — Sometimes it is useful to contain a class within another one if it is useless outside of the class or should not be accessed outside the class.
Constructors — A special method that generates a new object.
Parameterized types — Since 1.5, parameterized types can be assigned to a class during definition.  The parameterized types will be substituted with the types specified at the class's instantiation. It is done by the compiler. It is similar to the C language macro '#define' statement, where a preprocessor evaluates the macros.",Fundamentals[edit],plain_text
1524," 1 public class Employee {              // This defines the Employee class.
 2                                      // The public modifier indicates that
 3                                      // it can be accessed by any other class
 4 
 5     private static int nextID;       // Define a static field. Only one copy of this will exist,
 6                                      // no matter how many Employees are created.
 7 
 8     private int myID;                // Define fields that will be stored  
 9     private String myName;           // for each Employee. The private modifier indicates that
10                                      // only code inside the Employee class can access it.
11  
12     public Employee(String name) {   // This is a constructor. You can pass a name to the constructor
13                                      // and it will give you a newly created Employee object.
14         myName = name;
15         myID = nextID;               // Automatically assign an ID to the object
16         nextID++;                    // Increment the ID counter
17     }
18  
19     public String getName() {        // This is a member method that returns the
20                                      // Employee object's name.
21         return myName;               // Note how it can access the private field myName.
22     }
23  
24     public int getID() {             // This is another member method.
25    
26         return myID;  
27     }
28  
29     public static int getNextID() {  // This is a static method that returns the next ID
30                                      // that will be assigned if another Employee is created.
31         return nextID;
32     }
33 }
",Fundamentals[edit],code_fragment
1525,"The following Java code would produce this output:
",Fundamentals[edit],plain_text
1526," 1 public class EmployeeList {
 2     public static void main(String[] args) {
 3 
 4         System.out.println(Employee.getNextID());
 5  
 6         Employee a = new Employee(""John Doe"");
 7         Employee b = new Employee(""Jane Smith"");
 8         Employee c = new Employee(""Sally Brown"");
 9  
10         System.out.println(Employee.getNextID());
11  
12         System.out.println(a.getID() + "": "" + a.getName());
13         System.out.println(b.getID() + "": "" + b.getName());
14         System.out.println(c.getID() + "": "" + c.getName());
15     }
16 }
",Fundamentals[edit],code_fragment
1527,,Constructors[edit],
1528,"A constructor is called to initialize an object immediately after the object has been allocated:
",Constructors[edit],plain_text
1529,"1 public class Cheese {
2   // This is a constructor
3   public Cheese() {
4     System.out.println(""Construct an instance"");
5   }
6 }
",Constructors[edit],code_fragment
1530,"Typically, a constructor is invoked using the new keyword:
",Constructors[edit],plain_text
1531,"1 Cheese cheese = new Cheese();
",Constructors[edit],code_fragment
1532,"The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:
",Constructors[edit],plain_text
1533,"1 public class Cheese {
2   // This is a method with the same name as the class
3   public void Cheese() {
4     System.out.println(""A method execution."");
5   }
6 }
",Constructors[edit],code_fragment
1534,"The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be abstract, final, native, static, strictfp nor synchronized. However, a constructor, like methods, can be overloaded and take parameters.
",Constructors[edit],plain_text
1535," 1 public class Cheese {
 2      // This is a constructor
 3      public Cheese() {
 4           doStuff();
 5      }
 6 
 7      // This is another constructor
 8      public Cheese(int weight) {
 9           doStuff();
10      }
11 
12      // This is yet another constructor
13      public Cheese(String type, int weight) {
14           doStuff();
15      }
16 }
",Constructors[edit],code_fragment
1536,"By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:
",Constructors[edit],plain_text
1537,"1 public class Cheese {
2      public Cheese() {
3            super();
4      }
5 }
",Constructors[edit],code_fragment
1538,"The super() command calls the constructor of the superclass. If there is no explicit call to super(...) or this(...), then the default superclass constructor super(); is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The code listing 4.8 results in a runtime error:
",Constructors[edit],plain_text
1539,"1 public class Cheese {
2      public Cheese(int weight, String type) {
3           doStuff();
4      }
5 }
",Constructors[edit],code_fragment
1540,"1 public class Mouse {
2      public void eatCheese() {
3              Cheese c = new Cheese(); // Oops, compile time error!
4      }
5 }
",Constructors[edit],code_fragment
1541,"This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.
",Constructors[edit],plain_text
1542,,Initializers[edit],
1543,"Initializers are blocks of code that are executed at the same time as initializers for fields.
",Initializers[edit],plain_text
1544,"Static initializers are blocks of code that are executed at the same time as initializers for static fields.  Static field initializers and static initializers are executed in the order declared.  The static initialization is executed after the class is loaded.
",Initializers[edit],plain_text
1545,"1 static int count = 20;
2 static int[] squares;
3 static {  // a static initializer
4     squares = new int[count];
5     for (int i = 0; i < count; i++)
6         squares[i] = i * i;
7 }
8 static int x = squares[5];  // x is assigned the value 25
",Initializers[edit],code_fragment
1546,"Instance initializers are blocks of code that are executed at the same time as initializers for instance (non-static) fields.  Instance field initializers and instance initializers are executed in the order declared. Both instance initializers and instance field initializers are executed during the invocation of a constructor.  The initializers are executed immediately after the superclass constructor and before the body of the constructor.
",Initializers[edit],plain_text
1547,"
",Initializers[edit],plain_text
1548,"Inheritance is one of the most powerful mechanisms of the Object Oriented Programming. It allows the reuse of the members of a class (called the superclass or the mother class) in another class (called subclass, child class or the derived class) that inherits from it. This way, classes can be built by successive inheritance.
",Inheritance,plain_text
1549,"In Java, this mechanism is enabled by the extends keyword.
Example:
",Inheritance,plain_text
1550,"1 public class Vehicle {
2     public int speed;
3     public int numberOfSeats;
4 }
",Inheritance,code_fragment
1551,"1 public class Car extends Vehicle {
2     public Car() {
3         this.speed = 90;
4         this.numberOfSeats = 5;
5     }
6 }
",Inheritance,code_fragment
1552,"In the Code listing 4.10, the class Car inherits from Vehicle, which means that the attributes speed and numberOfSeats are present in the class Car, whereas they are defined in the class Vehicle. Also, the constructor defined in the class Car allows to initialize those attributes.
In Java, the inheritance mechanism allows to define a class hierarchy with all the classes. Without explicit inheritance, a class implicitly inherits from the Object class. This Object class is the root of the class hierarchy.
",Inheritance,plain_text
1553,"Some classes can't be inherited. Those classes are defined with the final keyword. For instance, the Integer class can't have subclasses. It is called a final class.
",Inheritance,plain_text
1554,,The Object class[edit],
1555,"At the instantiating, the child class receives the features inherited from its superclass, which also has received the features inherited from its own superclass and so on to the Object class.
This mechanism allows to define reusable global classes, whose user details the behavior in the derived more specific classes.
",The Object class[edit],plain_text
1556,"In Java, a class can only inherit from one class. Java does not allow you to create a subclass from two classes, as that would require creating complicated rules to disambiguate fields and methods inherited from multiple superclasses.  If there is a need for Java to inherit from multiple sources, the best option is through interfaces, described in the next chapter.
",The Object class[edit],plain_text
1557,,The super keyword[edit],
1558,"The super keyword allows access to the members of the superclass of a class, as you can use this to access the members of the current class.
Example:
",The super keyword[edit],plain_text
1559,"1 public class Plane extends Vehicle {
2     public Plane() {
3         super();
4     }
5 }
",The super keyword[edit],code_fragment
1560,"In this example, the constructor of the Plane class calls the constructor of its superclass Vehicle. You can only use super to access the members of the superclass inside the child class. If you use it from another class, it accesses the superclass of the other class.
This keyword also allows you to explicitly access the members of the superclass, for instance, in the case where there is a method with the same name in your class (overriding, ...).
Example :
",The super keyword[edit],plain_text
1561,"1 public class Vehicle {
2     // ...
3     public void run() throws Exception {
4         position += speed;
5     }
6 }
",The super keyword[edit],code_fragment
1562," 1 public class Plane extends Vehicle {
 2     // ...
 3     public void run() throws Exception {
 4         if (0 < height) {
 5            throw new Exception(""A plane can't run in flight."");
 6         } else {
 7            super.run();
 8         }
 9     }
10 }
",The super keyword[edit],code_fragment
1563,"1 public class Class1 {
2     public static final int CONSTANT_OF_CLASS_1 = 9;
3     public int myAttributeOfClass1 = 40;
4     public void myMethodOfClass1(int i) {
5     }
6 }
",The super keyword[edit],code_fragment
1564,"An interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:
",Interfaces,plain_text
1565,"A field is always a constant: it is always public, static and final, even if you do not mention it.
A method must be public and abstract, but it is not required to write the public and abstract keywords.
Constructors are forbidden.",Interfaces,plain_text
1566,"An interface represents a contract:
",Interfaces,plain_text
1567,"1 public interface SimpleInterface {
2     public static final int CONSTANT1 = 1;
3     int method1(String parameter);
4 }
",Interfaces,code_fragment
1568,"You can see that the method1() method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the implements keyword:
",Interfaces,plain_text
1569,"1 public class ClassWithInterface implements SimpleInterface {
2     int method1(String parameter) {
3         return 0;
4     }
5 }
",Interfaces,code_fragment
1570,"A class can implement several interface, separated by a comma. Java interfaces behave much like the concept of the Objective-C protocol. It is recommended to name an interface <verb>able, to mean the type of action this interface would enable on a class. However, it is not recommended to start the name of an interface by I as in C++. It is useless. Your IDE will help you instead.
",Interfaces,plain_text
1571,,Interest[edit],
1572,"If you have objects from different classes that do not have a common superclass, you can't call the same method in those classes, even if the two classes implement a method with the same signature.
",Interest[edit],plain_text
1573,"1 public class OneClass {
2     public int method1(String parameter) {
3         return 1;
4     }
5 }
",Interest[edit],code_fragment
1574,"1 public class AnotherClass {
2     public int method1(String parameter) {
3         return 2;
4     }
5 }
",Interest[edit],code_fragment
1575,"1 public static void main(String[] args) {
2     doAction(new OneClass());
3     doAction(new AnotherClass());
4 }
5 
6 public void doAction(Object anObject) {
7     anObject.method1(""Hello!"");
8 }
",Interest[edit],code_fragment
1576,"The solution is to write an interface that defines the method that should be implemented in the two classes as the SimpleInterface in the Code listing 4.14 and then the both classes can implement the interface as in the Code listing 4.15.
",Interest[edit],plain_text
1577,"1 public static void main(String[] args) {
2     doAction(new ClassWithInterface());
3     doAction(new AnotherClassWithInterface());
4 }
5 
6 public void doAction(SimpleInterface anObject) {
7     anObject.method1(""Hello!"");
8 }
",Interest[edit],code_fragment
1578,"You can also implement this using a common super class but a class can only inherit from one super class whereas it can implement several interfaces.
",Interest[edit],plain_text
1579,"Java does not support full orthogonal multiple inheritance (i.e. Java does not allow you to create a subclass from two classes). Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types that are inherited multiple times.  By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity.  The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor (a class called Object).
",Interest[edit],plain_text
1580,"When overriding methods defined in interfaces there are several rules to be followed:
",Interest[edit],plain_text
1581,"Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.
The signature of the interface method and the same return type or subtype should be maintained when implementing the methods.
All the methods of the interface need to be defined in the class, unless the class that implements the interface is abstract.",Interest[edit],plain_text
1582,,Extending interfaces[edit],
1583,"An interface can extend several interfaces, similar to the way that a class can extend another class, using the extends keyword:
",Extending interfaces[edit],plain_text
1584,"1 public interface InterfaceA {
2   public void methodA();
3 }
",Extending interfaces[edit],code_fragment
1585,"1 public interface InterfaceB {
2   public void methodB();
3 }
",Extending interfaces[edit],code_fragment
1586,"1 public interface InterfaceAB extends InterfaceA, InterfaceB {
2   public void otherMethod();
3 }
",Extending interfaces[edit],code_fragment
1587,"This way, a class implementing the InterfaceAB interface has to implement the methodA(), the methodB() and the otherMethod() methods:
",Extending interfaces[edit],plain_text
1588," 1 public class ClassAB implements InterfaceAB {
 2   public void methodA() {
 3     System.out.println(""A"");
 4   }
 5 
 6   public void methodB() {
 7     System.out.println(""B"");
 8   }
 9 
10   public void otherMethod() {
11     System.out.println(""foo"");
12   }
13 
14   public static void main(String[] args) {
15     ClassAB classAb = new ClassAB();
16     classAb.methodA();
17     classAb.methodB();
18     classAb.otherMethod();
19   }
20 }
",Extending interfaces[edit],code_fragment
1589,"Doing so, a ClassAB object can be casted into InterfaceA, InterfaceB and InterfaceAB.
",Extending interfaces[edit],plain_text
1590,"1 public interface Walkable {
2     void walk();
3 }
",Extending interfaces[edit],code_fragment
1591,,Method overloading[edit],
1592,"In a class, there can be several methods with the same name. However they must have a different signature. The signature of a method is comprised of its name, its parameter types and the order of its parameters. The signature of a method is not comprised of its return type nor its visibility nor the exceptions it may throw.
The practice of defining two or more methods within the same class that share the same name but have different parameters is called overloading methods.  
",Method overloading[edit],plain_text
1593,"Methods with the same name in a class are called overloaded methods. Overloading methods offers no specific benefit to the JVM but it is useful to the programmer to have several methods do the same things but with different parameters. For example, we may have the operation runAroundThe represented as two methods with the same name, but different input parameter types:
",Method overloading[edit],plain_text
1594,"1 public void runAroundThe(Building block) {
2   ...
3 }
4 
5 public void runAroundThe(Park park) {
6   ...
7 }
",Method overloading[edit],code_fragment
1595,"One type can be the subclass of the other:
",Method overloading[edit],plain_text
1596," 1 public class ClassName {
 2 
 3   public static void sayClassName(Object aObject) {
 4     System.out.println(""Object"");
 5   }
 6 
 7   public static void sayClassName(String aString) {
 8     System.out.println(""String"");
 9   }
10 
11   public static void main(String[] args) {
12     String aString = new String();
13     sayClassName(aString);
14 
15     Object aObject = new String();
16     sayClassName(aObject);
17   }
18 }
",Method overloading[edit],code_fragment
1597,"Although both methods would be fit to call the method with the String parameter, it is the method with the nearest type that will be called instead. To be more accurate, it will call the method whose parameter type is a subclass of the parameter type of the other method. So, aObject will output Object. Beware! The parameter type is defined by the declared type of an object, not its instantiated type!
",Method overloading[edit],plain_text
1598,"The following two method definitions are valid
",Method overloading[edit],plain_text
1599,"1 public void logIt(String param, Error err) {
2   ...
3 }
4 
5 public void logIt(Error err, String param) {
6   ...
7 }
",Method overloading[edit],code_fragment
1600,"because the type order is different. If both input parameters were type String, that would be a problem since the compiler would not be able to distinguish between the two:
",Method overloading[edit],plain_text
1601,"1 public void logIt(String param, String err) {
2   ...
3 }
4 
5 public void logIt(String err, String param) {
6   ...
7 }
",Method overloading[edit],code_fragment
1602,"The compiler would give an error for the following method definitions as well:
",Method overloading[edit],plain_text
1603,"1 public void logIt(String param) {
2   ...
3 }
4 
5 public String logIt(String param) {
6   String retValue;
7   ...
8   return retValue;
9 }
",Method overloading[edit],code_fragment
1604,"Note, the return type is not part of the unique signature.  Why not?  The reason is that a method can be called without assigning its return value to a variable.  This feature came from C and C++. So for the call:
",Method overloading[edit],plain_text
1605,"1 logIt(msg);
",Method overloading[edit],code_fragment
1606,"the compiler would not know which method to call. It is also the case for the thrown exceptions.
",Method overloading[edit],plain_text
1607," 1 public class Question6 {
 2  
 3   public void example1() {
 4   }
 5 
 6   public int example1() {
 7   }
 8 
 9   public void example2(int x) {
10   }
11 
12   public void example2(int y) {
13   }
14 
15   private void example3() {
16   }
17 
18   public void example3() {
19   }
20 
21   public String example4(int x) {
22     return null;
23   }
24 
25   public String example4() {
26     return null;
27   }
28 }
",Method overloading[edit],code_fragment
1608,,Variable Argument[edit],
1609,"Instead of overloading, you can use a dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding ... after its type. The dynamic arguments will be received as an array:
",Variable Argument[edit],plain_text
1610," 1   public void registerPersonInAgenda(String firstName, String lastName, Date... meeting) {
 2     String[] person = {firstName, lastName};
 3     lastPosition = lastPosition + 1;
 4     contactArray[lastPosition] = person;
 5 
 6     if (meeting.length > 0) {
 7       Date[] temporaryMeetings = registeredMeetings.length + meeting.length;
 8       for (i = 0; i < registeredMeetings.length; i++) {
 9         temporaryMeetings[i] = registeredMeetings[i];
10       }
11       for (i = 0; i < meeting.length; i++) {
12         temporaryMeetings[registeredMeetings.length + i] = meeting[i];
13       }
14       registeredMeetings = temporaryMeetings;
15     }
16   }
",Variable Argument[edit],code_fragment
1611,"The above method can be called with a dynamic number of arguments, for example:
",Variable Argument[edit],plain_text
1612,"1 registerPersonInAgenda(""John"", ""Doe"");
2 registerPersonInAgenda(""Mark"", ""Lee"", new Date(), new Date());
",Variable Argument[edit],code_fragment
1613,"This feature was not available before Java 1.5 .
",Variable Argument[edit],plain_text
1614,,Constructor overloading[edit],
1615,"The constructor can be overloaded. You can define more than one constructor with different parameters. For example:
",Constructor overloading[edit],plain_text
1616," 1 public class MyClass {
 2 
 3   private String memberField;
 4  
 5   /**
 6    * MyClass Constructor, there is no input parameter
 7    */
 8   public MyClass() {
 9      ...
10   }
11  
12   /**
13    * MyClass Constructor, there is one input parameter
14    */
15    public MyClass(String param1) {
16      memberField = param1;
17      ...
18   }
19 }
",Constructor overloading[edit],code_fragment
1617,"In the code listing 4.12, we defined two constructors, one with no input parameter, and one with one input parameter. You may ask which constructor will be called.  Its depends how the object is created with the new keyword. See below:
",Constructor overloading[edit],plain_text
1618,"1 // The constructor with no input parameter will be called
2 MyClass obj1 = new MyClass();
3 
4 // The constructor with one input param. will be called
5 MyClass obj2 = new MyClass(""Init Value"");
",Constructor overloading[edit],code_fragment
1619,"In the code section 4.29, we created two objects from the same class, or we can also say that obj1 and obj2 both have the same type. The difference between the two is that in the first one the memberField field is not initialized, in the second one that is initialized to ""Init Value"". A constructor may also be called from another constructor, see below:
",Constructor overloading[edit],plain_text
1620," 1 public class MyClass {
 2 
 3   private String memberField;
 4  
 5   /**
 6    * MyClass Constructor, there is no input parameter
 7    */
 8   public MyClass() {
 9     MyClass(""Default Value"");
10   }
11  
12   /**
13    * MyClass Constructor, there is one input parameter
14    */
15   public MyClass(String param1) {
16     memberField = param1;
17     ...
18   }
19 }
",Constructor overloading[edit],code_fragment
1621,"In the code listing 4.13, the constructor with no input parameter calls the other constructor with the default initial value. This call must be the first instruction of a constructor or else a compiler error will occur. The code gives an option to the user, to create the object with the default value or create the object with a specified value. The first constructor could have been written using the this keyword as well:
",Constructor overloading[edit],plain_text
1622,"1   public MyClass() {
2     this(""Default Value"");
3   }
",Constructor overloading[edit],code_fragment
1623,"Such a call reduces the code repetition.
",Constructor overloading[edit],plain_text
1624,,Method overriding[edit],
1625,"To easily remember what can be done in method overriding, keep in mind that all you can do in an object of a class, you can also do in an object of a subclass, only the behavior can change. A subclass should be covariant.
",Method overriding[edit],plain_text
1626,"Although a method signature has to be unique inside a class, the same method signature can be defined in different classes.  If we define a method that exists in the super class then we override the super class method.  It is called method overriding.  This is different from method overloading. Method overloading happens with methods with the same name but different signature.  Method overriding happens with methods with the same name and same signature between inherited classes.
",Method overriding[edit],plain_text
1627,"The return type can cause the same problem we saw above.  When we override a super class method the return type also must be the same.  If that is not the same, the compiler will give you an error.
",Method overriding[edit],plain_text
1628,"Beware! If a class declares two public methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.
",Method overriding[edit],plain_text
1629,"Method overriding is related to dynamic linking, or runtime binding. In order for the Method Overriding to work, the method call that is going to be called can not be determined at compilation time. It will be decided at runtime, and will be looked up in a table.
",Method overriding[edit],plain_text
1630," 1 MyClass obj;
 2 
 3 if (new java.util.Calendar().get(java.util.Calendar.AM_PM) == java.util.Calendar.AM) {
 4   // Executed during a morning
 5   obj = new SubOfMyClass();
 6 } else {
 7   // Executed during an afternoon
 8   obj = new MyClass();
 9 }
10  
11 obj.myMethod();
",Method overriding[edit],code_fragment
1631,"In the code section 4.31, the expression at line 3 is true if it is executed during a morning and false if it is executed during an afternoon. Thus, the instance of obj will be a MyClass or a SubOfMyClass depending on the execution time. So it is impossible to determine the method address at compile time. Because the obj reference can point to an object and all its sub objects, and that will be known only at runtime, a table is kept with all the possible method addresses to be called. Do not confuse:
",Method overriding[edit],plain_text
1632,"1 obj.myMethod(myParameter);
",Method overriding[edit],code_fragment
1633,"The implementation of this method is searched using the instantiated type of the called object (obj) and the declared type of the parameter object (myParameter).
",Method overriding[edit],plain_text
1634,"Also another rule is that when you do an override, the visibility of the new method that overrides the super class method can not be reduced.  The visibility can be increased, however.  So if the super class method visibility is public, the override method can not be package, or private. An override method must throw the same exceptions as the super class, or their subexceptions.
",Method overriding[edit],plain_text
1635,"super references to the parent class (i.e. super.someMethod()). It can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.
",Method overriding[edit],plain_text
1636,"Before a Java object can be created the class byte code must be loaded from the file system (with .class extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java class instance is known as class loading. There is one class created for each type of Java class.
",Object Lifecycle,plain_text
1637,"All objects in Java programs are created on heap memory.  An object is created based on its class.  You can consider a class as a blueprint, template, or a description how to create an object.  When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.
",Object Lifecycle,plain_text
1638,"The Java Virtual Machine (JVM) keeps track of the usage of object references.  If there are no more reference to the object, the object can not be used any more and becomes garbage.  After a while the heap memory  will be full of  unused objects.  The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created.  See below a simple example:
",Object Lifecycle,plain_text
1639,"1 {
2   // Create an object
3   MyObject obj = new MyObject();
4 
5   // Use the object
6   obj.printMyValues();
7 }
",Object Lifecycle,code_fragment
1640,"The obj variable contains the object reference pointing to an object created from the MyObject class. The obj object reference is in scope inside the { }.  After the } the object becomes garbage.  Object references can be passed in to methods and can be returned from methods.
",Object Lifecycle,plain_text
1641,,Creating object with the new keyword[edit],
1642,"99% of new objects are created using the new keyword.
",Creating object with the new keyword[edit],plain_text
1643,"1 public class MyProgram {
2 
3   public static void main(String[] args) {
4     // Create an 'MyObject' for the first time the application started
5     MyObject obj = new MyObject();
6   }
7 }
",Creating object with the new keyword[edit],code_fragment
1644,"When an object from the MyObject class is created for the first time, the JVM searches the file system for the definition of the class, that is the Java byte code. The file has the extension of *.class.  The CLASSPATH environment variable contains locations where Java classes are stored.  The JVM is looking for the MyObject.class file. Depending on which package the class belongs to, the package name will be translated to a directory path.
",Creating object with the new keyword[edit],plain_text
1645,"When the MyObject.class file is found, the JVM's class loader loads the class in memory, and creates a java.lang.Class object. The JVM stores the code in memory, allocates memory for the static variables, and executes any static initialize block.  Memory is not allocated for the object member variables at this point, memory will be allocated for them when an instance of the class, an object, is created.
",Creating object with the new keyword[edit],plain_text
1646,"There is no limit on how many objects from the same class can be created.  Code and static variables are stored only once, no matter how many objects are created. Memory is allocated for the object member variables when the object is created.  Thus, the size of an object is determined not by its code's size but by the memory it needs for its member variables to be stored.
",Creating object with the new keyword[edit],plain_text
1647,,Creating object by cloning an object[edit],
1648,"Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object's states.  
",Creating object by cloning an object[edit],plain_text
1649,"You may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the private memberVar variable of obj is legal as this is in the same class):
",Creating object by cloning an object[edit],plain_text
1650,"1 public class MyObject {
2    private int memberVar;
3 ...
4    MyObject(MyObject obj) {
5       this.memberVar = obj.memberVar;
6     ...
7    }
8 ...
9 }
",Creating object by cloning an object[edit],code_fragment
1651,"This method works but object creation with the new keyword is time-consuming. The clone() method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.
",Creating object by cloning an object[edit],plain_text
1652," 1 HashTable cacheTemplate = new HashTable();
 2 ...
 3 /** Clone Customer object for performance reason */
 4 public Customer createCustomerObject() {
 5    // See if a template object exists in our cache
 6    Customer template = cacheTemplate.get(""Customer"");
 7    if (template == null) {
 8       // Create template
 9       template = new Customer();
10       cacheTemplate.put(""Customer"", template);
11    }
12    return template.clone();
13 }
",Creating object by cloning an object[edit],code_fragment
1653,"Now, let's see how to make the Customer object cloneable.
",Creating object by cloning an object[edit],plain_text
1654,"1 public class Customer implements Cloneable {
2  ...
3     public Object clone() throws CloneNotSupportedException {
4        Object obj = super.clone();
5 
6        return obj;
7     }
8 }
",Creating object by cloning an object[edit],code_fragment
1655,"In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects.  So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't.  Also let's say that the Customer object has a reference to an Activity object that contains the customer activities.  Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects.  The solution:
",Creating object by cloning an object[edit],plain_text
1656," 1 public class Customer implements Cloneable {
 2   Activity activity;
 3   ...
 4     public Customer clone() throws CloneNotSupportedException {
 5       Customer clonedCustomer = (Customer) super.clone();
 6 
 7       // Clone the object referenced objects
 8       if (activity != null) {
 9          clonedCustomer.setActivity((Activity) activity.clone());
10       }
11       return clonedCustomer;
12    }
13 }
",Creating object by cloning an object[edit],code_fragment
1657,"Note that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry.
",Creating object by cloning an object[edit],plain_text
1658,,Re-creating an object received from a remote source[edit],
1659,"When an object is sent through a network, the object needs to be re-created at the receiving host.
",Re-creating an object received from a remote source[edit],plain_text
1660,"Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.
",Re-creating an object received from a remote source[edit],plain_text
1661,"By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped).  If additional handling is required beyond the default of writing all fields, you need to provide an implementation for the following three methods:
",Re-creating an object received from a remote source[edit],plain_text
1662,"If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:
",Re-creating an object received from a remote source[edit],plain_text
1663,"Normally, a minor change to the class can cause the serialization to fail.  You can still allow the class to be loaded by defining the serialization version id:
",Re-creating an object received from a remote source[edit],plain_text
1664,"1 private static final long serialVersionUID = 42L;
",Re-creating an object received from a remote source[edit],code_fragment
1665,,Destroying objects[edit],
1666,"Unlike in many other object-oriented programming languages, Java performs automatic garbage collection — any unreferenced objects are automatically erased from memory — and prohibits the user from manually destroying objects.
",Destroying objects[edit],plain_text
1667,"When an object is garbage-collected, the programmer may want to manually perform cleanup, such as closing any open input/output streams.  To accomplish this, the finalize() method is used.  Note that finalize() should never be manually called, except to call a super class' finalize method from a derived class' finalize method.  Also, we can not rely on when the finalize() method will be called.  If the java application exits before the object is garbage-collected, the finalize() method may never be called.
",Destroying objects[edit],plain_text
1668,"1 protected void finalize() throws Throwable {
2   try {
3     doCleanup();        // Perform some cleanup.  If it fails for some reason, it is ignored.
4   } finally {
5     super.finalize(); // Call finalize on the parent object
6   }
7 }
",Destroying objects[edit],code_fragment
1669,"The garbage-collector thread runs in a lower priority than the other threads. If the application creates objects faster than the garbage-collector can claim back memory, the program can run out of memory.
",Destroying objects[edit],plain_text
1670,"The finalize method is required only if there are resources beyond the direct control of the Java Virtual Machine that needs to be cleaned up.  In particular, there is no need to explicitly close an OutputStream, since the OutputStream will close itself when it gets finalized.  Instead, the finalize method is used to release either native or remote resources controlled by the class.
",Destroying objects[edit],plain_text
1671,,Class loading[edit],
1672,"One of the main concerns of a developer writing hot re-deployable applications is to understand how class loading works. Within the internals of the class loading mechanism lies the answer to questions like:
",Class loading[edit],plain_text
1673,"What happens if I pack a newer version of an utility library with my application, while an older version of the same library lingers somewhere in the server's lib directory?
How can I use two different versions of the same utility library, simultaneously, within the same instance of the application server?
What version of an utility class I am currently using?
Why do I need to mess with all this class loading stuff anyway?",Class loading[edit],plain_text
1674,"
",Scope,plain_text
1675,,Scope[edit],
1676,"The scope of a class, a variable or a method is its visibility and its accessibility. The visibility or accessibility means that you can use the item from a given place.
",Scope[edit],plain_text
1677,"A method parameter is visible inside of the entire method but not visible outside the method.
",Scope[edit],plain_text
1678," 1 public class Scope {
 2 
 3     public void method1(int i) {
 4         i = i++;
 5         method2();
 6         int j = i * 2;
 7     }
 8 
 9     public void method2() {
10         int k = 20;
11     }
12 
13     public static void main(String[] args) {
14         method1(10);
15     }
16 }
",Scope[edit],code_fragment
1679,"In code listing 3.14, i is visible within the entire method1 method but not in the method2 and the main methods.
",Scope[edit],plain_text
1680,"A local variable is visible after its declaration until the end of the block in which the local variable has been created.
",Scope[edit],plain_text
1681," 1 {
 2 ...
 3      // myNumber is NOT visible
 4   {
 5      // myNumber is NOT visible
 6      int myNumber;
 7      // myNumber is visible
 8     {
 9       ...
10        // myNumber is visible
11     }
12        // myNumber is visible
13   }
14      // myNumber is NOT visible
15 ...
16 }
",Scope[edit],code_fragment
1682,,Access modifiers[edit],
1683,"You surely would have noticed by now, the words public, protected and private at the beginning of class's method declarations used in this book. These keywords are called the access modifiers in the Java language syntax, and they define the scope of a given item.
",Access modifiers[edit],plain_text
1684,"If a class has public visibility, the class can be referenced by anywhere in the program.
If a class has protected visibility, the class can be referenced only in the package where the class is defined.
If a class has private visibility, (it can happen only if the class is defined nested in an other class) the class can be accessed only in the outer class.",Access modifiers[edit],plain_text
1685,"If a variable is defined in a public class and it has public visibility, the variable can be referenced anywhere in the application through the class it is defined in.
If a variable has protected visibility, the variable can be referenced only in the sub-classes and in the same package through the class it is defined in.
If a variable has package visibility, the variable can be referenced only in the same package through the class it is defined in.
If a variable has private visibility, the variable can be accessed only in the class it is defined in.",Access modifiers[edit],plain_text
1686,"If a method is defined in a public class and it has public visibility, the method can be called anywhere in the application through the class it is defined in.
If a method has protected visibility, the method can be called only in the sub-classes and in the same package through the class it is defined in.
If a method has package visibility, the method can be called only in the same package through the class it is defined in.
If a method has private visibility, the method can be called only in the class it is defined in.",Access modifiers[edit],plain_text
1687,"The interface methods and interfaces are always public. You do not need to specify the access modifier. It will default to public. For clarity it is considered a good practice to put the public keyword.
",Access modifiers[edit],plain_text
1688,"The same way all member variables defined in the Interface by default will become static final once inherited in a class.
",Access modifiers[edit],plain_text
1689,"The cases in bold are the default.
",Access modifiers[edit],plain_text
1690,,Utility[edit],
1691,"A general guideline for visibilities is to only make a member as visible as it needs to be. Don't make a member public if it only needs to be private.
",Utility[edit],plain_text
1692,"Doing so, you can rewrite a class and change all the private members without making compilation errors, even you don't know all the classes that will use your class as long as you do not change the signature of the public members.
",Utility[edit],plain_text
1693,,Field encapsulation[edit],
1694,"Generally, it is best to make data private or protected.  Access to the data is controlled by setter and getter methods.  This lets the programmer control access to data, allowing him/her to check for and handle invalid data.
",Field encapsulation[edit],plain_text
1695," 1 private String name;
 2 
 3 /**
 4  * This is a getter method because it accesses data from the object.
 5  */
 6 public String getName() {
 7   return name;
 8 }
 9 
10 /**
11  * This is a setter method because it changes data in the object.
12  */
13 public boolean setName(String newName) {
14   if (newName == null) {
15     return false;
16   } else {
17     name = newName;
18     return true;
19   }
20 }
",Field encapsulation[edit],code_fragment
1696,"In the code section 3.51, the setName() method will only change the value of name if the new name is not null.  Because setName() is conditionally changing name, it is wise to return a boolean to let the program know if the change was successful.
",Field encapsulation[edit],plain_text
1697," 1 public class Question15 {
 2 
 3     public static final int QKQKQKQK_MULTIPLIER = 2;
 4 
 5     public int ijijijijijijijijijAwfulName = 20;
 6 
 7     private int unununununununununCrummyName = 10;
 8 
 9     private void mememememememeUglyName(int i) {
10         i = i++;
11         tltltltltltltltltlBadName();
12         int j = i * QKQKQKQK_MULTIPLIER;
13     }
14 
15     public void tltltltltltltltltlBadName() {
16         int k = ijijijijijijijijijAwfulName;
17     }
18 
19     public static void main(String[] args) {
20         mememememememeUglyName(unununununununununCrummyName);
21     }
22 }
",Field encapsulation[edit],code_fragment
1698,"
In Java you can define a class inside an other class. A class can be nested inside another class or inside a method. A class that is not nested is called a top-level class and a class defining a nested class is an outer class.
",Nested classes,plain_text
1699,,Inner classes[edit],
1700,"When a class is declared inside another class, the nested class' access modifier can be public, private, protected or package(default).
",Inner classes[edit],plain_text
1701,"1 public class OuterClass {
2    private String outerInstanceVar;
3 
4    public class InnerClass {
5       public void printVars() {
6          System.out.println(""Print Outer Class Instance Var.:"" + outerInstanceVar);
7       }
8    }
9 }
",Inner classes[edit],code_fragment
1702,"The inner class has access to the enclosing class instance's variables and methods, even private ones, as seen above. This makes it very different from the nested class in C++, which are equivalent to the ""static"" inner classes, see below.
",Inner classes[edit],plain_text
1703,"An inner object has a reference to the outer object. In other words, all inner objects are tied to the outer object. The inner object can only be created through a reference to the 'outer' object. See below.
",Inner classes[edit],plain_text
1704,"1 public void testInner() {
2     ...
3     OuterClass outer = new OuterClass();
4     OuterClass.InnerClass inner = outer.new InnerClass();  
5     ...
6 }
",Inner classes[edit],code_fragment
1705,"Note that inner objects, because they are tied to the outer object, cannot contain static variables or methods.
",Inner classes[edit],plain_text
1706,"When in a non-static method of the outer class, you can directly use new InnerClass(), since the class instance is implied to be this.
",Inner classes[edit],plain_text
1707,"You can directly access the reference to the outer object from within an inner class with the syntax OuterClass.this; although this is usually unnecessary because you already have access to its fields and methods.
",Inner classes[edit],plain_text
1708,"Inner classes compile to separate "".class"" bytecode files, with the name of the enclosing class, followed by a ""$"", followed by the name of the inner class. So for example, the above inner class would be compiled to a file named ""OuterClass$InnerClass.class"".
",Inner classes[edit],plain_text
1709,"A nested class can be declared static. These classes are not bound to an instance of the outer defining class. A static nested class has no enclosing instance, and therefore cannot access instance variables and methods of the outer class. You do not specify an instance when creating a static inner class. This is equivalent to the inner classes in C++.
",Inner classes[edit],plain_text
1710,"These inner classes, also called local classes, cannot have access modifiers, like local variables, since the class is 'private' to the method. The inner class can be only abstract or final.
",Inner classes[edit],plain_text
1711,"1 public class OuterClass {
2    public void method() {
3       class InnerClass {
4  
5       }
6    }
7 }
",Inner classes[edit],code_fragment
1712,"In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared final. This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be final, so it cannot be changed.
",Inner classes[edit],plain_text
1713,,Anonymous Classes[edit],
1714,"In Java, a class definition and its instantiation can be combined into a single step. By doing that the class does not require a name. Those classes are called anonymous classes. An anonymous class can be defined and instantiated in contexts where a reference can be used, and it is a nested class to an existing class. Anonymous class is a special case of a class local to a method; hence they also can access final local variables of the enclosing method.
",Anonymous Classes[edit],plain_text
1715,"Anonymous classes are most useful to create an instance of an interface or adapter class without needing a brand new class.
",Anonymous Classes[edit],plain_text
1716,"1 public interface ActionListener {
2     public void actionPerformed();
3 }
",Anonymous Classes[edit],code_fragment
1717,"1 ActionListener listener = new ActionListener() {
2         public void actionPerformed() {
3             // Implementation of the action event
4             ...
5             return;
6         }
7     };
",Anonymous Classes[edit],code_fragment
1718,"In the above example the class that implements the ActionListener is anonymous. The class is defined where it is instantiated.
",Anonymous Classes[edit],plain_text
1719,"The above code is harder to read than if the class is explicitly defined, so why use it? If many implementations are needed for an interface, those classes are used only in one particular place, and it would be hard to come up with names for them, using an anonymous inner class makes sense.
",Anonymous Classes[edit],plain_text
1720,"The following example uses an anonymous inner class to implement an action listener.
",Anonymous Classes[edit],plain_text
1721," 1 import java.awt.Button;
 2 import java.awt.event.ActionEvent;
 3 import java.awt.event.ActionListener;
 4 
 5 class MyApp {
 6    Button aButton = new Button();
 7 
 8    MyApp() {
 9        aButton.addActionListener(new ActionListener() {
10                public void actionPerformed(ActionEvent e) {
11                    System.out.println(""Hello There"");
12                }
13            }
14        );
15    }
16 }
",Anonymous Classes[edit],code_fragment
1722,"The following example does the same thing, but it names the class that implements the action listener.
",Anonymous Classes[edit],plain_text
1723," 1 import java.awt.Button;
 2 import java.awt.event.ActionEvent;
 3 import java.awt.event.ActionListener;
 4 
 5 class MyApp {
 6    Button aButton = new Button();
 7 
 8    // Nested class to implement the action listener
 9    class MyActionListener implements ActionListener {
10        public void actionPerformed(ActionEvent e) {
11            System.out.println(""Hello There"");
12        }
13    }
14    MyApp() {
15        aButton.addActionListener(new MyActionListener());
16    }
17 }
",Anonymous Classes[edit],code_fragment
1724,"Using anonymous classes is especially preferable when you intend to use many different classes that each implement the same interface.
",Anonymous Classes[edit],plain_text
1725,"
",Anonymous Classes[edit],plain_text
1726,"Java is a strongly typed language, so a field in a class may be typed like this:
",Generics,plain_text
1727," 1 public class Repository {
 2 
 3    public Integer item;
 4 
 5    public Integer getItem() {
 6       return item;
 7    }
 8 
 9    public void setItem(Integer newItem) {
10       item = newItem;
11    }
12 }
",Generics,code_fragment
1728,"This ensures that, only Integer objects can be put in the field and a ClassCastException can't occur at runtime, only compile-time error can occur. Unfortunately, it can be used only with Integer objects. If you want to use the same class in another context with Strings, you have to generalize the type like this:
",Generics,plain_text
1729," 1 public class Repository {
 2 
 3    public Object item;
 4 
 5    public Object getItem() {
 6       return item;
 7    }
 8 
 9    public void setItem(Integer newItem) {
10       item = newItem;
11    }
12 
13    public void setItem(String newItem) {
14       item = newItem;
15    }
16 }
",Generics,code_fragment
1730,"But you will have ClassCastException at runtime again and you can't easily use your field. The solution is to use Generics.
",Generics,plain_text
1731,,Generic class[edit],
1732,"A generic class does not hard code the type of a field, a return value or a parameter. The class only indicates that a generic type should be the same, for a given object instance. The generic type is not specified in the class definition. It is specified during object instantiation. This allows the generic type to be different from an instance to another. So we should write our class this way:
",Generic class[edit],plain_text
1733," 1 public class Repository<T> {
 2 
 3    public T item;
 4 
 5    public T getItem() {
 6       return item;
 7    }
 8 
 9    public void setItem(T newItem) {
10       item = newItem;
11    }
12 }
",Generic class[edit],code_fragment
1734,"Here, the generic type is defined after the name of the class. Any new identifier can be chosen. Here, we have chosen T, which is the most common choice. The actual type is defined at the object instantiation:
",Generic class[edit],plain_text
1735,"1 Repository<Integer> arithmeticRepository = new Repository<Integer>();
2 arithmeticRepository.setItem(new Integer(1));
3 Integer number = arithmeticRepository.getItem();
4 
5 Repository<String> textualRepository = new Repository<String>();
6 textualRepository.setItem(""Hello!"");
7 String message = textualRepository.getItem();
",Generic class[edit],code_fragment
1736,"Although each object instance has its own type, each object instance is still strongly typed:
",Generic class[edit],plain_text
1737,"1 Repository<Integer> arithmeticRepository = new Repository<Integer>();
2 arithmeticRepository.setItem(""Hello!"");
",Generic class[edit],code_fragment
1738,"A class can define as many generic types as you like. Choose a different identifier for each generic type and separate them by a comma:
",Generic class[edit],plain_text
1739," 1 public class Repository<T, U> {
 2 
 3    public T item;
 4 
 5    public U anotherItem;
 6 
 7    public T getItem() {
 8       return item;
 9    }
10 
11    public void setItem(T newItem) {
12       item = newItem;
13    }
14 
15    public U getAnotherItem() {
16       return anotherItem;
17    }
18 
19    public void setAnotherItem(U newItem) {
20       anotherItem = newItem;
21    }
22 }
",Generic class[edit],code_fragment
1740,"When a type that is defined with generic (for example, Collection<T>) is not used with generics (for example, Collection) is called a raw type.
",Generic class[edit],plain_text
1741,,Generic method[edit],
1742,"A generic type can be defined for just a method:
",Generic method[edit],plain_text
1743,"1 public <D> D assign(Collection<D> generic, D obj) {
2   generic.add(obj);
3   return obj;
4 }
",Generic method[edit],code_fragment
1744,"Here a new identifier (D) has been chosen at the beginning of the method declaration. The type is specific to a method call and different types can be used for the same object instance:
",Generic method[edit],plain_text
1745,"1 Collection<Integer> numbers = new ArrayList<Integer>();
2 Integer number = assign(numbers, new Integer(1));
3 Collection<String> texts = new ArrayList<String>();
4 String text = assign(texts, ""Store it."");
",Generic method[edit],code_fragment
1746,"The actual type will be defined by the type of the method parameter. Hence, the generic type can't be defined only for the return value as it wouldn't be resolved. See the Class<T> section for a solution.
",Generic method[edit],plain_text
1747," 1 public class Question8<T> {
 2   public T item;
 3  
 4   public T getItem() {
 5     return item;
 6   }
 7  
 8   public void setItem(T newItem) {
 9     item = newItem;
10   }
11 
12   public static void main(String[] args) {
13     Question8<String> aQuestion = new Question8<String>();
14     aQuestion.setItem(""Open your mind."");
15     aQuestion.display(aQuestion.getItem());
16   }
17 
18   public void display(String parameter) {
19     System.out.println(""Here is the text: "" + parameter);
20   }
21 
22   public void display(Integer parameter) {
23     System.out.println(""Here is the number: "" + parameter);
24   }
25 
26   public void display(Object parameter) {
27     System.out.println(""Here is the object: "" + parameter);
28   }
29 }
",Generic method[edit],code_fragment
1748,,Wildcard Types[edit],
1749,"As we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.
In some cases this is too restrictive.  What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?
The wildcard type is represented by the character <?>, and pronounced Unknown, or Any-Type. Any-Type can be expressed also by <? extends Object>. Any-Type includes Interfaces, not only Classes.
So now we can define a collection whose element type matches anything. See below:
",Wildcard Types[edit],plain_text
1750,"1 Collection<?> collUnknown;
",Wildcard Types[edit],code_fragment
1751,"You can specify a restriction on the types of classes that may be used. For example, <? extends ClassName> only allows objects of class ClassName or a subclass.
For example, to create a collection that may only contain ""Serializable"" objects, specify:
",Wildcard Types[edit],plain_text
1752,"1 Collection<String> textColl = new ArrayList<String>();
2 
3 Collection<? extends Serializable> serColl = textColl;
",Wildcard Types[edit],code_fragment
1753,"The above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String. The following collection can only contain objects that extend the class Animal.
",Wildcard Types[edit],plain_text
1754,"1 class Dog extends Animal {
2 }
",Wildcard Types[edit],code_fragment
1755,"1 // Create ""Animal Collection"" variable
2 Collection<? extends Animal> animalColl = new ArrayList<Dog>();
",Wildcard Types[edit],code_fragment
1756,"<? super ClassName> specifies a restriction on the types of classes that may be used.
For example, to declare a Comparator that can compare Dogs, you use:
",Wildcard Types[edit],plain_text
1757,"1 Comparator<? super Dog> myComparator;
",Wildcard Types[edit],code_fragment
1758,"Now suppose you define a comparator that can compare Animals:
",Wildcard Types[edit],plain_text
1759,"1 class AnimalComparator implements Comparator<Animal> {
2   int compare(Animal a, Animal b) {
3    //...
4   }
5 }
",Wildcard Types[edit],code_fragment
1760,"Since Dogs are Animals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.
",Wildcard Types[edit],plain_text
1761,"1 Comparator<Animal> myAnimalComparator = new AnimalComparator();
2 
3 static int compareTwoDogs(Comparator<? super Dog> comp, Dog dog1, Dog dog2) {
4   return comp.compare(dog1, dog2);
5 }
",Wildcard Types[edit],code_fragment
1762,"The above code is valid because the Animal class is a supertype of the Dog class. Use of a class that is not a supertype would cause a compilation error.
",Wildcard Types[edit],plain_text
1763,"The advantage of the unbounded wildcard (i.e. <?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not any type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:
",Wildcard Types[edit],plain_text
1764,"1 public void addAtBottom(Collection anyCollection) {
2   anyCollection.add(new Integer(1));
3 }
",Wildcard Types[edit],code_fragment
1765,"This code will compile but this code may corrupt the collection if the collection only contains strings:
",Wildcard Types[edit],plain_text
1766,"1 List<String> col = new ArrayList<String>();
2 addAtBottom(col);
3 col.get(0).endsWith(""."");
",Wildcard Types[edit],code_fragment
1767,"This situation could have been avoided if the addAtBottom(Collection) method was defined with an unbounded wildcard: addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(), isEmpty(), iterator(), remove(Object o), size(), ...) can be called. For instance, addAtBottom(Collection<?>) could contain the following code:
",Wildcard Types[edit],plain_text
1768,"1 public void addAtBottom(Collection<?> anyCollection) {
2    Iterator<?> iterator = anyCollection.iterator();
3    while (iterator.hasNext()) {
4       System.out.print(iterator.next());
5    }
6 }
",Wildcard Types[edit],code_fragment
1769,,Class<T>[edit],
1770,"Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using generics for something other than a container class.
For example, the type of String.class is Class<String>, and the type of Serializable.class is Class<Serializable>. This can be used to improve the type safety of your reflection code.
In particular, since the newInstance() method in Class now returns T, you can get more precise types when creating objects reflectively.
Now we can use the newInstance() method to return a new object with exact type, without casting. An example with generics:
",Class<T>[edit],plain_text
1771," 1 Customer cust = Utility.createAnyObject(Customer.class);  // No casting
 2 ...
 3 public static <T> T createAnyObject(Class<T> cls) {
 4     T ret = null;
 5     try {
 6         ret = cls.newInstance();
 7     } catch (Exception e) {
 8         // Exception Handling
 9     }
10     return ret;
11 }
",Class<T>[edit],code_fragment
1772,"The same code without generics:
",Class<T>[edit],plain_text
1773," 1 Customer cust = (Customer) Utility.createAnyObject(Customer.class);  // Casting is needed
 2 ...
 3 public static Object createAnyObject(Class cls) {
 4     Object ret = null;
 5     try {
 6         ret = cls.newInstance();
 7     } catch (Exception e) {
 8         // Exception Handling
 9     }
10     return ret;
11 }
",Class<T>[edit],code_fragment
1774,,Motivation[edit],
1775,"Java was long criticized for the need to explicitly type-cast an element when it was taken out of a ""container/collection"" class. There was no way to enforce that a ""collection"" class contains only one type of object (e.g., to forbid at compile time that an Integer object is added to a Collection that should only contain Strings). This is possible since Java 1.5.
In the first couple of years of Java evolution, Java did not have a real competitor. This has changed by the appearance of Microsoft C#. With Generics Java is better suited to compete against C#.
Similar constructs to Java Generics exist in other languages, see Generic programming for more information.
Generics were added to the Java language syntax in version 1.5. This means that code using Generics will not compile with Java 1.4 and less.
Use of generics is optional. For backwards compatibility with pre-Generics code, it is okay to use generic classes without the generics type specification (<T>). In such a case, when you retrieve an object reference from a generic object, you will have to manually cast it from type Object to the correct type.
",Motivation[edit],plain_text
1776,,Note for C++ programmers[edit],
1777,"Java Generics are similar to C++ Templates in that both were added for the same reason. The syntax of Java Generic and C++ Template are also similar. There are some differences however. The C++ template can be seen as a kind of macro, in that a new copy of the code is generated for each generic type referenced. All extra code for templates is generated at compiler time.
In contrast, Java Generics are built into the language.  The same code is used for each generic type. For example:
",Note for C++ programmers[edit],plain_text
1778,"1 Collection<String>  collString  = new ArrayList<String>();
2 Collection<Integer> collInteger = new ArrayList<Integer>();
",Note for C++ programmers[edit],code_fragment
1779,"Both these objects appear as the same type at runtime (both ArrayList's). The generic type information is erased during compilation (type erasure). For example:
",Note for C++ programmers[edit],plain_text
1780,"1 public <T> void method(T argument) {
2   T variable;
3   …
4 }
",Note for C++ programmers[edit],code_fragment
1781,"is transformed by erasure into:
",Note for C++ programmers[edit],plain_text
1782,"1 public void method(Object argument) {
2   Object variable;
3   …
4 }
",Note for C++ programmers[edit],code_fragment
1783," 1 import java.util.ArrayList;
 2 import java.util.Collection;
 3 
 4 public class Question9 {
 5   public static void main(String[] args) {
 6     Collection<String> collection1 = new ArrayList<String>();
 7     Collection<? extends Object> collection2 = new ArrayList<String>();
 8     Collection<? extends String> collection3 = new ArrayList<String>();
 9     Collection<? extends String> collection4 = new ArrayList<Object>();
10     Collection<? super Object> collection5 = new ArrayList<String>();
11     Collection<? super Object> collection6 = new ArrayList<Object>();
12     Collection<?> collection7 = new ArrayList<String>();
13     Collection<? extends Object> collection8 = new ArrayList<?>();
14     Collection<? extends Object> collection9 = new ArrayList<Object>();
15     Collection<? extends Integer> collection10 = new ArrayList<String>();
16     Collection<String> collection11 = new ArrayList<? extends String>();
17     Collection collection12 = new ArrayList<String>();
18   }
19 }
",Note for C++ programmers[edit],code_fragment
1784,"
",Note for C++ programmers[edit],plain_text
1785,"The most basic collection interface is called Collection. This interface gives the user the generic usage of a collection. All collections need to have the same basic operations. Those are:
",Collection,plain_text
1786,"Adding element(s) to the collection
Removing element(s) from the collection
Obtaining the number of elements in the collection
Listing the contents of the collection, (Iterating through the collection)",Collection,plain_text
1787," 1 import java.util.Collection;   // Interface
 2 import java.util.ArrayList;    // Implementation
 3 
 4 public class CollectionProgram {
 5 
 6   public static void main(String[] args) {
 7     Collection myCollection = new ArrayList();
 8     myCollection.add(""1"");
 9     myCollection.add(""2"");
10     myCollection.add(""3"");
11     System.out.println(""The collection contains "" + myCollection.size() + "" item(s)."");
12 
13     myCollection.clear();
14     if (myCollection.isEmpty()) {
15       System.out.println(""The collection is empty."");
16     } else {
17       System.out.println(""The collection is not empty."");
18     }
19   }
20 }
",Collection,code_fragment
1788,"When you put an object in a collection, this object is not actually in the collection. Only its object reference is added to the collection. This means that if an object is changed after it was put in an collection, the object in the collection also changes. The code listing 5.2 computes the seven next days from tomorrow and stores each date in a list to read it afterwards. See what happens:
",Collection,plain_text
1789," 1 import java.util.ArrayList;
 2 import java.util.Calendar;
 3 import java.util.Collection;
 4 import java.util.Date;
 5 import java.util.GregorianCalendar;
 6 
 7 public class SevenNextDays {
 8 
 9   public static void main(String[] args) {
10    
11     // The calendar is set at the current date: today
12     Calendar calendar = new GregorianCalendar();
13 
14     Collection collectionOfDays = new ArrayList();
15     Date currentDate = new Date();
16     for (int i = 0; i < 7; ++i) {
17       // The calendar is now set to the next day
18       calendar.add(Calendar.DATE, 1);
19       currentDate.setTime(calendar.getTimeInMillis());
20 
21       collectionOfDays.add(currentDate);
22     }
23 
24     for (Object oneDay : collectionOfDays) {
25       System.out.println(""The next day is: "" + oneDay);
26     }
27   }
28 }
",Collection,code_fragment
1790,"All collection items were meant to be updated to a different date but they all have been updated to the last one. This means that each update has updated all the collection items. The currentDate has been used to fill all the collection items. The collection didn't keep trace of the added values (one of the seven dates) but the added object references (currentDate). So the collection contains the same object seven times! To avoid this issue, we should have coded it this way:
",Collection,plain_text
1791," 1 import java.util.ArrayList;
 2 import java.util.Calendar;
 3 import java.util.Collection;
 4 import java.util.Date;
 5 import java.util.GregorianCalendar;
 6 
 7 public class ActualSevenNextDays {
 8 
 9   public static void main(String[] args) {
10    
11     // The calendar is set at the current date: today
12     Calendar calendar = new GregorianCalendar();
13 
14     Collection collectionOfDays = new ArrayList();
15     for (int i = 0; i < 7; ++i) {
16       Date currentDate = new Date();
17       // The calendar is now set to the next day
18       calendar.add(Calendar.DATE, 1);
19       currentDate.setTime(calendar.getTimeInMillis());
20 
21       collectionOfDays.add(currentDate);
22     }
23 
24     for (Object oneDay : collectionOfDays) {
25       System.out.println(""The next day is: "" + oneDay);
26     }
27   }
28 }
",Collection,code_fragment
1792,"Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item being changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.
",Collection,plain_text
1793,,Generics[edit],
1794,"Objects put into a collection are upcasted to the Object class. This means that you need to cast the object reference back when you get an element out of the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. For example. let's use this collection with two objects in it:
",Generics[edit],plain_text
1795,"1 Collection ageList = new ArrayList();
2 ageList.add(new Integer(46));
3 ageList.add(""50"");
",Generics[edit],code_fragment
1796,"1 Integer sum = new Integer(0);
2 for (Object age : ageList) {
3     sum = sum.add((Integer) age);
4 }
5 
6 if (!ageList.isEmpty()) {
7     System.out.println(""The average age is "" + sum / ageList.size());
8 }
",Generics[edit],code_fragment
1797,"This error could have been found earlier, at compile time, by using generic types. The Generics have been added since JDK version 1.5. It is an enhancement to the type system of the Java language.  All collection implementations since 1.5 now have a parameterized type <E>.  The E refers to an Element type.  When a collection is created, the actual Element type will replace the E.  In the collection, the objects are now upcasted to E class.
",Generics[edit],plain_text
1798,"1 Collection<Integer> ageList = new ArrayList<Integer>();
2 ageList.add(new Integer(46));     // Integer can be added
3 ageList.add(""50"");                // Compilation error, ageList can have only Integers inside
",Generics[edit],code_fragment
1799," ageList  is a collection that can contain only Integer objects as elements. No casting is required when we take out an element.
",Generics[edit],plain_text
1800,"1 Integer age = ageList.get(0);
",Generics[edit],code_fragment
1801,"Generics are not mandatory but are is often used with the collection classes.
",Generics[edit],plain_text
1802,,Collection classes[edit],
1803,"There is no direct implementation for the java.util.Collection interface.  The Collection interface has five sub interfaces.
",Collection classes[edit],plain_text
1804,"
",Collection classes[edit],plain_text
1805,"A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method int hashCode() of the item and compares its result to the hash code of all the already inserted items. If the hash code is not found, the item is added. If the hash code is found, the set calls the boolean equals(Object obj); method for all the set items with the same hashcode as the new item. If all equal-calls return false, the new item is inserted in the set. If an equal-call returns true, the new item is not inserted in the set.
",Collection classes[edit],plain_text
1806,"
",Collection classes[edit],plain_text
1807,"Set cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the Set. We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects' values have to be checked as well.
",Collection classes[edit],plain_text
1808,"To do that, fortunately, each java object has the boolean equals(Object obj), method available inherited from Object. You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.
",Collection classes[edit],plain_text
1809,"There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared.  Calling the equals() method would cause a ClassCastException. There are two solutions to this:
",Collection classes[edit],plain_text
1810,"Solution one : Override the int hashCode() method and return the same values for the same type of objects and return different values for different type of objects.  The equals() method is used to compare objects only with the same value of hashCode. So before an object is added, the Set implementation needs to:
find all the objects in the Set that have the same hashCode as the candidate object hashCode
and for those, call the equals() methods passing in the candidate object
if any of them returns true, the object is not added to the Set.",Collection classes[edit],plain_text
1811,"Solution two : Create a super class for the Apple and Orange, let's call it Fruit class. Put Fruits in the Set. You need to do the following:
Do not override the equals() and hashCode() methods in the Apple and Orange classes
Create appleEquals() method in the Apple class, and create orangeEquals() method in the Orange class
Override the hashCode() method in the Fruit class and return the same value, so the equals() is called by the Set implementation
Override the equals() method in the Fruit class for something like this.",Collection classes[edit],plain_text
1812," 1 public boolean equals(Object obj) {
 2     boolean ret = false;
 3     if (this instanceof Apple &&
 4           obj instanceof Apple) {
 5         ret = this.appleEquals(obj);
 6     } else if (this instanceof Orange &&
 7               obj  instanceof Orange) {
 8         ret = this.orangeEquals(obj);  
 9     } else {
10         // Can not compare Orange to Apple
11        ret = false;
12     }
13     return ret;
14 }
",Collection classes[edit],code_fragment
1813,"Note:
",Collection classes[edit],plain_text
1814,"Only the objects that have the same hashCode will be compared.
You are responsible to override the equals() and hashCode() methods. The default implementations in Object won't work.
Only override the hashCode() method if you want to eliminate value duplicates.
Do not override the hashCode() method if you know that the values of your objects are different, or if you only want to prevent adding the exactly same object.
Beware that the hashCode() may be used in other collection implementations, like in a Hashtable to find an object fast. Overriding the default hashCode() method may affect performance there.
The default hashCodes are unique for each object created, so if you decide not to override the hashCode() method, there is no point overriding the equals() method, as it won't be called.",Collection classes[edit],plain_text
1815,"The SortedSet interface is the same as the Set interface plus the elements in the SortedSet are sorted. It extends the Set Interface. All elements in the SortedSet must implement the Comparable Interface, furthermore all elements must be mutually comparable.
",Collection classes[edit],plain_text
1816,"Note that the ordering maintained by a sorted set must be consistent with equals if the sorted set is to correctly implement the Set interface. This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compare method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.
",Collection classes[edit],plain_text
1817,"The SortedSet interface has additional methods due to the sorted nature of the 'Set'.  Those are:
",Collection classes[edit],plain_text
1818,"In a list collection, the elements are put in a certain order, and can be accessed by an index.  Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:
",Collection classes[edit],plain_text
1819,"
",Collection classes[edit],plain_text
1820," Head               Node 1                   Node 2                     Node n
  ______
 | Size |          _________________        _______________            _____________
 |______|         |      | point   |       |      | point  |          |      |      |  
 | First|-------->| Data | to next |------>| Data | to next|-- ... -->| Data | null |
 | elem |         |______|_________|       |______|________|          |______|______|
 |______|                                                                 ^
 | Last |                                                                 |
 | elem |-----------------------------------------------------------------
 |______|
",Collection classes[edit],plain_text
1821,"Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:
",Collection classes[edit],plain_text
1822," Head               Node 1                   Node 2                     Node n
  ______                                 _____________________
 | Size |          _________________    |   _______________   |       ______________
 |_- 1__|         |      | point   |    |  |      | point  |  |       |      |      |  
 | First|-------->| Data | to next |----   | Data | to next|   -...-->| Data | null |
 | elem |         |______|_________|       |______|________|          |______|______|
 |______|                                                                 ^
 | Last |                                                                 |
 | elem |-----------------------------------------------------------------
 |______|
",Collection classes[edit],plain_text
1823,,Queue[edit],
1824,"The Queue interface provides additional insertion, extraction, and inspection operations. There are FIFO (first in, first out) and LIFO (last in, first out) queues. This interface adds the following operations to the Collection interface:
",Queue[edit],plain_text
1825,"
",Queue[edit],plain_text
1826,,Complete UML class diagram[edit],
1827,"
",Complete UML class diagram[edit],plain_text
1828,,Synchronization[edit],
1829,"Synchronization is important when you are running several threads. Beware, synchronization does not mean that your collection is thread-safe. A thread-safe collection is also called a concurrent collection. Most of the popular collection classes have implementations for both single thread and multiple thread environments. The non-synchronized implementations are always faster. You can use the non-synchronized implementations in multiple thread environments, when you make sure that only one thread updates the collection at any given time.
",Synchronization[edit],plain_text
1830,"A new Java JDK package was introduced at Java 1.5, that is java.util.concurrent.  This package supplies a few Collection implementations designed for use in multi-threaded environments.
",Synchronization[edit],plain_text
1831,"The following table lists all the synchronized collection classes:
",Synchronization[edit],plain_text
1832,,Custom collection[edit],
1833,"The Java JDK collection implementations are quite powerful and good, so it is unlikely that you will need to write your own. The usage of the different collections are the same but the implementations are different. If the existing collection implementations do not meet your needs, you can write your version of the implementation. Your version of the implementation just needs to implement the same java.util.Collection interface, then you can switch to using your implementation and the code that is using the collection does not need to be changed.
",Custom collection[edit],plain_text
1834,"Use the Collection interface if you need to keep related (usually the same type of) objects together in a collection where you can:
",Custom collection[edit],plain_text
1835,"Search for a particular element
List the elements
Maintain and/or change the order of the elements by using the collection basic operations (Add, Remove, Update,..)
Access the elements by an index number",Custom collection[edit],plain_text
1836,"The advantages of using the Collection interface are:
",Custom collection[edit],plain_text
1837,"Gives a generic usage, as we talked about above, it is easy to switch implementation
It makes it easy to convert one type of collection to another.",Custom collection[edit],plain_text
1838,"The Collection interface defines the following basic operations:
",Custom collection[edit],plain_text
1839,"Note that in addAll() we can add any type of collection.  This is the beauty of using the Collection interface. You can have a LinkedList and just call the addAll(list) method, passing in a list.  You can pass in a Vector, an ArrayList, a HashSet, a TreeSet, a YourImpOfCollection, ...
All those different types of collection will be magically converted to a LinkedList.
",Custom collection[edit],plain_text
1840,"Let's have a closer look at this magic.  The conversion is easy because the Collection interface defines  a standard way of looping through the elements.  The following code is a possible implementation of addAll() method of the LinkedList.
",Custom collection[edit],plain_text
1841," 1 import java.util.Collection
 2 import java.util.Iterator
 3 ...
 4 public boolean addAll(Collection coll) {
 5    int sizeBefore = this.size();
 6    Iterator iter = coll.iterator();
 7    while(iter.hasNext()) {
 8       this.add(iter.next());
 9    }
10    if (sizeBefore > this.size()) {
11       return true;
12    } else {
13       return false;
14    }
15 }
",Custom collection[edit],code_fragment
1842,"The above code just iterates through the passed in collection and adds the elements to the linked list. You do not have to do that, since that is already defined. What you might need to code for is to loop through a Customer collection:
",Custom collection[edit],plain_text
1843," 1 import java.util.Collection
 2 import java.util.Iterator
 3 import java.yourcompany.Customer
 4 ...
 5 public String printCustomerNames(Collection customerColl) {
 6    StringBuffer buf = new StringBuffer();
 7 
 8    Iterator iter = customerColl.iterator();
 9    while(iter.hasNext()) {
10       Customer cust = (Customer) iter.next();
11       buf.append(cust.getName());
12       buf.append( ""\n"" );
13    }
14   return buf.toString();
15 }
",Custom collection[edit],code_fragment
1844,"Notice two things:
",Custom collection[edit],plain_text
1845,"The above code will work for all type of collections.
We have to know the type of objects inside the collection, because we call a method on it.",Custom collection[edit],plain_text
1846,"
",Custom collection[edit],plain_text
1847,"The ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed.
",ArrayList,plain_text
1848,"Standard Java arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold.
",ArrayList,plain_text
1849,"Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array may be shrunk.
",ArrayList,plain_text
1850,,Initializing[edit],
1851,"The ArrayList class supports three constructors. The first constructor builds an empty array list.:
",Initializing[edit],plain_text
1852,"The following constructor builds an array list that is initialized with the elements of the collection c.
",Initializing[edit],plain_text
1853,"The following constructor builds an array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements.
",Initializing[edit],plain_text
1854,"The capacity grows automatically as elements are added to an array list.
",Initializing[edit],plain_text
1855,,Methods[edit],
1856,"ArrayList defines following methods:
",Methods[edit],plain_text
1857,Inserts the specified element at the specified position index in this list. Throws IndexOutOfBoundsException if the specified index is out of range (index < 0 || index >= size()).,Methods[edit],plain_text
1858,Appends the specified element to the end of this list.,Methods[edit],plain_text
1859,"Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. Throws NullPointerException if the specified collection is null.",Methods[edit],plain_text
1860,"Inserts all of the elements in the specified collection into this list, starting at the specified position. Throws NullPointerException if the specified collection is null.",Methods[edit],plain_text
1861,Returns the number of elements in this list.,Methods[edit],plain_text
1862," Adding Element and Size of ArrayList
",Methods[edit],plain_text
1863," Output for Adding Element and Size of  ArrayList
",Methods[edit],plain_text
1864,Returns the element at the specified position in this list. Throws IndexOutOfBoundsException if the specified index is is out of range (index < 0 or index >= size()).,Methods[edit],plain_text
1865,Replaces the element at the specified position in this list with the specified element. Throws IndexOutOfBoundsException if the specified index is is out of range (index < 0 or index >= size()).,Methods[edit],plain_text
1866,"Returns the index in this list of the first occurrence of the specified element, or -1 if the List does not contain this element.",Methods[edit],plain_text
1867,"Returns the index in this list of the last occurrence of the specified element, or -1 if the list does not contain this element.",Methods[edit],plain_text
1868,"Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).",Methods[edit],plain_text
1869," Different Method in ArrayList
",Methods[edit],plain_text
1870," Output for Different Method in ArrayList
",Methods[edit],plain_text
1871,"public class ArrayListDemo {
		public static void main(String[] args) {
	
		ArrayList al = new ArrayList();

		al.add(""A"");
		al.add(""B"");
		al.add(""C"");
		al.add(""E"");
		al.add(""F"");
	
		al.remove(2);
		al.remove(""F"");
		
		al.set(1, ""G"");
		al.add(""H"");
		al.set(3, ""I"");
		System.out.println(""Size of al : "" + al.size());
		System.out.println(""Contents of al : "" + al);

	}
  }
",Methods[edit],code_fragment
1872,"Some more ArrayList methods:
",Methods[edit],plain_text
1873,"
Aside from the java.util.Collection interface, the Java JDK has the java.util.Map interface as well.  It is sometimes also called an Associated Array or a Dictionary.  A map defines key value mappings.  Implementations of the Map interface do not contain collections of objects.  Instead they contain collections of key->value mappings.  It can be thought of as an array where the index doesn't need to be an integer.
",Map,plain_text
1874,"1 import java.util.Map;
2 import java.util.Hashtable;
3 ...
4 Map map = new Hashtable();
5 ...
6 map.put(key, value);
",Map,code_fragment
1875,"Use the Map interface if you need to keep related objects together in a Map where you can:
",Map,plain_text
1876,"Access an element by a key object
Map one object to other",Map,plain_text
1877,"
",Map,plain_text
1878,"
",Map,plain_text
1879,"In the above example, the same operations are made with two different map implementations:
",Map,plain_text
1880," 1 import java.util.LinkedHashMap;
 2 import java.util.Map;
 3 import java.util.TreeMap;
 4 
 5 /**
 6  * Compare the map implementations.
 7  *
 8  * @author xxx
 9  */
10 public class MapImplementations {
11 
12   /**
13    * Compare the map implementations.
14    * @param args The execution parameters.
15    */
16   public static void main(String[] args) {
17     processMap(new LinkedHashMap<String, Integer>());
18 
19     processMap(new TreeMap<String, Integer>());
20   }
21 
22   /**
23    * Use a map:
24    * 1. Fill the map with key-> value.
25    * 2. Print all the keys.
26    *
27    * @param map The used map.
28    */
29   public static void processMap(Map<String, Integer> map) {
30     System.out.println(""Process the map"");
31     map.put(""3"", new Integer(3));
32     map.put(""2"", new Integer(2));
33     map.put(""1"", new Integer(1));
34 
35     for (String key : map.keySet()) {
36       System.out.println(key);
37     }
38   }
39 }
",Map,code_fragment
1881,"We see that only the TreeMap has sorted the keys. Beware of the generics. The Map interface is tricky. The methods get() and remove() are not generic. This means that you must be careful of the type of the key:
",Map,plain_text
1882," 1 Map<Integer, String> map = new TreeMap<Integer, String>();
 2 
 3 map.put(new Integer(1), ""Watch"");
 4 map.put(new Integer(2), ""out"");
 5 map.put(new Integer(3), ""!"");
 6 
 7 map.remove(""2"");
 8 
 9 for (String value : map.values()) {
10   System.out.println(value);
11 }
",Map,code_fragment
1883,"The remove() call has done nothing because ""2"" is a String, not an Integer so no key and value has been found and removed.
",Map,plain_text
1884,"The Map interface has the following implementations:
",Map,plain_text
1885,"
",Map,plain_text
1886,"
",Map,plain_text
1887,,Thread safe maps[edit],
1888,"The following table lists all the synchronized map classes:
",Thread safe maps[edit],plain_text
1889,"
",Thread safe maps[edit],plain_text
1890,"In Java, we can distinguish two kinds of equality. 
",Comparing Objects,plain_text
1891,"Object reference equality: when two object references point to the same object.
Object value equality: when two separate objects happen to have the same values/state.",Comparing Objects,plain_text
1892,"If two objects are equal in reference, they are equal in value too.
",Comparing Objects,plain_text
1893,,Comparing for reference equality[edit],
1894,"The == operator can be used to check if two object references point to the same object.
",Comparing for reference equality[edit],plain_text
1895,"1 if (objRef1 == objRef2) {
2     // The two object references point to the same object
3 }
",Comparing for reference equality[edit],code_fragment
1896,,Comparing for value equality[edit],
1897,"To be able to compare two Java objects of the same class the boolean equals(Object obj) method must be overriden and implemented by the class.
",Comparing for value equality[edit],plain_text
1898,"The implementor decides which values must be equal to consider two objects to be equal. For example in the below class, the name and the address must be equal but not the description.
",Comparing for value equality[edit],plain_text
1899," 1 public class Customer {
 2     private String name;
 3     private String address;
 4     private String description;
 5     // ...
 6     public boolean equals(Object obj) {
 7         if (this == obj) {
 8             return true;
 9         } else if (obj == null) {
10             return false;
11         } else if (obj instanceof Customer) {
12             Customer cust = (Customer) obj;
13             if ((cust.getName() == null && name == null) ||
14                 (cust.getName().equals(name) && ((cust.getAddress() == null && address == null)
15                 || cust.getAddress().equals(address))) {
16                 return true;
17             }
18         }
19         return false;
20     }
21 
22 }
",Comparing for value equality[edit],code_fragment
1900,"After the equals() method is overriden, two objects from the same class can be compared like this:
",Comparing for value equality[edit],plain_text
1901,"1 Customer cust1 = new Customer();
2 Customer cust2 = new Customer();
3 //...
4 if (cust1.equals(cust2)) {
5     // Two Customers are equal, by name and address
6 }
",Comparing for value equality[edit],code_fragment
1902,"Note that equal objects must have equal hash codes. Therefore, when overriding the equals method, you must also override the hashCode method. Failure to do so violates the general contract for the hashCode method, and any classes that use the hash code, such as HashMap will not function properly.
",Comparing for value equality[edit],plain_text
1903,,Sorting/Ordering[edit],
1904,"In Java, there are several existing methods that already sort objects from any class like Collections.sort(List<T> list). However, Java needs to know the comparison rules between two objects. So when you define a new class and want the objects of your class to be sortable, you have to implement the Comparable and redefine the compareTo(Object obj) method. 
",Sorting/Ordering[edit],plain_text
1905,"A negative integer means that the current object is before the parameter object in the natural ordering.
Zero means that the current object and the parameter object are equal.
A positive integer means that the current object is after the parameter object in the natural ordering.",Sorting/Ordering[edit],plain_text
1906,"Let's say that the name is more important than the address and the description is ignored.
",Sorting/Ordering[edit],plain_text
1907," 1 public class SortableCustomer implements Comparable<SortableCustomer> {
 2     private String name;
 3     private String address;
 4     private String description;
 5     // ...
 6     public int compareTo(SortableCustomer anotherCustomer) {
 7         if (name.compareTo(anotherCustomer.getName()) == 0) {
 8             return address.compareTo(anotherCustomer.getAddress();
 9         } else {
10             return name.compareTo(anotherCustomer.getName();
11         }
12     }
13 
14 }
",Sorting/Ordering[edit],code_fragment
1908,"Objects that implement this interface can be used as keys in a sorted map or elements in a sorted set, without the need to specify a comparator.
",Sorting/Ordering[edit],plain_text
1909,"The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo((Object) e2) == 0 has the same boolean value as e1.equals((Object) e2) for every e1 and e2 of class C. Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.
",Sorting/Ordering[edit],plain_text
1910,"It is strongly recommended (though not required) that natural orderings be consistent with equals. This is because sorted sets (and sorted maps) without explicit comparators behave ""strangely"" when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the equals method.
",Sorting/Ordering[edit],plain_text
1911,,Change Sorting/Ordering[edit],
1912,"Sometimes we may want to change the ordering of a collection of objects from the same class. We may want to order descending or ascending order. We may want to sort by name or by address.
",Change Sorting/Ordering[edit],plain_text
1913,"We need to create a class for each way of ordering. It has to implement the Comparator interface.
",Change Sorting/Ordering[edit],plain_text
1914,"Since Java 5.0, the Comparator interface is generic; that means when you implement it, you can specify what type of objects your comparator can compare.
",Change Sorting/Ordering[edit],plain_text
1915,"1 public class CustomerComparator implements Comparator<Customer> {
2     public int compare(Customer cust1, Customer cust2) {
3         return cust1.getName().compareTo(cust2.getName());
4     }
5 }
",Change Sorting/Ordering[edit],code_fragment
1916,"The above class then can be associated with a SortedSet or other collections that support sorting.
",Change Sorting/Ordering[edit],plain_text
1917,"1 Collection<Customer> orderedCustomers = new TreeSet<Customer>(new CustomerComparator());
",Change Sorting/Ordering[edit],code_fragment
1918,"Using the Iterator the orderedCustomers collection can be iterated in order of sorted by name.
",Change Sorting/Ordering[edit],plain_text
1919,"A List can be sorted by the Collections' sort method.
",Change Sorting/Ordering[edit],plain_text
1920,"1 java.util.Collections.sort(custList, new CustomerComparator());
",Change Sorting/Ordering[edit],code_fragment
1921,"Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator.
",Change Sorting/Ordering[edit],plain_text
1922,"An array of objects can also be sorted with the help of a Comparator.
",Change Sorting/Ordering[edit],plain_text
1923,"1 SortableCustomer[] customerArray;
2 //...
3 java.util.Arrays.sort(customerArray, new CustomerComparator());
",Change Sorting/Ordering[edit],code_fragment
1924,"Sorts the specified array of Customer objects (customerArray) according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator.
",Change Sorting/Ordering[edit],plain_text
1925,"
",Change Sorting/Ordering[edit],plain_text
1926,"
Language compilers are adept at pointing out most of the erroneous code in a program, however there are some errors that only become apparent when the program is executed. Consider the code listing 6.1; here, the program defines a method divide that does a simple division operation taking two integers as parameter arguments and returning the result of their division. It can safely be assumed that when the divide(4, 2) statement is called, it would return the number 2. However, consider the next statement, where the program relies upon the provided command line arguments to generate a division operation. What if the user provides the number zero (0) as the second argument? We all know that division  by zero is impossible, but the compiler couldn't possibly have anticipated the user providing zero as an argument.

",Throwing and catching exceptions,plain_text
1927," 1 public class SimpleDivisionOperation {
 2   public static void main(String[] args) {
 3     System.out.println(divide(4, 2));
 4     if (args.length > 1) {
 5       int arg0 = Integer.parseInt(args[0]);
 6       int arg1 = Integer.parseInt(args[1]);
 7       System.out.println(divide(arg0, arg1));
 8     }
 9   }
10 
11   public static int divide(int a, int b) {
12     return a / b;
13   }
14 }
",Throwing and catching exceptions,code_fragment
1928,"Such exceptional code that results in erroneous interpretations at program runtime usually results in errors that are called exceptions in Java. When the Java interpreter encounters an exceptional code, it halts execution and displays information about the error that occurs. This information is known as a stack trace. The stack trace in the above example tells us more about the error, such as the thread — ""main"" — where the exception occurred, the type of exception — java.lang.ArithmeticException, a comprehensible display message — / by zero, and the exact methods and the line numbers where the exception may have occurred.
",Throwing and catching exceptions,plain_text
1929,,Exception object[edit],
1930,"The preceding exception could have been created explicitly by the developer as it is the case in the following code:
",Exception object[edit],plain_text
1931," 1 public class SimpleDivisionOperation {
 2   public static void main(String[] args) {
 3     System.out.println(divide(4, 2));
 4     if (args.length > 1) {
 5       // Convert a string to an integer
 6       int arg0 = Integer.parseInt(args[0]);
 7       int arg1 = Integer.parseInt(args[1]);
 8       System.out.println(divide(arg0, arg1));
 9     }
10   }
11 
12   public static int divide(int a, int b) {
13     if (b == 0) {
14       throw new ArithmeticException(""You can\'t divide by zero!"");       
15     } else {
16       return a / b;
17     }
18   }
19 }
",Exception object[edit],code_fragment
1932,"Note that when b equals zero, there is no return value. Instead of a java.lang.ArithmeticException generated by the Java interpreter itself, it is an exception created by the coder. The result is the same. It shows you that an exception is an object. Its main particularity is that it can be thrown. An exception object must inherit from java.lang.Exception. Standard exceptions have two constructors:
",Exception object[edit],plain_text
1933,"1 new Exception();
",Exception object[edit],code_fragment
1934,"1 new Exception(""Something unexpected happened"");
",Exception object[edit],code_fragment
1935,"This string can later be extracted using various methods, as you can see in the code listing 6.2.
",Exception object[edit],plain_text
1936,"You can throw any type of Throwable object using the keyword throw. It interrupts the method. Anything after the throw statement would not be executed, unless the thrown exception is handled. The exception object is not returned from the method, it is thrown from the method. That means that the exception object is not the return value of the method and the calling method can be interrupted too and so on and so on...
",Exception object[edit],plain_text
1937,"Typically, you'll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.
",Exception object[edit],plain_text
1938,"The box 6.1 below talks about the various exception classes within the java.lang package.
",Exception object[edit],plain_text
1939,,try/catch statement[edit],
1940,"By default, when an exception is thrown, the current method is interrupted, the calling method is interrupted too and so on till the main method. A thrown exception can also be caught using a
try/catch statement. Below is how a try/catch statement works:
",try/catch statement[edit],plain_text
1941," 1 int a = 4;
 2 int b = 2;
 3 int result = 0;
 4 try {
 5   int c = a / b;
 6   result = c;
 7 } catch(ArithmeticException ex) {
 8   result = 0;
 9 }
10 return result;
",try/catch statement[edit],code_fragment
1942,"The executed code lines have been highlighted. When no exception is thrown, the method flow executes the try statement and not the catch statement.
",try/catch statement[edit],plain_text
1943," 1 int a = 4;
 2 int b = 0;
 3 int result = 0;
 4 try {
 5   int c = a / b;
 6   result = c;
 7 } catch(ArithmeticException ex) {
 8   result = 0;
 9 }
10 return result;
",try/catch statement[edit],code_fragment
1944,"As there is a thrown exception at line 5, the line 6 is not executed, but the exception is caught by the catch statement so the catch block is executed. The following code is also executed. Note that the catch statement takes an exception as parameter. There is a third case: when the exception is not from the same class as the parameter:
",try/catch statement[edit],plain_text
1945," 1 int a = 4;
 2 int b = 0;
 3 int result = 0;
 4 try {
 5   int c = a / b;
 6   result = c;
 7 } catch(NullPointerException ex) {
 8   result = 0;
 9 }
10 return result;
",try/catch statement[edit],code_fragment
1946,"It is as if there is no try/catch statement. The exception is thrown to the calling method.
",try/catch statement[edit],plain_text
1947,,catch blocks[edit],
1948,"A try/catch statement can contain several catch blocks, to handle different exceptions in different ways. Each catch block must take a parameter of a different throwable class. A thrown object may match several catch block but only the first catch block that matches the object will be executed. A catch-block will catch a thrown exception if and only if:
",catch blocks[edit],plain_text
1949,"the thrown exception object is the same as the exception object specified by the catch-block.
the thrown exception object is the subtype of the exception object specified by the catch-block.",catch blocks[edit],plain_text
1950,"This means that the catch block order is important. As a consequence, you can't put a catch block that catches all the exception (which take a java.lang.Exception as parameter) before a catch block that catches a more specific exception as the second block could never be executed.
",catch blocks[edit],plain_text
1951," 1 try {
 2   // Suppose the code here throws any exceptions,
 3   // then each is handled in a separate catch block.
 4 
 5   int[] tooSmallArray = new int[2];
 6   int outOfBoundsIndex = 10000;
 7   tooSmallArray[outOfBoundsIndex] = 1;
 8 
 9   System.out.println(""No exception thrown."");
10 } catch(NullPointerException ex) {
11   System.out.println(""Exception handling code for the NullPointerException."");
12 } catch(NumberFormatException ex) {
13   System.out.println(""Exception handling code for the NumberFormatException."");
14 } catch(ArithmeticException | IndexOutOfBoundsException ex) {
15   System.out.println(""Exception handling code for ArithmeticException""
16     + "" or IndexOutOfBoundsException."");
17 } catch(Exception ex) {
18   System.out.println(""Exception handling code for any other Exception."");
19 }
",catch blocks[edit],code_fragment
1952,"At line 14, we use a multi-catch clause. It is available since the JDK 7. This is a combination of several catch clauses and let's you handle exceptions in a single handler while also maintaining their types. So, instead of being boxed into a parent Exception super-class, they retain their individual types.
",catch blocks[edit],plain_text
1953,"You can also use the java.lang.Throwable class here, since Throwable is the parent class for the application-specific Exception classes. However, this is discouraged in Java programming circles. This is because Throwable happens to also be the parent class for the non-application specific Error classes which are not meant to be handled explicitly as they are catered for by the JVM itself.
",catch blocks[edit],plain_text
1954,,finally block[edit],
1955,"A finally block can be added after the catch blocks. A finally block is always executed, even when no exception is thrown, an exception is thrown and caught, or an exception is thrown and not caught. It's a place to put code that should always be executed after an unsafe operation like a file close or a database disconnection. You can define a try block without catch block, however, in this case, it must be followed by a finally block.
",finally block[edit],plain_text
1956,,Example of handling exceptions[edit],
1957,"Let's examine the following code:
",Example of handling exceptions[edit],plain_text
1958," 1 public void methodA() throws SomeException {
 2     // Method body
 3 }
 4 
 5 public void methodB() throws CustomException, AnotherException {
 6     // Method body
 7 }
 8 
 9 public void methodC() {
10     methodB();
11     methodA();
12 }
",Example of handling exceptions[edit],code_fragment
1959,"In the code section 6.7, methodC is invalid.  Because methodA and methodB pass (or throw) exceptions, methodC must be prepared to handle them.  This can be handled in two ways: a try-catch block, which will handle the exception within the method and a throws clause which would in turn throw the exception to the caller to handle.  The above example will cause a compilation error, as Java is very strict about exception handling. So the programmer is forced to handle any possible error condition at some point.
",Example of handling exceptions[edit],plain_text
1960,"A method can do two things with an exception: ask the calling method to handle it by the throws declaration or handle the exception inside the method by the try-catch block.
",Example of handling exceptions[edit],plain_text
1961,"To work correctly, the original code can be modified in multiple ways.  For example, the following:
",Example of handling exceptions[edit],plain_text
1962,"1 public void methodC() throws CustomException, SomeException {
2   try {
3     methodB();
4   } catch(AnotherException e) {
5     // Handle caught exceptions.
6   }
7   methodA();
8 }
",Example of handling exceptions[edit],code_fragment
1963,"The AnotherException from methodB will be handled locally, while CustomException and SomeException will be thrown to the caller to handle it. Most of the developers are embarrassed when they have to choose between the two options. This type of decision should not be taken at development time. If you are a development team, it should be discussed between all the developers in order to have a common exception handling policy.
",Example of handling exceptions[edit],plain_text
1964,,Keyword references[edit],
1965,"try
catch
finally
throws
throw",Keyword references[edit],plain_text
1966,"
",Keyword references[edit],plain_text
1967,"
A checked exception is a type of exception that must be either caught or declared in the method in which it is thrown. For example, the java.io.IOException is a checked exception. To understand what is a checked exception, consider the following code:
",Checked exceptions,plain_text
1968,"1 public void ioOperation(boolean isResourceAvailable) {
2   if (!isResourceAvailable) {
3     throw new IOException();
4   }
5 }
",Checked exceptions,code_fragment
1969,"This code won't compile because it can throw a checked exception. The compilation error can be resolved in either of two ways: By catching the exception and handling it, or by declaring that the exception can be thrown using the throws keyword.
",Checked exceptions,plain_text
1970,"1 public void ioOperation(boolean isResourceAvailable) {
2   try {
3     if (!isResourceAvailable) {
4       throw new IOException();
5     }
6   } catch(IOException e) {
7     // Handle caught exceptions.
8   }
9 }
",Checked exceptions,code_fragment
1971,"In the Java class hierarchy, an exception is a checked exception if it inherits from java.lang.Throwable, but not from java.lang.RuntimeException or java.lang.Error. All the application or business logic exceptions should be checked exceptions.
",Checked exceptions,plain_text
1972,"It is possible that a method declares that it can throw an exception, but actually it does not. Still, the caller has to deal with it. The checked exception declaration has a domino effect. Any methods that will use the previous method will also have to handle the checked exception, and so on.
",Checked exceptions,plain_text
1973,"So the compiler for the Java programming language checks, at compile time, that a program contains handlers for all application exceptions, by analyzing each method body. If, by executing the method body, an exception can be thrown to the caller, that exception must be declared. How does the compiler know whether a method body can throw an exception? That is easy. Inside the method body, there are calls to other methods; the compiler looks at each of their method signature, what exceptions they declared to throw.
",Checked exceptions,plain_text
1974,,Why Force Exception Handling?[edit],
1975,"This may look boring to the developer but it forces them to think about all the checked exceptions and increase the code quality. This compile-time checking for the presence of exception handlers is designed to make the application developer life easier. To debug whether a particular thrown exception has a matching catch would be a long process. In conventional languages like C, and C++, a separate error handling debugging were needed. In Java we can be sure that when an application exception is thrown, that exception somewhere in the program is handled. In C, and C++, that has to be tested. In Java that does not need to be tested, so the freed up time can be used for more meaningful testing, testing the business features.
",Why Force Exception Handling?[edit],plain_text
1976,,What Exceptions can be Declared when Overriding a Method?[edit],
1977,"The checked exception classes specified after the throws keyword are part of the contract between the implementer and user. An overriding method can declare the same exceptions, subclasses or no exceptions.
",What Exceptions can be Declared when Overriding a Method?[edit],plain_text
1978,,What Exceptions can be Declared when Implementing an Interface?[edit],
1979,"JAVA 1.8 onwards: When interfaces are involved, the implementation declaration may skip a throws-clause but if one wish to have then should be compatible with the interface declarations. In other words, the implementation should throw the declared exception or it's sub-type or no exception.
",What Exceptions can be Declared when Implementing an Interface?[edit],plain_text
1980,"Prior to Java 1.8: The implementer must declare same exception or its subclass.  
",What Exceptions can be Declared when Implementing an Interface?[edit],plain_text
1981,"
",What Exceptions can be Declared when Implementing an Interface?[edit],plain_text
1982,"
Unchecked, uncaught or runtime exceptions are exceptions that can be thrown without being caught or declared:
",Unchecked exceptions,plain_text
1983,"1 public void futureMethod() {
2   throw new RuntimeException(""This method is not yet implemented"");
3 }
",Unchecked exceptions,code_fragment
1984,"...however, you can still declare and catch such exceptions. Runtime exceptions are not business exceptions. They are usually related to hard-coded issues like data errors, arithmetic overflow, divide by zero etc. In other words, errors that can't be worked around nor anticipated. The most famous (and feared) runtime exception is the NullPointerException.
",Unchecked exceptions,plain_text
1985,"A runtime exception must be or inherit from the RuntimeException class or the Error class.
",Unchecked exceptions,plain_text
1986,"Sometime it is desirable to catch all exceptions for logging purposes, then throw them back in. For example, in servlet programming when an application server calls the server getLastModified(), we want to monitor that no exceptions happened during the serving of the request. The application has its own logging separate from the server logging so the runtime exceptions would just go through without being detected by the application. The following code checks all exceptions, logs them and throws them back again.
",Unchecked exceptions,plain_text
1987," 1 public long getLastModified(HttpServletRequest req) {
 2   try {
 3     ...
 4     return getTimeStamp();
 5     ...
 6   } catch(RuntimeException e) {
 7     log.error(""Error during handling post request"", e);
 8 
 9     throw e;
10   }
11 }
",Unchecked exceptions,code_fragment
1988,"In the above code, all business logic exception are handled in the getTimeStamp() method. Runtime exceptions are caught for logging purposes, and then thrown back to the server to be handled.
",Unchecked exceptions,plain_text
1989,"
",Unchecked exceptions,plain_text
1990,"
NullPointerException is a RuntimeException. In Java, a special null value can be assigned to an object reference.
NullPointerException is thrown when an application attempts to use an object reference that has the null value.
These include:
",Preventing NullPointerException,plain_text
1991,"Calling an instance method on the object referred by a null reference.
Accessing or modifying an instance field of the object referred by a null reference.
If the reference type is an array type, taking the length of a null reference.
If the reference type is an array type, accessing or modifying the slots of a null reference.
If the reference type is a subtype of Throwable, throwing a null reference.",Preventing NullPointerException,plain_text
1992,"Applications should throw instances of this class to indicate other illegal uses of the null object.
",Preventing NullPointerException,plain_text
1993,"1 Object obj = null;
2 obj.toString();  // This statement will throw a NullPointerException
",Preventing NullPointerException,code_fragment
1994,"The above code shows one of the pitfalls of Java and the most common source of bugs. No object is created and the compiler does not detect it. NullPointerException is one of the most common exceptions thrown in Java.
",Preventing NullPointerException,plain_text
1995,,Why do we need null?[edit],
1996,"The reason we need it is because many times we need to create an object reference before the object itself is created. Object references cannot exist without a value, so we assign the null value to it.
",Why do we need null?[edit],plain_text
1997,"1 public Person getPerson(boolean isWoman) {
2   Person person = null;
3   if (isWoman) {
4     person = createWoman();
5   } else {
6     person = createMan();
7   }
8   return person;
9 }
",Why do we need null?[edit],code_fragment
1998,"In code section 6.14 we want to create the Person inside the if-else, but we also want to return the object reference to the caller, so we need to create the object reference outside of the if-else, because of the scoping rule in Java. Incorrect error-handling and poor contract design can be a pitfall with any programming language. This is also true for Java.
",Why do we need null?[edit],plain_text
1999,"Now we will describe how to prevent NullPointerException. We do not describe general techniques for how you should program Java, we just hope to make you more aware of null values, and to be more careful about generating them yourself.
",Why do we need null?[edit],plain_text
2000,"This list is not complete — there are no rules for preventing NullPointerException entirely in Java, because the standard libraries have to be used, and they can cause NullPointerExceptions.  Also, it is possible to observe an uninitialized final field in Java, so you can't even treat a final field as being completely trusted during the object's creation.
",Why do we need null?[edit],plain_text
2001,"A good approach is to learn how to deal with NullPointerExceptions first, and become competent with that.  These suggestions will help you to cause less NullPointerExceptions, but they don't replace the need to know about NullPointerExceptions.
",Why do we need null?[edit],plain_text
2002,,Comparing string variable with a string literal[edit],
2003,"When you compare a variable with a string literal, most of people would do that this way:
",Comparing string variable with a string literal[edit],plain_text
2004,"1 if (state.equals(""OK"")) {
2   ...
3 }
",Comparing string variable with a string literal[edit],code_fragment
2005,"Always put the string literal first:
",Comparing string variable with a string literal[edit],plain_text
2006,"1 if (""OK"".equals(state)) {
2   ...
3 }
",Comparing string variable with a string literal[edit],code_fragment
2007,"If the state variable is null, you get a NullPointerException in the first example, but not in the second one.
",Comparing string variable with a string literal[edit],plain_text
2008,,Minimize the use of the keyword 'null' in assignment statements[edit],
2009,"This means not doing things like:
",Minimize the use of the keyword 'null' in assignment statements[edit],plain_text
2010," 1 String s = null;
 2 while (something) {
 3     if (something2) {
 4         s = ""yep"";
 5     }
 6 }
 7 
 8 if (s != null) {
 9     something3(s);
10 }
",Minimize the use of the keyword 'null' in assignment statements[edit],code_fragment
2011,"You can replace this with:
",Minimize the use of the keyword 'null' in assignment statements[edit],plain_text
2012,"1 boolean done = false;
2 
3 while (!done && something) {
4     if (something2) {
5        done = true;
6        something3(""yep"");
7     }
8 }
",Minimize the use of the keyword 'null' in assignment statements[edit],code_fragment
2013,"You might also consider replacing null with """" in the first example, but default values bring about bugs caused by default values being left in place.  A NullPointerException is actually better, as it allows the runtime to tell you about the bug, rather than just continue with a default value.
",Minimize the use of the keyword 'null' in assignment statements[edit],plain_text
2014,,Minimize the use of the new Type[int] syntax for creating arrays of objects[edit],
2015,"An array created using new Object[10] has 10 null pointers.  That's 10 more than we want, so use collections instead, or explicitly fill the array at initialization with:
",Minimize the use of the new Type[int] syntax for creating arrays of objects[edit],plain_text
2016,"1 Object[] objects = {""blah"", 5, new File(""/usr/bin"")};
",Minimize the use of the new Type[int] syntax for creating arrays of objects[edit],code_fragment
2017,"or:
",Minimize the use of the new Type[int] syntax for creating arrays of objects[edit],plain_text
2018,"1 Object[] objects;
2 objects = new Object[]{""blah"", 5, new File(""/usr/bin"")};
",Minimize the use of the new Type[int] syntax for creating arrays of objects[edit],code_fragment
2019,,Check all references obtained from 'untrusted' methods[edit],
2020,"Many methods that can return a reference null reference.  Make sure you check these.  For example:
",Check all references obtained from 'untrusted' methods[edit],plain_text
2021,"1 File file = new File(""/etc"");
2 File[] files = file.listFiles();
3 if (files != null) {
4     stuff
5 }
",Check all references obtained from 'untrusted' methods[edit],code_fragment
2022,"File.listFiles() can return null if /etc is not a directory.
",Check all references obtained from 'untrusted' methods[edit],plain_text
2023,"You can decide to trust some methods not to return null, if you like, but that's an assumption you're making.  Some methods that don't specify that they might return null, actually do, instead of throwing an exception.
",Check all references obtained from 'untrusted' methods[edit],plain_text
2024,,For each loop trap[edit],
2025,"Beware if you loop on an array or a collection in a for each loop.
",For each loop trap[edit],plain_text
2026,"1 Collection<Integer> myNumbers = buildNumbers();
2 for (Integer myNumber : myNumbers) {
3   System.out.println(myNumber);
4 }
",For each loop trap[edit],code_fragment
2027,"If the object is null, it does not just do zero loops, it throws a null pointer exception. So don't forget this case. Add an if statement or return empty collections:
",For each loop trap[edit],plain_text
2028,"1 Collection<Integer> myNumbers = buildNumbers();
2 if (myNumbers != null) {
3   for (Integer myNumber : myNumbers) {
4     System.out.println(myNumber);
5   }
6 }
",For each loop trap[edit],code_fragment
2029,,External tools[edit],
2030,"There are tools like FindBugs that parse your code and warn you about potential bugs. Most of the time, these tools detect possible null pointers.
",External tools[edit],plain_text
2031,"
",External tools[edit],plain_text
2032,"
Stack Trace is a list of method calls from the point when the application was started to the point where the exception was thrown. The most recent method calls are at the top.
",Stack trace,plain_text
2033," 1 public class StackTraceExample {
 2   public static void main(String[] args) {
 3     method1();
 4   }
 5 
 6   public static void method1() {
 7     method11();
 8   }
 9 
10   public static void method11() {
11     method111();
12   }
13 
14   public static void method111() {
15     throw new NullPointerException(""Fictitious NullPointerException"");
16   }
17 }
",Stack trace,code_fragment
2034,"The stack trace can be printed to the standard error by calling the public void printStackTrace() method of an exception.
",Stack trace,plain_text
2035,"From Java 1.4, the stack trace is encapsulated into an array of a java class called java.lang.StackTraceElement.
The stack trace element array returned by Throwable.getStackTrace() method. Each element represents a single stack frame. All stack frames except for the one at the top of the stack represent a method invocation. The frame at the top of the stack represents the execution point at which the stack trace was generated. Typically, this is the point at which the throwable corresponding to the stack trace was created.
",Stack trace,plain_text
2036,"A stack frame represents the following information:
",Stack trace,plain_text
2037,"1 public StackTraceElement(String declaringClass,
2                          String methodName,
3                          String fileName,
4                          int lineNumber);
",Stack trace,code_fragment
2038,"Creates a stack trace element representing the specified execution point.
",Stack trace,plain_text
2039,,Converting the stack trace into string[edit],
2040,"Many times for debugging purposes, we'd like to convert the stack trace to a String so we can log it to our log file.
",Converting the stack trace into string[edit],plain_text
2041,"The following code shows how to do that:
",Converting the stack trace into string[edit],plain_text
2042," 1 import java.io.StringWriter;
 2 import java.io.PrintWriter;
 3 
 4 ...
 5 
 6   Exception e = new NullPointerException();
 7 
 8   StringWriter outError = new StringWriter();
 9   e.printStackTrace(new PrintWriter(outError));
10   String errorString = outError.toString();
11 
12   // Do whatever you want with the errorString
",Converting the stack trace into string[edit],code_fragment
2043,"
",Converting the stack trace into string[edit],plain_text
2044,"
When an exception is caught, the exception contains the stack-trace, which describes the error and shows where the exception happened (i.e. where the problem is and where the application programmer should look to fix the problem). Sometimes it is desirable to catch an exception and throw another exception. If the new exception keeps a reference to the first exception, the first exception is called a nesting exception.
",Nesting exceptions (chained exceptions),plain_text
2045," 1 public class NestingExceptionExample {
 2  
 3   public static void main(String[] args) throws Exception {
 4     Object[] localArgs = (Object[]) args;
 5    
 6     try {
 7       Integer[] numbers = (Integer[]) localArgs;
 8     } catch (ClassCastException originalException) {
 9       Exception generalException = new Exception(
10         ""Horrible exception!"",
11         originalException);
12       throw generalException;
13     }
14   }
15 }
",Nesting exceptions (chained exceptions),code_fragment
2046,"The above code is an example of a nesting exception. When the Exception is thrown, by passing in the ClassCastException object reference as a parameter, the ClassCastException is nested in the newly created Exception, its stack-trace is appended together. When the Exception is caught, its stack-trace contains the original ClassCastException's stack-trace.
",Nesting exceptions (chained exceptions),plain_text
2047,"This is a kind of exception conversion, from one exception to another. For example, calling a remote object using RMI, the calling method has to deal with RemoteException which is thrown if something is wrong during the communication. From the application point of view, RemoteException has no meaning, it should be transparent to the application that a remote object was used or not. So the RemoteException should be converted to an application exception.
",Nesting exceptions (chained exceptions),plain_text
2048,"This conversion can also hide where the error is originated. The stack-trace starts when the exception is thrown. So when we catch and throw a new exception, the stack-trace starts at when the new exception was thrown, losing the original stack-trace. This was true with the earlier version of Java (before 1.4). Since then, so called cause facility capabilities were built in the Throwable class.
",Nesting exceptions (chained exceptions),plain_text
2049,"A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a ""chain"" of exceptions, each caused by another.
",Nesting exceptions (chained exceptions),plain_text
2050,"A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the initCause(Throwable) method. New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the Throwable constructors that takes a cause. For example:
",Nesting exceptions (chained exceptions),plain_text
2051,"1 try {
2     lowLevelOp();
3 } catch (LowLevelException le) {
4     throw new HighLevelException(le);
5 }
",Nesting exceptions (chained exceptions),code_fragment
2052,"Because the initCause method is public, it allows a cause to be associated with any throwable, even a ""legacy throwable"" whose implementation predates the addition of the exception chaining mechanism to Throwable. For example:
",Nesting exceptions (chained exceptions),plain_text
2053,"1 try {
2     lowLevelOp();
3 } catch (LowLevelException le) {
4     throw (HighLevelException) new HighLevelException().initCause(le);
5 }
",Nesting exceptions (chained exceptions),code_fragment
2054,"Further, as of release 1.4, many general purpose Throwable classes (for example Exception, RuntimeException, Error) have been retrofitted with constructors that take a cause. This was not strictly necessary, due to the existence of the initCause method, but it is more convenient and expressive to delegate to a constructor that takes a cause.
",Nesting exceptions (chained exceptions),plain_text
2055,"By convention, class Throwable and its subclasses have two constructors, one that takes no arguments and one that takes a String argument that can be used to produce a detail message. Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a Throwable (the cause), and one that takes a String (the detail message) and a Throwable (the cause).
",Nesting exceptions (chained exceptions),plain_text
2056,"
",Nesting exceptions (chained exceptions),plain_text
2057,"
CPUs for any computer are designed to execute one task at any given time, yet we run multiple applications side-by-side and everything works in perfect congruence. It's not just because CPUs are extremely fast in performing calculations, it's because CPUs use a clever device of dividing their time amongst various tasks. Each application or task that is invoked on a computer gets associated with the CPU in the form of a process. A CPU therefore manages various processes, and jumps back and forth amongst each process giving it a fraction of its time and processing capability. This happens so fast that to a normal computer user it presents with the illusion of processes being run simultaneously. This capability of the CPU to divide its time amongst processes is called multitasking.
",Threads and Runnables,plain_text
2058,"So, if we run a Java application on a computer, we are effectively creating a process with the CPU that gets a fraction of the CPU's time. In Java parlance, this main process gets called the daemon process or the daemon thread. But, Java goes one step further. It allows programmers to divide this daemon thread into several multiple threads which get executed simultaneously (much like a CPU) hence providing a Java application with a finer multitasking capability called multithreading.
",Threads and Runnables,plain_text
2059,"In this section, we will take a look at what threads are and how multithreading is implemented within a Java program to make it appear congruent and effectively fast to respond.
",Threads and Runnables,plain_text
2060,,Threads[edit],
2061,"In light of the above discussion, a thread is the smallest unit of processing that can be scheduled by an operating system. Therefore, using threads, a programmer can effectively create two or more tasks[1] that run at the same time. The first call-to-action is to implement a set of tasks that a particular thread would execute. To do so, we require the creation of a Runnable process.
",Threads[edit],plain_text
2062,"A Runnable process block is a simple class that implements a run() method. Within the run() method is the actual task that needs to be executed by a running thread. By implementing a class with the Runnable interface, we ensure that the class holds a run() method. Consider the following program:
",Threads[edit],plain_text
2063,"import java.util.Random;
public class RunnableProcess implements Runnable {
    private String name;
    private int time;
    private Random rand = new Random();

    public RunnableProcess(String name) {
        this.name = name;
        this.time = rand.nextInt(999);
    }

    public void run() {
        try {
            System.out.printf(""%s is sleeping for %d \n"", this.name, this.time);
            Thread.sleep(this.time);
            System.out.printf(""%s is done.\n"", this.name);
        } catch(Exception ex) {
            ex.printStackTrace();
        }
    }
}
",Threads[edit],code_fragment
2064,"In the above code, we create a class called RunnableProcess and implement the Runnable interface to ensure that we have a run() method in the class declaration.
",Threads[edit],plain_text
2065,"public class RunnableProcess implements Runnable {
    ...
    public void run() {
        ...
    }
}
",Threads[edit],code_fragment
2066,"We then declare the rest of the logic for the class. For the constructor, we take a String parameter that would serve as the name of the class. Then, we initialize the class member variable time with a random number between 0 and 999. To ensure the initialization of a random number, we use the Random class in the java.util package.
",Threads[edit],plain_text
2067,"import java.util.Random;
...
private Random rand = new Random();
...
this.time = rand.nextInt(999);
",Threads[edit],code_fragment
2068,"The actual task that would be executed per this runnable block is presented within the run() method. To keep safe from exceptions occurring because of the concurrent programming, we wrap the code within this method with a try..catch block. The executing task actually consists of just three statements. The first outputs the provided name for the Runnable process, and the last reports that the thread has executed. Perhaps the most intriguing part of the code is the second statement: Thread.sleep(...).
",Threads[edit],plain_text
2069,"...
System.out.printf(""%s is sleeping for %d \n"", this.name, this.time);
Thread.sleep(this.time);
System.out.printf(""%s is done \n"", this.name);
...
",Threads[edit],code_fragment
2070,"This statement allows the thread executing the current runnable block to halt its execution for the given amount of time. This time is presented in milliseconds. But for our convenience, this time would be the random number generated in the constructor and can be anywhere between 0 and 999 milliseconds. We will explore this in a later section. Creating a Runnable process block is just the beginning. No code is actually executed. To do so, we would require the creation of threads that would then individually execute this task.
",Threads[edit],plain_text
2071,"Once we have a Runnable process block, we can create various threads that can then execute the logic encased within such blocks. Multithreading capabilities in Java are utilized and manipulated using the Thread class. A Thread object therefore holds all the necessary logic and devices to create truly multithreaded programs. Consider the following program:
",Threads[edit],plain_text
2072,"public class ThreadLogic {
    public static void main(String[] args) {
        Thread t1 = new Thread(new RunnableProcess(""Thread-1""));
        Thread t2 = new Thread(new RunnableProcess(""Thread-2""));
        Thread t3 = new Thread(new RunnableProcess(""Thread-3""));
    }
}
",Threads[edit],code_fragment
2073,"Creating threads is as simple as the above program suggests. You just have to create an object of the Thread class and pass a reference to a Runnable process object. In the case above, we present the Thread constructor with the class object for the RunnableProcess class that we created in code listing 1. But for each object, we give a different name (i.e., ""Thread-1"" and ""Thread-2"", etc.) to differentiate between the three Thread objects. The above example only declares Thread objects and hasn't yet started them for execution.
",Threads[edit],plain_text
2074,"Now, that we know how to effectively create a Runnable process block and a Thread object that executes it, we need to understand how to start the created Thread objects. This couldn't be simpler. For this process, we will be calling the start() method on the Thread objects and voilà, our threads will begin executing their individual process tasks.
",Threads[edit],plain_text
2075,"public class ThreadLogic {
    public static void main(String[] args) {
        Thread t1 = new Thread(new RunnableProcess(""Thread-1""));
        Thread t2 = new Thread(new RunnableProcess(""Thread-2""));
        Thread t3 = new Thread(new RunnableProcess(""Thread-3""));

        t1.start();
        t2.start();
        t3.start();
    }
}
",Threads[edit],code_fragment
2076,"The above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.
",Threads[edit],plain_text
2077,"It should be noted that the execution of the Thread didn't occur in the desired order. Instead of the order t1–t2–t3, the threads executed in the order of t1–t3–t2. The order in which the threads are executed is completely dependent on the operating system and may change for every execution of the program, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using the Thread.sleep(...) function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time was t2 (""Thread-2"") with 189 milliseconds of sleep hence it got called first. Then t1 was called and finally t3 was called.
",Threads[edit],plain_text
2078,,Manipulating threads[edit],
2079,"It can be said that the execution order of the threads was manipulated to some degree using the Thread.sleep(...) method. The Thread class has such static methods that can arguably affect the execution order and manipulation of threads. Below are some useful static methods in the Thread class. These methods when called will only affect the currently running threads.
",Manipulating threads[edit],plain_text
2080,,Synchronization[edit],
2081,"Given below is an example of creating and running multiple threads that behave in a synchronous manner such that when one thread is using a particular resource, the others wait until the resource has been released. We will talk more about this in later sections.
",Synchronization[edit],plain_text
2082,"public class MultiThreadExample {
    public static boolean cthread;
    public static String stuff = "" printing material"";

    public static void main(String args[]) {
        Thread t1 = new Thread(new RunnableProcess());
        Thread t2 = new Thread(new RunnableProcess());
        t1.setName(""Thread-1"");
        t2.setName(""Thread-2"");
        t2.start();
        t1.start();
    }
    /*
     * Prints information about the current thread and the index it is
     * on within the RunnableProcess
     */
    public static void printFor(int index) {
        StringBuffer sb = new StringBuffer();
        sb.append(Thread.currentThread().getName()).append(stuff);
        sb.append("" for the "").append(index).append("" time."");
        System.out.print(sb.toString());
    }
}
class RunnableProcess implements Runnable {
    public void run() {
        for(int i = 0; i < 10; i++) {
            synchronized(MultiThreadExample.stuff) {
                MultiThreadExample.printFor(i);
                try {
               	    MultiThreadExample.stuff.notifyAll();
                    MultiThreadExample.stuff.wait();
                } catch(InterruptedException ex) {
                   ex.printStackTrace();
                }
            }
        }
    }
}
",Synchronization[edit],code_fragment
2083,,Where are threads used?[edit],
2084,"Threads are used intensively in applications that require a considerable amount of CPU usage. For operations that are time-consuming and intensive, it is usually advised to use threads. An example of such an application would be a typical video game. At any given time, a video game involves various characters, objects in the surroundings and other such nuances that needs to be dealt with simultaneously. Dealing with each element or object within the game requires a fair amount of threads to monitor every object.
",Where are threads used?[edit],plain_text
2085,"For example, take this screen-shot of a role-playing strategy game on the right. Here the game visuals depict various in-game characters moving about on the screen. Now imagine processing the movements, direction and behaviors of each of the characters visible on screen. It would certainly take a lot of time moving each character one-by-one if this were to be done one task after another. However if fundamentals of multi-threading are employed, each character would move in a synchronous manner with respect to others.
",Where are threads used?[edit],plain_text
2086,"Threads are not only used heavily in video games, their use is common in everything from simple browser applications to complex operating systems and networking applications. Today it often goes beyond the simple preference of the developer but into the need to maximize the usefulness of contemporaneous hardware that is predicated in heavy multitasking.
",Where are threads used?[edit],plain_text
2087,,References[edit],
2088,"Daemon thread tutorial
",References[edit],plain_text
2089,"
In a multi-threaded environment, when more than one thread can access and modify a resource, the outcome could be unpredictable.  For example, let's have a counter variable that is incremented by more than one thread.
",Basic Synchronization,plain_text
2090,"Beware! Synchronization is an ambiguous term. It doesn't consist of making all threads executing the same code section at the same time. It is the opposite. It prevents any two threads from executing the same code section at the same time. It synchronizes the end of one processing with the beginning of a second processing.
",Basic Synchronization,plain_text
2091,"int counter = 0;
...
counter += 1;
",Basic Synchronization,code_fragment
2092,"The above code is built up by the following sub-operations:
",Basic Synchronization,plain_text
2093,"Read ; read variable counter
Add ; add 1 to the value
Save ; save the new value to variable counter",Basic Synchronization,plain_text
2094,"Let's say that two threads need to execute that code, and if the initial value of the counter variable is zero, we expect after the operations the value to be 2.
",Basic Synchronization,plain_text
2095,"In the above case Thread 1 operation is lost, because Thread 2 overwrites its value. We'd like Thread 2 to wait until Thread 1 finishes the operation. See below:
",Basic Synchronization,plain_text
2096,"
",Basic Synchronization,plain_text
2097,"
",Basic Synchronization,plain_text
2098,"
",Basic Synchronization,plain_text
2099,"
In 1990s, the trend was moving away from Mainframe computing to Client/Server as the price of Unix servers dropped. The database access and some business logic were centralized on the back-end server, collecting data from the user program was installed on the front-end users' ""client"" computers. In the Java world there are three main ways the front-end and the back-end can communicate. 
",Client Server Programming,plain_text
2100,"The client application uses JDBC (Java DataBase Connectivity API) to connect to the data base server, (Limited business logic on the back-end, unless using Stored procedures).
The client application uses RMI (Remote Method Invocation) to communicate with the back-end.
The client application uses a socket connection to communicate with the back-end.",Client Server Programming,plain_text
2101,,Socket Connection Example[edit],
2102,"This page shows an example of a socket connection.
",Socket Connection Example[edit],plain_text
2103,"The Java language was developed having network computing in mind. For this reason it is very easy to create a server program. A server is a piece of code that runs all the time listening on a particular port on the computer for incoming requests. When a request arrives, it starts a new thread to service the request.
See the following example:

",Socket Connection Example[edit],plain_text
2104,"import java.net.ServerSocket;
/**
 * -- Main Server Class; Listening on a port for client; If there is a client,
 * starts a new Thread and goes back to listening for further clients. --
 */
public class ComServer 
{
static boolean  GL_listening = true;
   /**
    * -- Main program to start the Server --
    */
   public static void main(String[] args) throws IOException
   {
      ComServer srv = new ComServer();
      srv.listen(); 
   } // --- End of Main Method ---

   /**
    * -- Server method; Listen for client --
    */
   public int listen() throws IOException
   {
    ServerSocket serverSocket = null;
    int iPortNumber = 9090;

       // --- Open the Server Socket where this should listen ---
       try {
           System.out.println( ""*** Open the listening socket; at:""+ iPortNumber + "" ***"" );
           serverSocket = new ServerSocket( iPortNumber );
       } catch (IOException e) {
           System.err.println(""Could not listen on port:""+iPortNumber );
           System.exit(1);
       }
       while ( GL_listening )
       {
        ComServerThread clientServ; 
           // --- Listening for client; If there is a client start a Thread -
           System.out.println( ""*** Listen for a Client; at:""+ iPortNumber + "" ***"" );
           clientServ = new ComServerThread( serverSocket.accept() );
           // --- Service a Client ---
           System.out.println( ""*** A Client came; Service it ***"" );
           clientServ.start();   /* --- Use for multy Threaded --- */
      //     clientServ.run();    /* --- Use for Single Threaded --- */
       }

       // --- Close the Server socket;  Server exiting ---
       serverSocket.close();
    return 0;
   } // --- End of listen Method --- 
}  // --- End of ComServer Class ---
",Socket Connection Example[edit],code_fragment
2105," /**
  * -- A class extended from a Thread; Responsible to service one client --
  */
 class '''ComServerThread''' extends Thread
 {
    private Socket clientSocket = null;
    COM_DATA tDataFromClient;
    COM_DATA tDataToClient; 
    ObjectInputStream oIn;
    ObjectOutputStream oOut;
    /**
     * -- Constructor --
     */
    public ComServerThread( Socket socket )
    {
       super( ""ComServerThread"" );
       this.clientSocket = socket;
    } // -- End of ComServerThread() constructor --
    /**
     * -- Overrun from the Thread (super) class --
     */
    public void run()
    {
       try {
          // --- Create the Writer; will be used to send data to client ---
          oOut = new ObjectOutputStream( clientSocket.getOutputStream() );
          // --- Create the Reader; will be used to get data from client ---
          oIn  = new ObjectInputStream( clientSocket.getInputStream() );
          // --- Create a new protocol object ---
          ComProtocol comp = new ComProtocol();
          // --- Send something to client to indicate that server is ready ---
          tDataToClient  = '''comp.processInput( null );'''
          '''sendDataToClient'''( tDataToClient, oOut );
          // --- Get the data from the client ---
          while ( true )
          {
             try {
                tDataFromClient = '''getDataFromClient( oIn )''';
                // --- Parse the request and get the reply ---
                tDataToClient = '''comp.processInput( tDataFromClient );'''
                // --- Send data to the Client ---
                '''sendDataToClient'''( tDataToClient, oOut );
             }
             catch ( EOFException e ) {
                System.out.println( ""Client Disconnected, Bye, Bye"" );
                break;
             }
             // --- See if the Client wanted to terminate the connection ---
             if ( tDataToClient.bExit )
             {
                System.out.println( ""Client said Bye. Bye"" );
                break;
             }
          }
          // --- Close resources;  This client is gone ---
          comp.Final();
          oOut.close();
          oIn.close();
          clientSocket.close();
       } catch ( IOException e ) {
        e.printStackTrace();
       }
    } // -- End of run() Method --
    /**
     * Get data from Client 
     */
    private static COM_DATA '''getDataFromClient'''( ObjectInputStream oIn ) throws IOException                                                                         
    {
        COM_DATA  tDataFromClient = null;         
        // --- Initialize variables ---
        //   tDataFromClient = new COM_DATA();
        while ( tDataFromClient == null )
        {
           try {
              // --- Read Line Number first --
              tDataFromClient = (COM_DATA) oIn.readObject();
           } catch ( ClassNotFoundException e ) {
               System.out.println( ""ClassNotFound"" );
           }
        }
        System.out.println( ""Get: "" + tDataFromClient.comData );
     return tDataFromClient;
    } // --- getDataFromClient() Method --- 
    /**
     * Send data to Client 
     */
    private static void '''sendDataToClient'''( COM_DATA tDataToClient,
                                           ObjectOutputStream  oOut ) throws IOException
    {         
        System.out.println( ""Sent: "" + tDataToClient.comData );
        oOut.writeObject( tDataToClient );
      return;
    } // -- End of sendDataToClient() Method --
 } // --- End of ComServerThread class ---
",Socket Connection Example[edit],code_fragment
2106," class '''ComProtocol'''
 {
  private static final int COM_STATUS_WAITING    = 0; 
  private static final int COM_STATUS_READY_SENT = 1;
  private static final int COM_STATUS_DATA_SENT  = 2;
  private static final int COM_STATUS_WAITING_FOR_TERMINALID = 3;
  private int state = COM_STATUS_WAITING;
  
  // --- Reference to 'BACK-END' module ---  
  private MqTeAccess mqTe;
  ...
    /**
     * Create a protokol object; CAll MQ INI function
     */
    public ComProtocol()
    {
     int    iRet = 0;
        // --- Initialize 'BACK-END' modules  ---
        mqTe. ...
 ...
    }
    /**
     * --- Process the Input and Create the output to the Client ---
     */
    public COM_DATA processInput( COM_DATA theInput )
    {
     COM_DATA theOutput;
        // --- Initialize Variables ---
        theOutput = new COM_DATA();
        // --- Check if the Clients want to disconnect ---
        if ( theInput != null ) 
        {
            if ( theInput.comData.equals('''""!BYE.@""''') )
            {
                // --- The Client wants to terminate; Echo data back to client
                theOutput.comData = ""BYE."";
                // --- Mark the communication to be terminated ---
                theOutput.bExit = true;
                // --- Set the internal state to wait for a new client ---
                state = COM_STATUS_WAITING;
                // --- Return Data object to be sent to the client ---
                return theOutput;
            }
            if ( theInput.comData.equals('''""!SHUTDOWN.@""''') )
            {
                // --- The Client wants to terminate; Echo data back to client
                theOutput.comData = ""BYE."";
                // --- Mark the communication to be terminated ---
                theOutput.bExit = true;
                // --- Tell the server to stop listening for new clients ---
                ComServer.GL_listening = false;
                // --- Set the internal state to wait for a new client ---
                state = COM_STATUS_WAITING;
                // --- Return Data object to be sent to the client ---
                return theOutput;
            }
        }
        if ( state == COM_STATUS_WAITING )
        {
            // --- Send ready Message to the Client ---
            theOutput.comData = ""Ready:"";
            // --- Set the internal state ready; and wait for TerminalId ---
            state = COM_STATUS_WAITING_FOR_TERMINALID;
        }
        else if ( state == COM_STATUS_WAITING_FOR_TERMINALID )
        {
         int iRet;
            // --- Get the Terminal ID ---
            sTermId = theInput.comData; 
            // --- Call 'BACK-END' modules ...  ---
            mqTe. ...
 ...
            // --- Send ready Message with the Server Version to the Client ---
            theOutput.comData = ""Ready;Server Version 1.0:"";
            // --- Set the internal state raedy; and wait for TerminalId ---
            state = COM_STATUS_READY_SENT;
        }
        else if ( state == COM_STATUS_READY_SENT )
        {
         int iRet;
            String sCommand = theInput.comData;
            // --- Call 'BACK-END' modules ...
 ...
            /*
            ** --- Check if we should get Response data ---
            */
            if ( theInput.iRet == COM_DATA.NOWAIT_FOR_RESPONSE ) {
                // -- Set the Output Value ---
                theOutput.iRet = iRet;
                theOutput.comData = """";
            }
            else {
                // --- Call 'BACK-END' modules ---
                mqTe. ...
                // --- Set the Output Value ---
                theOutput.comData    = mqTe.sResponseBuffer; 
                theOutput.iRet       = iRet;
            }
        }
     return theOutput;
    }  // --- End of Method processInput() ---
 } // --- End of ComProtocol Class Definition ---

----
",Socket Connection Example[edit],code_fragment
2107," /**
  * COM_DATA data structure 
  */
 public class COM_DATA implements Serializable
 {
  public String  comData;
  public boolean bExit;
  public int     iRet;
    /**
     * --- Constants values can be passed in in iRet to the Server ---
     */
    static final int WAIT_FOR_RESPONSE    = 0;
    static final int NOWAIT_FOR_RESPONSE  = 1;
   /**
    * Initialize the data structure
    */
   public COM_DATA()
   {
      comData     = """";
      bExit       = false;
      iRet        = 0;
   } // -- End of COM_DATA() Constructor --   
   /**
    * Copy over it contents 
    */
   public void copy( COM_DATA tSrc )
   {
      this.comData     = tSrc.comData;
      this.bExit       = tSrc.bExit;
      this.iRet        = tSrc.iRet;
    return;
   } 
 } // -- End of COM_DATA class --
",Socket Connection Example[edit],code_fragment
2108,"A client code for a server/service is usually an API that a user application uses to interface to the server. With the help of a client API the user application does not have to know how to connect to the server to get services.
",Socket Connection Example[edit],plain_text
2109,"The following is the client class for the above server:
",Socket Connection Example[edit],plain_text
2110," public class ComClient
 {
  private Socket         comSocket;
  private ObjectOutputStream oOut;
  private ObjectInputStream  oIn;
  private boolean         IsItOpen = false;       
    /**
     * --- Open Socket ---
     */
    public void openCom( String sServerName,
                         int    iPortNumber ) throws UnknownHostException,
                                                              IOException  
    {
       try {
          // --- Open Socket for communication ---
          comSocket = new Socket( sServerName, iPortNumber );     
          // --- Get Stream to write request to the Server ---
          oOut = new ObjectOutputStream( comSocket.getOutputStream() );     
          // --- Get Stream// to read from the Server
          oIn = new ObjectInputStream( comSocket.getInputStream());
          // --- Set internal Member variable that the Communication opened ---
          IsItOpen = true;
       } catch ( java.net.UnknownHostException e ) {
          System.err.println( ""(openCom:)Don't know about host: ""+sServerName );
          IsItOpen = false;
          throw( e );                                         
       } catch ( java.io.IOException e ) {
          System.err.println(""(openCom:)Couldn't get I/O for the connection to: ""+ sServerName );
          IsItOpen = false;
          throw( e );         
       }               
    }
    /**
     * --- Check if Socket is open ---
     */
    public boolean isItOpen()
    {
      return IsItOpen;
    }     
    /**
     * --- Get data string from the Server ---
     */
    public void getServerData( COM_DATA tServData ) throws IOException
    {
        // --- Initialize Variables ---
        tServData.comData = """";
        // --- Get the Response from the Server ---              
        try {
           tServData.copy( (COM_DATA) oIn.readObject() );
        }   
        catch ( ClassNotFoundException e ) {
            System.out.println( ""Class Not Found"" );
        } 
        System.out.println( ""Server: "" + tServData.comData );
        if ( tServData.comData.equals(""BYE."") )
        {
            tServData.bExit = true;
        }        
     return;
    }
    /**
     * --- Send data to the Server ---
     */
    public void sendDataToServer( COM_DATA tServData ) throws IOException
    {
        // --- Send the data string ---
        System.out.println( ""Send: "" + tServData.comData );
        oOut.writeObject( tServData );
     return;
    } 
    /**
     * --- Close Socket --- 
     */
    public void closeCom() throws IOException
    {
        oOut.close();
        oIn.close();
        comSocket.close();
        IsItOpen = false;
    }    
 }
",Socket Connection Example[edit],code_fragment
2111,"
",Socket Connection Example[edit],plain_text
2112,"
Java's Remote Method Invocation (commonly referred to as RMI) is used for client and server models. RMI is the object oriented equivalent to RPC (Remote procedure call).
",Remote Method Invocation (RMI),plain_text
2113,"The Java Remote Method Invocation (RMI) system allows an object running in one Java Virtual Machine (VM) to invoke methods of an object running in another Java VM. RMI provides for remote communication between programs written in the Java programming language.
",Remote Method Invocation (RMI),plain_text
2114,"RMI is only defined for use with the Java platform. If you need to call methods between different language environments, use CORBA. With CORBA a Java client can call a C++ server and/or a C++ client can call a Java server. With RMI that can not be done.
",Remote Method Invocation (RMI),plain_text
2115,,STUB and SKELETON[edit],
2116,"The remote method invocation goes through a STUB on the client side and a so called SKELETON on the server side.
",STUB and SKELETON[edit],plain_text
2117,"CLIENT --> STUB --> ... Network ... --> SKELETON --> REMOTE OBJECT
",STUB and SKELETON[edit],plain_text
2118,"Prior to Java 1.2 the skeleton had to be explicitly generated with the rmic tool. Since 1.2 a dynamic skeleton is used, which employs the features of Java Reflection to do its work.
",STUB and SKELETON[edit],plain_text
2119,,rmiregistry[edit],
2120,"Remote objects can be listed in the RMI Registry. Clients can get a reference to the remote object by querying the Registry. After that, the client can call methods on the remote objects. (Remote object references can also be acquired by calling other remote methods. The Registry is really a 'bootstrap' that solves the problem of where to get the initial remote reference from.)
",rmiregistry[edit],plain_text
2121,"The RMI Registry can either be started within the server JVM, via the LocateRegistry.createRegistry() API, or a separate process called rmiregistry that has to be started before remote objects can be added to it, e.g. by the command line in Unix:
",rmiregistry[edit],plain_text
2122,"or under Windows:
",rmiregistry[edit],plain_text
2123,"If port is not specified the default 1099 is used. The client will need to connect to this port to access the Registry.
",rmiregistry[edit],plain_text
2124,"The Registry can also be started from a program by calling the following code:
",rmiregistry[edit],plain_text
2125,"import java.rmi.registry.LocateRegistry;
...
Registry reg = LocateRegistry.createRegistry(iPort);
",rmiregistry[edit],code_fragment
2126,"Objects passed in as parameters to the remote objects's methods will be passed by value. If the remote object changes the passed-in object values, it won't be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.
",rmiregistry[edit],plain_text
2127,"However, exported remote objects passed as parameters are passed by remote reference.
",rmiregistry[edit],plain_text
2128,,rmic tool[edit],
2129,,RMI Remote object[edit],
2130,"The remote object has to either extend the java.rmi.server.UnicastRemoteObject object, or be explicitly exported by calling the java.rmi.server.UnicastRemoteObject.exportObject() method.
",RMI Remote object[edit],plain_text
2131,,RMI clients[edit],
2132,"Here is an example of RMI client:
",RMI clients[edit],plain_text
2133," 1 import java.rmi.registry.LocateRegistry;
 2 import java.rmi.registry.Registry;
 3 
 4 public class HelloClient{
 5 
 6     private HelloClient() {}
 7 
 8     public static void main(String[] args) {
 9         String host = (args.length < 1) ? null : args[0];
10         try {
11             Registry registry = LocateRegistry.getRegistry(host);
12             Hello stub = (Hello) registry.lookup(""Hello"");
13             String response = stub.sayHello();
14             System.out.println(""response: "" + response);
15         } catch (Exception e) {
16             System.err.println(""Client exception: "" + e.toString());
17             e.printStackTrace();
18         }
19     }
20 }
",RMI clients[edit],code_fragment
2134,"
",RMI clients[edit],plain_text
2135,"
Enterprise JavaBeans (EJB) technology is the server-side component architecture for Java Platform, Enterprise Edition (Java EE). EJB technology enables to create distributed, transactional, secure and portable application component objects.
",Enterprise JavaBean Programming (EJB),plain_text
2136,"EJB supports the development and deployment of component based business applications.  Applications written using the Enterprise JavaBeans architecture are scalable, transactional, and multi-user secure.  These applications may be written once, and then deployed on any server platform that supports the Enterprise JavaBeans specification.
",Enterprise JavaBean Programming (EJB),plain_text
2137,,EJB History[edit],
2138,,EJB Features[edit],
2139,"Security Management
Persistence Management
Transaction Management
Distributable Interoperable Management
Exception Management",EJB Features[edit],plain_text
2140,,Types of EJB[edit],
2141,"Session Beans
StateFull Session Beans
Stateless Session Beans
Entity Beans
Message Driven Beans",Types of EJB[edit],plain_text
2142,,Problems with EJB as a component based development[edit],
2143,"EJBs are an attempt to create component based application development.  With EJBs it is easier to develop components, but the same basic and fundamental maintenance problem will still be there. That is the dependencies between the client and the components.  The usage of a component is fixed, changes on the component interface cause to break the client code.  The same client/server problem comes back, that is as the users of a component increases the maintenance of that component getting harder and harder until it goes to impossible.
",Problems with EJB as a component based development[edit],plain_text
2144,"For a true component based application development we need to standardize the usage of a component.  The client must somehow flexibly figure out automatically how to use a component, so component changes don't affect any of the clients using that component. Without that flexibility, a true component based application development will remain as an idea, a dream, a theory without significant practical use.
If we had that flexibility, it could cause a paradigm shift in the software development industry.
",Problems with EJB as a component based development[edit],plain_text
2145,"JINI was an attempt from Sun to address this flexibility problem.  In JINI, the client download the component interface implementation and execute it in the client space.
",Problems with EJB as a component based development[edit],plain_text
2146,"So we need to mix (somehow) EJB and JINI technologies to come up with a true flexible component based technology.
",Problems with EJB as a component based development[edit],plain_text
2147,,References[edit],
2148,Sun EJB Home,References[edit],plain_text
2149,,See also[edit],
2150,EJB in Java EE,See also[edit],plain_text
2151,,External links[edit],
2152,"EJB 2 Tutorial, interactive Java Lessons",External links[edit],plain_text
2153,"
",External links[edit],plain_text
2154,"
After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces.  JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way.  It can be viewed as an object repository that provides a distributed persistent  object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.
",Java Spaces Programming (Jini),plain_text
2155,"JavaSpaces is used when someone wants to achieve scalability and availability and at the same time reducing the complexity of the overall system.
",Java Spaces Programming (Jini),plain_text
2156,"Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.
",Java Spaces Programming (Jini),plain_text
2157,"In conventional applications, objects are assembled from the database before presenting to the end user. In JavaSpace applications, we keep the ready made ""end user"" objects and store them in the JavaSpace. In JavaSpace applications the services are decoupled from each other; they communicate through objects that they write and read/take from the JavaSpace. Services search for objects that they want to take or read from the Space by using template object.
",Java Spaces Programming (Jini),plain_text
2158,,JINI[edit],
2159,"JavaSpaces technology is part of the Java Jini technology.  The basic features of JINI are:
",JINI[edit],plain_text
2160,"No user intervention is needed when services are brought on or offline. (In contrast to EJBs where the client program has to know the server and port number where the EJB is deployed. In JINI the client is supposed to find, discover the service in the network.)
Self healing by adapting when services (consumers of services) come and go. Services need to periodically renew a lease to indicate that they are still available.
Consumers of JINI services do not need prior knowledge of the service's implementation. The implementation is downloaded dynamically and run on the consumer JVM, without configuration and user intervention. For example, the end user may be presented with slightly different user interface depending which service is being used at the time. The implementation of those user interface code would be provided by the service being used.",JINI[edit],plain_text
2161,"A minimal JINI network environment consists of:
",JINI[edit],plain_text
2162,"One or more services
A lookup-service keeping a list of registered services
One or more consumers",JINI[edit],plain_text
2163,,The JINI Lookup Service[edit],
2164,"The lookup service is described in the : Jini Lookup Service Specification (reggie).  This service interface defines all operations that are possible on the lookup service.  Clients locate services by requesting with a lookup server that implements a particular interface.  Client asks the lookup server for all services that implement the particular service interface.  The lookup service returns service objects for all registered services that implement the given interface.  The client may invoke methods on that object in order to interact directly with the server.
",The JINI Lookup Service[edit],plain_text
2165,,Lookup Discovery[edit],
2166,"Jini Discovery and Join Specification describes how does the client find the jini lookup service.  There is a protocol to do that, jini comes with a set of API's that implement that protocol.  The Jini Discovery Utility Specification defines a set of utility classes that are used to work with the protocol.
",Lookup Discovery[edit],plain_text
2167,,Leasing[edit],
2168,"When a service registers with the lookup service, it receives a lease from the lookup service, described in the Jini Distributed Leasing Specification.
",Leasing[edit],plain_text
2169,,Entries and Templates[edit],
2170,,Distributed Events[edit],
2171,"
",Distributed Events[edit],plain_text
2172,"
Java allows users to document the classes and the members by using a particular syntax of comment.
",Javadoc,plain_text
2173,,Syntax[edit],
2174,"A documentation comment is framed by slash-star-star and star-slash (i.e. /** ... */). The documentation is in the HTML format.
",Syntax[edit],plain_text
2175,"1 /**
2  *  A class to give an <b>example</b> of HTML documentation.
3  */
4 public class Example {
5     /** ...Documentation of a member with the type integer named example... */
6     public int example;
7 }
",Syntax[edit],code_fragment
2176,"A documentation comment is placed just above the commented entity (class, constructor, method, field).
",Syntax[edit],plain_text
2177,"In a documentation comment, the first part is a description text in the HTML format. The second part is a list of special attributes whose name starts with an at sign (@):
",Syntax[edit],plain_text
2178,"1 /**
2  *  Get the sum of two integers.
3  *  @param a The first integer number.
4  *  @param b The second integer number.
5  *  @return The value of the sum of the two given integers.
6  */
7 public int sum(int a, int b) {
8     return a + b;
9 }
",Syntax[edit],code_fragment
2179,"Here is a non exhaustive list of special attributes:
",Syntax[edit],plain_text
2180,"See also annotations since Java 5.
",Syntax[edit],plain_text
2181,,Documentation[edit],
2182,"The JDK provides a tool named javadoc which allows to generate the documentation of the well commented classes. The javadoc command without argument give the complete syntax of the command.
",Documentation[edit],plain_text
2183,"Example : for a class named Example defined in a package named org.wikibooks.en in the file C:\ProgJava\org\wikibooks\en\Example.java :
",Documentation[edit],plain_text
2184," 1 package org.wikibooks.en;
 2 
 3 /**
 4  *  An example class.
 5  */
 6 public class Example {
 7     /**
 8     Get the sum of two integers.
 9     @param a The first integer number.
10     @param b The second integer number.
11     @return The value of the sum of the two given integers.
12     */
13     public int sum(int a, int b) {
14         return a + b;
15     }
16 }
",Documentation[edit],code_fragment
2185,"The documentation can be generated in a specific folder (C:\ProgDoc for example) with the following command:
",Documentation[edit],plain_text
2186,"The options of this command are described below:
",Documentation[edit],plain_text
2187,"The description page of a package copy the description text from the file named package.html which should be placed in the given folder. In our example, we should document the package in the file C:\ProgJava\org\wikibooks\en\package.html.
",Documentation[edit],plain_text
2188,"Since Java 5[1], the package.html file can be replaced by a special Java file named package-info.java containing only the package declaration preceding by a documentation comment.
",Documentation[edit],plain_text
2189,"1 /**
2  * This fake package is used to illustrate the Java wikibook.
3  * at <i>en.wikibooks.org</i>.
4  */
5 package org.wikibooks.en;
",Documentation[edit],code_fragment
2190,,References[edit],
2191,"
",References[edit],plain_text
2192,"
",Introduction to Annotation,plain_text
2193,,Introduction[edit],
2194,"In Java, an annotation is a language construct (introduced in J2SE 1.5) that provides a mechanism for including metadata directly in the source code.
",Introduction[edit],plain_text
2195,"Annotations can provide metadata for Java classes, attributes, and methods. Syntactically, annotations can be viewed as a special kind of modifier and can be used anywhere that other modifiers (such as public, static, or final) can be used.
",Introduction[edit],plain_text
2196,"One of the main forces of adding this feature to Java was the wide spread use of XML descriptors to add additional information, metadata, for Java classes. Frameworks like EJB, JSF, Spring, Hibernate were heavily using external XML descriptors. The problem of those external descriptors was that those files are out of reach of the Java compiler and for that reason compiler type checking could not be used. A small spelling mistake bug in a huge XML descriptor file is hard to locate and fix. On the other hand the Java annotations use the Java compiler type checking features so spelling mistakes in annotation names will be caught by the Java compiler.
",Introduction[edit],plain_text
2197,"In summary, annotations can be...
",Introduction[edit],plain_text
2198,"used as a source of information for the compiler;
made available for compile-time or deployment-time processing;
examined at runtime.",Introduction[edit],plain_text
2199,,External links[edit],
2200,[1] The Java™ Tutorial on Annotations,External links[edit],plain_text
2201,"
",External links[edit],plain_text
2202,"
Annotations can be viewed as a source of defining meta-data for a piece of code in Java. The annotation @CodeDescription used in the following sections does not come as a part of the Java API.
",Creating custom annotations,plain_text
2203,,Annotation Type Declaration[edit],
2204,"Before you can use an annotation with classes, theirs members and statements or expressions, you need to define an annotation type. Following is the syntax on how to define a type for the mentioned annotation.
",Annotation Type Declaration[edit],plain_text
2205,"@interface CodeDescription
{
    String author();
    String version();
}
",Annotation Type Declaration[edit],code_fragment
2206,"That's it! Our first ever annotation has been defined. Now, we can use it with any of our classes. An annotation definition if you look closely resembles the definition of a normal interface, except that the interface keyword is preceded by the @ character. Some refer to this syntactical declaration as the annotation type declaration due to the fact that @ is 'AT' or 'Annotation Type' for that very instance.
",Annotation Type Declaration[edit],plain_text
2207,,Annotation Element Declarations[edit],
2208,"What look like methods in the body of the annotation definition are called annotation element declarations. These are the named entities that we used with the annotation body in the example in the previous section. However, for the sake of clarity, code below also represents the calling of the following annotation:
",Annotation Element Declarations[edit],plain_text
2209,"public class MyMethod
{
    @CodeDescription
    (
        author = ""Unknown"",
        version = ""1.0.0.1""
    )
    public void doSomething()
    {
        ...
    }
}
",Annotation Element Declarations[edit],code_fragment
2210,,Using a default value[edit],
2211,"Now, for instance, you want the annotation to know that if no value for the version element is present, then it should use a default value. Declaring a default value would be done the following way.
",Using a default value[edit],plain_text
2212,"@interface CodeDescription
{
    String author();
    String version() default ""1.0.0.1"";
}
",Using a default value[edit],code_fragment
2213,"So, now if you use the same code again, you can ignore the version element because you know that the value is to be provided by default.
",Using a default value[edit],plain_text
2214,"public class MyMethod
{
    @CodeDescription(author = ""Sysop"")
    public void doSomething()
    {
        ...
    }
}
",Using a default value[edit],code_fragment
2215,"
",Using a default value[edit],plain_text
2216,"
There are five annotation types in the java.lang.annotation package called meta-annotations. These annotation types are used to annotate other annotation types.
",Meta-annotations,plain_text
2217,,Documented[edit],
2218,"If a member is annotated with a type itself marked as @Documented, then that member will be documented as annotating that type.
",Documented[edit],plain_text
2219,"@interface Secret { }

@Documented
@interface NotSecret { }

@Secret
@NotSecret
public class Example {
}
",Documented[edit],code_fragment
2220,"In the documentation for the Example class, such as the JavaDoc, Example will be shown as annotated with @NotSecret, but not @Secret.
",Documented[edit],plain_text
2221,,Inherited[edit],
2222,"Exactly as the name sounds, an @Inherited annotation type is inherited by subclasses of an annotated type.
",Inherited[edit],plain_text
2223,"@Inherited
@interface ForEveryone { }

@interface JustForMe { }

@ForEveryone
@JustForMe
class Superclass { }

class Subclass extends Superclass { }
",Inherited[edit],code_fragment
2224,"In this example, Superclass has been explicitly annotated with both @ForEveryone and @JustForMe. Subclass hasn't been explicitly marked with either one; however, it inherits @ForEveryone because the latter is annotated with @Inherited. @JustForMe isn't annotated, so it isn't inherited by Subclass.
",Inherited[edit],plain_text
2225,,Repeatable[edit],
2226,"A @Repeatable annotation type is repeatable - i.e. can be specified multiple times on the same class. This meta-annotation was added in Java 8.
",Repeatable[edit],plain_text
2227,,Retention[edit],
2228,"Different annotation types have different purposes. Some are intended for use with the compiler; others are meant to be reflected dynamically at runtime. There's no reason for a compiler annotation to be available at runtime, so the @Retention meta-annotation specifies how long an annotation type should be retained. The value attribute is one of the java.lang.annotation.RetentionPolicy enum constants. The possible values, in order from shortest to longest retention, are as follows:
",Retention[edit],plain_text
2229,"If no @Retention policy is specified, it defaults to RetentionPolicy.CLASS.
",Retention[edit],plain_text
2230,,Target[edit],
2231,"The @Target meta-annotation determines what may be marked by the annotation. The value attribute is one or more of the java.lang.annotation.ElementType enum constants. Those constants are ElementType.ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, and TYPE.
",Target[edit],plain_text
2232,"If @Target is not specified, the annotation may be used on any program element.
",Target[edit],plain_text
2233,"
",Target[edit],plain_text
2234,"
Annotations can be used by the compiler to carry out certain directives.  Much that you'd love programming in Java, you probably would have been fussed about compiler warnings. Compiler warnings are not necessarily errors but are warnings that tell you the code might malfunction because of some reason.
",Helping the compiler,plain_text
2235,"You can issue directive to the compiler in the shape of three pre-defined annotation to tell it what sort of pre-processing a certain bit of code requires. The three annotations are:
",Helping the compiler,plain_text
2236,"@Deprecated
@Override
@SuppressWarnings(..)",Helping the compiler,plain_text
2237,"@Deprecated is used to flag that a method or class should no longer be used, normally because a better alternative exists.  Compilers and IDEs typically raise a warning if deprecated code is invoked from non deprecated code. [1]
",Helping the compiler,plain_text
2238,"@Override flags that a method overrides a method in a superclass.  If there is no overridden method, a compile error should occur. [2]
",Helping the compiler,plain_text
2239,"@SuppressWarnings(..) SuppressWarnings tells the compiler not to report on some, or all, types of warnings.  It can be applied to a type, a method or a variable.  [3]
",Helping the compiler,plain_text
2240,,External links[edit],
2241,[4] Advanced usage of the @SuppressWarnings(..) annotation,External links[edit],plain_text
2242,"
",External links[edit],plain_text
2243,"
This section covers the Java platform classes used for basic input and output. But before we begin we need to have a concrete understanding of what input and output means in programming. To grasp this concept, think of the Java platform as a system.
",Basic I/O,plain_text
2244,,Understanding input and output[edit],
2245,"The Java platform is an isolated entity, a space on your OS in a way, where everything outside this system is its environment. The interaction between the system and its environment is a two-way dialog of sorts. Either the system receives messages from its environment, or it conveys its messages to the same. When a message is received by the system, it is called an input, its opposite is an output. On a whole, this communication is termed input/output abbreviated as I/O.
",Understanding input and output[edit],plain_text
2246,"The following chapters are designed to introduce basic input and output in Java, including reading text input from the keyboard, outputting text to the monitor, and reading/writing files from the file system.  More advanced user interaction using Graphics and Graphical User Interface (GUI) programs is taken up in the later section on Swing.
",Understanding input and output[edit],plain_text
2247,"There are two packages for I/O: the older java.io package (does not support symbolic links) and the newer java.nio (""new io"") package that has improved exception handling at java.nio.file.
",Understanding input and output[edit],plain_text
2248,"Writing to the screen is very easy, and can be accomplished using one of two methods:
",Understanding input and output[edit],plain_text
2249,"System.out.print(""Hello world"");
",Understanding input and output[edit],code_fragment
2250,"As of version 5, Java provides a class in the java.util package called Scanner that simplifies keyboard input.
",Understanding input and output[edit],plain_text
2251,"Scanner kbdIn = new Scanner(System.in); // Instantiating a new Scanner object
System.out.print(""Enter your name: ""); // Printing out the prompt
String name = kbdIn.nextLine(); // Reading a line of input (until the user hits enter) from the keyboard
// and putting it in a String variable called name
System.out.println(""Welcome, "" + name); // Printing out welcome, followed by the user's name
",Understanding input and output[edit],code_fragment
2252,"Alternatively, one could write a method to handle keyboard input:
",Understanding input and output[edit],plain_text
2253,"public String readLine() {
  // Creates a new BufferedReader object
  BufferedReader x = new BufferedReader(new InputStreamReader(System.in));

  // Reads a line of input and returns it directly
  return x.readLine();
}
",Understanding input and output[edit],code_fragment
2254,"Note that the code above shouldn't be used in most applications, as it creates new Objects every time the method is run.
A better alternative would be to create a separate class file to handle keyboard input.
",Understanding input and output[edit],plain_text
2255,"
",Understanding input and output[edit],plain_text
2256,"
The most basic input and output in Java (System.in and System.out fields that have been used in the Basic I/O) is done using streams. Streams are objects that represent sources and destinations of data.  Streams that are sources of data can be read from, and streams that are destinations of data can be written to. A stream in Java is an ordered sequence of bytes of undetermined length. Streams are ordered and in sequence so that the java virtual machine can understand and work upon the stream. Streams are analogous to water streams. They exist as a communication medium, just like electromagnetic waves in communication. The order or sequence of bytes in a Java stream allow the virtual machine to classify it among other streams.
",Streams,plain_text
2257,"Java has various inbuilt streams implemented as classes in the package java.io like the classes of System.in and System.out. Streams can be classed as both input and output streams. All Java streams are derived from Input Stream (java.io.InputStream) and Output Stream (java.io.OutputStream) classes. They are abstract base classes meant for other stream classes. The System.in is the input stream class derivative and analogically System.out is the output counterpart. Both are basic classes used to directly interact with input and output through console, similarly follows System.err. Also Java has streams to communicate across different parts of a program or even among threads. There are also classes that ""filter"" streams, changing one format to another (e.g. class DataOutputStream, which translates various primitive types to byte streams).
",Streams,plain_text
2258,"It is a characteristic of streams that they deal only in one discrete unit of data at a time, and different streams deal with different types of data.  If one had a stream that represented a destination for bytes, for example, one would send data to the destination one byte at a time.  If a stream was a source of byte data, one would read the data a byte at a time.  Because this is the only way to access data from a stream, in this latter case, we wouldn't know when we had read all the data from the stream until we actually got there.  When reading a stream, one generally has to check each unit of data each read operation to see if the end of the stream has been reached (with byte streams, the special value is the integer -1, or FFFF hex).
",Streams,plain_text
2259,,Input streams[edit],
2260,"Input streams acquire bytes for our programmed java application/program (e.g. a file, an array, a keyboard or monitor, etc.). InputStream is an abstract class that represents a source of byte data.  It has a read() method, which returns the next byte in the stream and a close() method, which should be called by a program when that program is done with the stream.  The read() method is overloaded, and can take a byte array to read to.  It has a skip() method that can skip a number of bytes, and an available() method that a program can use to determine the number of bytes immediately available to be read, as not all the data is necessarily ready immediately.  As an abstract class, it cannot be instantiated, but describes the general behavior of an input stream.  A few examples of concrete subclasses would be ByteArrayInputStream, which reads from a byte array, and FileInputStream, which reads byte data from a file.
",Input streams[edit],plain_text
2261,"In the following example, we print ""Hello world!"" on the screen several times. The number of times the message is printed is stored in a file named source.txt. This file should only contain a integer and should be placed in the same folder of the ConfiguredApplication class.
",Input streams[edit],plain_text
2262," 1 import java.io.File;
 2 import java.io.FileInputStream;
 3  
 4 public class ConfiguredApplication {
 5  
 6   public static void main(String[] args) throws Exception {
 7  
 8     // Data reading
 9     File file = new File(""source.txt"");
10     FileInputStream stream = new FileInputStream(file);
11  
12     StringBuffer buffer = new StringBuffer();
13  
14     int character = 0;
15     while ((character = stream.read()) != -1) {
16       buffer.append((char) character);
17     }
18  
19     stream.close();
20  
21     // Data use
22     Integer readInteger = Integer.parseInt(buffer.toString());
23     for (int i = 0; i < readInteger ; i++) {
24       System.out.println(""Hello world!"");
25     }
26   }
27 }
",Input streams[edit],code_fragment
2263,"The close() method is not always mandatory but can avoid some inter-process concurrency conflicts. However if it occurs before a read() or write() (in the same process) they return the warning Stream closed.
",Input streams[edit],plain_text
2264,"The class start to identify the filename with a File object. The File object is used by an input stream as the source of the stream. We create a buffer and a character to prepare the data loading. The buffer will contain all the file content and the character will temporary contain each character present in the file, one after one. This is done while{}in the loop. Each iteration of the loop will copy a character from the stream to the buffer. The loop ends when no more character is present in the stream. Then we close the stream. The last part of the code use the data we have loaded in from the file. It is transformed into string and then into an integer (so the data must be an integer). If it works, the integer is used to determine the number of time we print ""Hello world!"" on the screen. No try/catch block has been defined for readability but the thrown exceptions should be caught.
",Input streams[edit],plain_text
2265,"Let's try with the following source file:
",Input streams[edit],plain_text
2266,"We should obtain this:
",Input streams[edit],plain_text
2267,"There is also Reader which is an abstract class that represents a source of character data.  It is analogous to InputStream, except that it deals with characters instead of bytes (remember that Java uses Unicode, so that a character is 2 bytes, not one).  Its methods are generally similar to those of InputStream.  Concrete subclasses include classes like FileReader, which reads characters from files, and StringReader, which reads characters from strings.  You can also convert an InputStream object to a Reader object with the InputStreamReader class, which can be ""wrapped around"" an InputStream object (by passing it as an argument in its constructor).  It uses a character encoding scheme (which can be changed by the programmer) to translate a byte into a 16-bit Unicode character.
",Input streams[edit],plain_text
2268,,Output streams[edit],
2269,"Output Streams direct streams of bytes outwards to the environment from our program or application. OutputStream is an abstract class which is the destination counterpart of InputStream.  OutputStream has a write() method which can be used to write a byte to the stream.  The method is overloaded, and can take an array as well.  A close() method closes the stream when the application is finished with it, and it has a flush() method.  The stream may wait until it has a certain amount before it writes it all at once for efficiency.  If the stream object is buffering any data before writing it, the flush() method will force it to write all of this data.  Like InputStream, this class cannot be instantiated, but has concrete subclasses that parallel those of InputStream, eg ByteArrayOutputStream, FileOutputStream, etc.
",Output streams[edit],plain_text
2270,"In the following example, we store the current time in an already existing file called log.txt located in the same folder than the class.
",Output streams[edit],plain_text
2271," 1 import java.io.File;
 2 import java.io.FileOutputStream;
 3 import java.util.Date;
 4  
 5 public class LogTime {
 6     public static void main(String[] args) throws Exception {
 7         // Generate data
 8         String timeInString = new Date().toString();
 9 
10         // Store data
11         File file = new File(""log.txt"");
12         FileOutputStream stream = new FileOutputStream(file);
13 
14         byte[] timeInBytes = timeInString.getBytes();
15 
16         stream.write(timeInBytes);
17         stream.flush();
18         stream.close();
19     }
20 }
",Output streams[edit],code_fragment
2272,"This case is more simple as we can put all the data in the stream at the same time. The first part of the code generate a string containing the current time. Then we create a File object identifying the output file and an output stream for this file. We write the data in the stream, flush it and close it. That's all. No try/catch block has been defined for readability but the thrown exceptions should be caught.
",Output streams[edit],plain_text
2273,"Now let's execute it:
",Output streams[edit],plain_text
2274,"We should obtain this content:
",Output streams[edit],plain_text
2275,"There is also Writer which is a character counterpart of OutputStream, and a destination counterpart to Reader, this is also an abstract superclass.  Particular implementations parallel those of Reader, eg FileWriter, StringWriter, and OutputStreamWriter, for converting a regular OutputStream into a reader so that it can take character data.
",Output streams[edit],plain_text
2276,,System.out and System.err[edit],
2277,"System is a class in the package java.lang with a number of static members that are available to Java programs.  Two members that are useful for console output are System.out and System.err.  Both System.out and System.err are PrintStream objects.  PrintStream is a subclass of FilterOutputStream, itself a subclass of OutputStream (discussed above), and its main purpose is to translate a wide variety of data types into streams of bytes that represent that data in characters according to some encoding scheme.
",System.out and System.err[edit],plain_text
2278,"System.out and System.err both display text to a console where the user can read it, however what this means exactly depends on the platform used and the environment in which the program is running.  In BlueJay and Eclipse IDE, for example, there is a special ""terminal"" window that will display this output.  If the program is launched in Windows, the output will be sent to the DOS prompt (usually this means that you have to launch the program from the command line to see the output).
",System.out and System.err[edit],plain_text
2279,"System.out and System.err differ in what they're supposed to be used for.  System.out should be used for normal program output, System.err should be used to inform the user that some kind of error has occurred in the program.  In some situations, this may be important.  In DOS, for instance, a user can redirect standard output to some other destination (a file, for example), but error output will not be redirected, but rather displayed on the screen.  If this weren't the case, the user might never be able to tell that an error had occurred.
",System.out and System.err[edit],plain_text
2280,,New I/O[edit],
2281,"Versions of Java prior to J2SE 1.4 only supported stream-based blocking I/O. This required a thread per stream being handled, as no other processing could take place while the active thread blocked waiting for input or output.  This was a major scalability and performance issue for anyone needing to implement any Java network service.  Since the introduction of NIO (New I/O) in J2SE 1.4, this scalability problem has been rectified by the introduction of a non-blocking I/O framework (though there are a number of open issues in the NIO API as implemented by Oracle).
",New I/O[edit],plain_text
2282,"The non-blocking IO framework, though considerably more complex than the original blocking IO framework, allows any number of ""channels"" to be handled by a single thread. The framework is based on the Reactor Pattern.
",New I/O[edit],plain_text
2283,,More Info[edit],
2284,"More information on the contents of the java.io package can be viewed on the Oracle website by clicking this link (http://docs.oracle.com/javase/7/docs/api/index.html).
",More Info[edit],plain_text
2285,"
",More Info[edit],plain_text
2286,"
The Java platform Event Model is the basis for event-driven programming on the Java platform.
",Event handling,plain_text
2287,,Event-driven programming[edit],
2288,"No matter what the programming language or paradigm you are using, chances are that you will eventually run into a situation where your program will have to wait for an external event to happen. Perhaps your program must wait for some user input, or perhaps it must wait for data to be delivered over the network. Or perhaps something else. In any case, the program must wait for something to happen that is beyond the program's control: the program cannot make that event happen.
",Event-driven programming[edit],plain_text
2289,"In this situation there are two general options for making a program wait for an external event to happen. The first of these is called polling and means you write a little loop of the for ""while the event has not happened, check again"". Polling is very simple to build and very straightforward. But it is also very wasteful: it means a program takes up processor time in order to do absolutely nothing but wait. This is usually considered too much of a drawback for programs that have to do a lot of waiting. Programs that have a lot of waiting moments (for example, programs that have a graphical user interface and often have to wait for long periods of time until the user does something) usually fare much better when they use the other mechanism: event-driven programming.
",Event-driven programming[edit],plain_text
2290,"In event-driven programming a program that must wait, simply goes to sleep. It no longer takes up processor time, might even be unloaded from memory and generally leaves the computer available to do useful things. But the program doesn't completely go away; instead, it makes a deal with the computer or the operating system. A deal sort of like this:
",Event-driven programming[edit],plain_text
2291,"Event-driven programming usually has a pretty large impact on the design of a program. Usually, a program has to be broken up into separate pieces to do event-driven programming (one piece for general processing and one or more others to deal with events that occur). Event-driven programming in Java is more complicated than non-event driven but it makes far more efficient use of the hardware and sometimes (like when developing a graphical user interface) dividing your code up into event-driven blocks actually fits very naturally with your program's structure.
",Event-driven programming[edit],plain_text
2292,"In this module we examine the basis of the Java Platform's facilities for event-driven programming and we look at some typical examples of how that basis has been used throughout the platform.
",Event-driven programming[edit],plain_text
2293,,The Java Platform Event Model[edit],
2294,"One of the most interesting things about support for event-driven programming on the Java platform is that there is none, as such. Or, depending on your point of view, there are many different individual pieces of the platform that offer their own support for event-driven programming.
",The Java Platform Event Model[edit],plain_text
2295,"The reason that the Java platform doesn't offer one general implementation of event-driven programming is linked to the origins of the support that the platform does offer. Back in 1996 the Java programming language was just getting started in the world and was still trying to gain a foothold and conquer a place for itself in software development. Part of this early development concentrated on software development tooling like IDEs. One of the trends in software development around that time was for reusable software components geared towards user interfaces: components that would encapsulate some sort of interesting, reusable functionality into a single package that could be handled as a single entity rather than as a loose collection of individual classes. Sun Microsystems tried to get on the component bandwagon by introducing what they called a JavaBean, a software component not only geared towards the UI but that could also be configured easily from an IDE. In order to make this happen Sun came up with a large specification of JavaBeans (the JavaBeans Spec) dealing mostly with naming conventions (to make the components easy to handle from an IDE). But Sun also realized at the same time that a UI-centric component would need support for an event-driven way of connecting events in the component to business logic that would have to be written by the individual developer. So the JavaBeans Spec also included a small specification for an event Model for the Java platform.
",The Java Platform Event Model[edit],plain_text
2296,"When they started working on this Event Model, the Sun engineers were faced with a choice: try to come up with a huge specification to encompass all possible uses of an event model, or just specify an abstract, generic framework that could be expanded for individual use in specific situations. They chose the latter option and so, love it or hate it, the Java Platform has no generic support for event-driven programming other than this general Event Model framework.
",The Java Platform Event Model[edit],plain_text
2297,"The Event Model framework is really very simple in and of itself, consisting of three classes (one abstract) and an interface. Most of all it consists of naming conventions that the programmer must obey. The framework is depicted in the image on the right.
",The Java Platform Event Model[edit],plain_text
2298,"Speaking in terms of classes and interfaces, the most important parts of the framework are the java.util.EventObject abstract class and the java.util.EventListener interface. These two types are the centerpieces of the rules and conventions of the Java Platform Event Model, which are:
",The Java Platform Event Model[edit],plain_text
2299,"A class that has to be notified when an event occurs, is called an event listener. An event listener has one distinct method for each type of event notification that it is interested in.
Event notification method declarations are grouped together into categories. Each category is represented by an event listener interface, which must extend java.util.EventListener. By convention an event listener interface is named <Event category name>Listener. Any class that will be notified of events must implement at least one listener interface.
Any and all state related to an event occurrence will be captured in a state object. The class of this object must be a subclass of java.util.EventObject and must record at least which object was the source of the event. Such a class is called an event class and by convention is named <Event category name>Event.
Usually (but not necessarily!) an event listener interface will relate to a single event class. An event listener may have multiple event notification methods that take the same event class as an argument.
An event notification method usually (but not necessarily!) has the conventional signature public void <specific event>(<Event category name>Event evt).
A class that is the source of events must have a method that allows for the registration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void add<Event category name>Listener(<Event category name>Listener listener).
A class that is the source of events may have a method that allows for the deregistration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void remove<Event category name>Listener(<Event category name>Listener listener).",The Java Platform Event Model[edit],plain_text
2300,"That seems like a lot, but it's pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object (source, inherited from java.util.EventObject).
",The Java Platform Event Model[edit],plain_text
2301,"Whenever an interesting event occurs, the EventSourceClass must notify all of the listeners for that event that it knows about by calling the notification method that exist for that purpose. All of the notification methods (in this example there is only one, interestingEventOccurred) have been grouped together by topic in a listener interface: InterestingEventListener, which implements java.util.EventListener and is named according to the Event Model conventions. This interface must be implemented by all event listener classes (in this case only InterestingEventListenerImpl). Because EventSourceClass must be able to notify any interested listeners, it must be possible to register them. For this purpose the EventSourceClass has an addInterestingEventListener method. And since it is required, there is a removeInterestingEventListener method as well.
",The Java Platform Event Model[edit],plain_text
2302,"As you can clearly see from the example, using the Event Model is mostly about following naming conventions. This might seem a little cumbersome at first, but the point of having naming conventions is to allow automated tooling to access and use the event model. And there are indeed many tools, IDEs and frameworks that are based on these naming conventions.
",The Java Platform Event Model[edit],plain_text
2303,"There's one more thing to notice about the Event Model and that is what is not in the Model. The Event Model is designed to allow implementations a large degree of freedom in the implementation choices made, which means that the Event Model can serve as the basis for a very wide range of specific, purpose-built event handling systems.
",The Java Platform Event Model[edit],plain_text
2304,"Aside from naming conventions and some base classes and interfaces, the Event Model specifies the following:
",The Java Platform Event Model[edit],plain_text
2305,"It must be possible to register and deregister listeners.
An event source must publish events by calling the correct notification method on all registered listeners.
A call to an event notification method is a normal, synchronous Java call and the method must be executed by the same thread that called it.",The Java Platform Event Model[edit],plain_text
2306,"But the Event Model doesn't specify how any of this must be done. There are no rules regarding which classes exactly must be event sources, nor about how they must keep track of registered event listeners. So one class might publish its own events, or be responsible for publishing the events that relate to an entire collection of objects (like an entire component). And an event source might allow listeners to be deregistered at any time (even in the middle of handling an event) or might limit this to certain times (which is relevant to multithreading).
",The Java Platform Event Model[edit],plain_text
2307,"Also, the Event Model doesn't specify how it must be embedded within any program. So, while the model specifies that a call to an event handling method is a synchronous call, the Model does not prescribe that the event handling method cannot hand off tasks to another thread or that the entire event model implementation must run in the main thread of the application. In fact, the Java Platform's standard user interface framework (Swing) includes an event handling implementation that runs as a complete subsystem of a desktop application, in its own thread.
",The Java Platform Event Model[edit],plain_text
2308,"In the previous section we mentioned that an event notification method usually takes a single argument. This is the preferred convention, but the specification does allow for exceptions to this rule if the application really needs that exception. A typical case for an exception is when the event notification must be sent across the network to a remote system though non-Java means, like the CORBA standard. In this case it is required to have multiple arguments and the Event Model allows for that. However, as a general rule the correct format for a notification method is
",The Java Platform Event Model[edit],plain_text
2309,"public void specificEventDescription(Event_type evt)
",The Java Platform Event Model[edit],code_fragment
2310,"Another thing we mentioned earlier is that, as a general rule, the Event Model allows many event listeners to register with a single event source for the same event. In this case the event source must broadcast any relevant events to all the registered listeners. However, once again the Event Model specification allows for an exception to the rule. If it is necessary from a design point of view you may limit an event source to registering a single listener; this is called unicast event listener registration. When unicast registration is used, the registration method must be declared to throw the java.util.TooManyListenersException exception if too many listeners are registered:
",The Java Platform Event Model[edit],plain_text
2311,"public void add<Event_type>Listener(<Event_type>Listener listener) throws java.util.TooManyListenersException
",The Java Platform Event Model[edit],code_fragment
2312,"Finally, the specification allows for one more extension: the event adaptor. An event adaptor is an implementation of an event listener interface that can be inserted between an event source and an actual event listener class. This is done by registering the adaptor with the event source object using the regular registration method. Adaptors are used to add additional functionality to the event handling mechanism, such as routing of event objects, event filtering or enriching of the event object before processing by an actual event handler class.
",The Java Platform Event Model[edit],plain_text
2313,,A simple example[edit],
2314,"In the previous section we've explored the depths (such as there are) of the Java platform Event Model framework. If you're like most people, you've found the theoretical text more confusing than the actual use of the model. Certainly more confusing than should be necessary to explain what is, really, quite a simple framework.
",A simple example[edit],plain_text
2315,"In order to clear everything up a bit, let's examine a simple example based on the Event Model framework. Let's assume that we want to write a program that reads a stream of numbers input by the user at the command line and processes this stream somehow. Say, by keeping track of the running sum of numbers and producing that sum once the stream has been completely read.
",A simple example[edit],plain_text
2316,"Of course we could implement this program quite simply with a loop in a main() method. But instead let's be a little more creative. Let's say that we want to divide our program neatly into classes, each with a responsibility of its own (like we should in a proper, object-oriented design). And let's imagine that we want it to be possible not only to calculate the sum of all the numbers read, but to perform any number of calculations on the same number stream. In fact, it should be possible to add new calculations with relative ease and without having to affect any previously existing code.
",A simple example[edit],plain_text
2317,"If we analyze these requirements, we come to the conclusion that we have a number of different responsibilities in the program:
",A simple example[edit],plain_text
2318,"Using the Event Model framework allows us to separate the two main responsibilities cleanly and affords us the flexibility we are looking for. If we implement the logic for reading the number stream in a single class and treat the reading of a single number as an event, the Event Model allows us to broadcast that event (and the number) to as many stream processors as we like. The class for reading the number stream will act as the event source of the program and each stream processor will be a listener. Since each listener is a class of its own and can be registered with the stream reader (or not) this means our model allows us to have multiple, independent stream processing that we can add on to without affecting the code to read the stream or any pre-existing stream processor.
",A simple example[edit],plain_text
2319,"The Event Model says that any state associated with an event should be included in a class that represents the event. That's perfect for us; we can implement a simple event class that will record the number read from the command line. Each listener can then process this number as it sees fit.
",A simple example[edit],plain_text
2320,"For our interesting event set let's keep things simple: let's limit ourselves to having read a new number and having reached the end of the stream. With this choice we come to the following design for our example application:
",A simple example[edit],plain_text
2321,"In the following sections we look at the implementation of this example.
",A simple example[edit],plain_text
2322,"Let's start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-somethingEvent. Let's go for NumberReadEvent, since that's what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, that's the number read from the stream. And our event class must inherit from java.util.EventObject. So all in all, the following class is all we need:
",A simple example[edit],plain_text
2323,"package org.wikibooks.en.javaprogramming.example;

import java.util.EventObject;

public class NumberReadEvent extends EventObject {

    private double number;
   
    public NumberReadEvent(Object source, Double number) {
        super(source);
        this.number = number;
    }

    public double getNumber() {
        return number;
    }
}
",A simple example[edit],code_fragment
2324,"Next, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener. We said earlier our interesting events were ""number read"" and ""end of stream reached"", so here we go:
",A simple example[edit],plain_text
2325,"package org.wikibooks.en.javaprogramming.example;

import java.util.EventListener;

public interface NumberReadListener extends EventListener {
    public void numberRead(NumberReadEvent numberReadEvent);
   
    public void numberStreamTerminated(NumberReadEvent numberReadEvent);
}
",A simple example[edit],code_fragment
2326,"Actually the numberStreamTerminated method is a little weird, since it isn't actually a ""number read"" event. In a real program you'd probably want to do this differently. But let's keep things simple in this example.
",A simple example[edit],plain_text
2327,"So, with our listener interface defined, we need one or more implementations (actual listener classes). At the very least we need one that will keep a running sum of the numbers read. We can add as many as we like, of course. But let's stick with just one for now. Obviously, this class must implement our NumberReadListener interface. Keeping a running summation is a matter of adding numbers to a field as the events arrive. And we wanted to report on the sum when the end of the stream is reached; since we know when that happens (i.e. the numberStreamTerminated method is called), a simple println statement will do:
",A simple example[edit],plain_text
2328,"package org.wikibooks.en.javaprogramming.example;

public class NumberReadListenerImpl implements NumberReadListener {
   
    double totalSoFar = 0D;

    @Override
    public void numberRead(NumberReadEvent numberReadEvent) {
        totalSoFar += numberReadEvent.getNumber();
    }

    @Override
    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {
        System.out.println(""Sum of the number stream: "" + totalSoFar);
    }
}
",A simple example[edit],code_fragment
2329,"So, is this code any good? No. It's yucky and terrible and most of all not thread safe. But it will do for our example.
",A simple example[edit],plain_text
2330,"This is where things get interesting: the event source class. This is the interesting place because this is where we must put code to read the number stream, code to send events to all the listeners and code to manage listeners (add and remove them and keep track of them).
",A simple example[edit],plain_text
2331,"Let's start by thinking about keeping track of listeners. Normally this is a tricky business, since you have to take all sorts of multithreading concerns into account. But we're being simple in this example, so let's just stick with a simple java.util.Set of listeners. Which we can initialize in the constructor:
",A simple example[edit],plain_text
2332,"private Set<NumberReadListener> listeners;
   
public NumberReader() {
    listeners = new HashSet<NumberReadListener>();
}
",A simple example[edit],code_fragment
2333,"That choice makes it really easy to implement adding and removing of listeners:
",A simple example[edit],plain_text
2334,"public void addNumberReadListener(NumberReadListener listener) {
    this.listeners.add(listener);
}

public void removeNumberReadListener(NumberReadListener listener) {
    this.listeners.remove(listener);
}
",A simple example[edit],code_fragment
2335,"We won't actually use the remove method in this example — but recall that the Model says it must be present.
",A simple example[edit],plain_text
2336,"Another advantage of this simple choice is that notification of all the listeners is easy as well. We can just assume any listeners will be in the set and iterate over them. And since the notification methods are synchronous (rule of the model) we can just call them directly:
",A simple example[edit],plain_text
2337,"private void notifyListenersOfEndOfStream() {
    for (NumberReadListener numberReadListener : listeners) {
        numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));
    }
}

private void notifyListeners(Double d) {
    for (NumberReadListener numberReadListener: listeners) {
        numberReadListener.numberRead(new NumberReadEvent(this, d));
    }
}
",A simple example[edit],code_fragment
2338,"Note that we've made some assumptions here. For starters, we've assumed that we'll get the Double value d from somewhere. Also, we've assumed that no listener will ever care about the number value in the end-of-stream notification and have passed in the fixed value 0 for that event.
",A simple example[edit],plain_text
2339,"Finally we must deal with reading the number stream. We'll use the Console class for that and just keep on reading numbers until there are no more:
",A simple example[edit],plain_text
2340,"public void start() {
    Console console = System.console();
    if (console != null) {
        Double d = null;
        do {
            String readLine = console.readLine(""Enter a number: "", (Object[])null);
            d = getDoubleValue(readLine);
            if (d != null) {
                notifyListeners(d);
            }
        } while (d != null);
        notifyListenersOfEndOfStream();
    }
}
",A simple example[edit],code_fragment
2341,"Note how we've hooked the number-reading loop into the event handling mechanism by calling the notify methods? The entire class looks like this:
",A simple example[edit],plain_text
2342,"package org.wikibooks.en.javaprogramming.example;

import java.io.Console;
import java.util.HashSet;
import java.util.Set;

public class NumberReader {
    private Set<NumberReadListener> listeners;
   
    public NumberReader() {
        listeners = new HashSet<NumberReadListener>();
    }
   
    public void addNumberReadListener(NumberReadListener listener) {
        this.listeners.add(listener);
    }
   
    public void removeNumberReadListener(NumberReadListener listener) {
        this.listeners.remove(listener);
    }
   
    public void start() {
        Console console = System.console();
        if (console != null) {
            Double d = null;
            do {
                String readLine = console.readLine(""Enter a number: "", (Object[])null);
                d = getDoubleValue(readLine);
                if (d != null) {
                    notifyListeners(d);
                }
            } while (d != null);
            notifyListenersOfEndOfStream();
        }
    }

    private void notifyListenersOfEndOfStream() {
        for (NumberReadListener numberReadListener: listeners) {
            numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));
        }
    }

    private void notifyListeners(Double d) {
        for (NumberReadListener numberReadListener: listeners) {
            numberReadListener.numberRead(new NumberReadEvent(this, d));
        }
    }

    private Double getDoubleValue(String readLine) {
        Double result;
        try {
            result = Double.valueOf(readLine);
        } catch (Exception e) {
            result = null;
        }
        return result;
    }
}
",A simple example[edit],code_fragment
2343,"Finally, we need one more class: the kickoff point for the application. This class will contain a main() method, plus code to create a NumberReader, a listener and to combine the two:
",A simple example[edit],plain_text
2344,"package org.wikibooks.en.javaprogramming.example;

public class Main {

    public static void main(String[] args) {
        NumberReader reader = new NumberReader();
        NumberReadListener listener = new NumberReadListenerImpl();
        reader.addNumberReadListener(listener);
        reader.start();
    }
}
",A simple example[edit],code_fragment
2345,"If you compile and run the program, the result looks somewhat like this:
",A simple example[edit],plain_text
2346,"Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:
",A simple example[edit],plain_text
2347,"is general to the process and not specific to any one listener; or
is not supposed to affect the implementation of specific listeners.",A simple example[edit],plain_text
2348,"According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as ""proof"" for the calculations done in the listeners.
",A simple example[edit],plain_text
2349,"An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.
",A simple example[edit],plain_text
2350,"In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:
",A simple example[edit],plain_text
2351,"Uses a fixed log file name and overwrites that log file with every program run.
Opens a FileWriter in the constructor and just keeps it open.
Implements the numberRead method by writing the number to the FileWriter.
Implements the numberStreamTerminated method by closing the FileWriter.",A simple example[edit],plain_text
2352,"Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:
",A simple example[edit],plain_text
2353,"package org.wikibooks.en.javaprogramming.example;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

public class NumberReaderLoggingAdaptor implements NumberReadListener {
    private Set<NumberReadListener> listeners;
    private BufferedWriter output;
   
    public NumberReaderLoggingAdaptor() {
        listeners = new HashSet<NumberReadListener>();
        try {
            output = new BufferedWriter(new FileWriter(""numberLog.log""));
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
   
    public void addNumberReadListener(NumberReadListener listener) {
        this.listeners.add(listener);
    }
   
    public void removeNumberReadListener(NumberReadListener listener) {
        this.listeners.remove(listener);
    }
   
   
    @Override
    public void numberRead(NumberReadEvent numberReadEvent) {
        try {
            output.write(numberReadEvent.getNumber() + ""\n"");
        } catch (Exception e) {
           
        }
        for (NumberReadListener numberReadListener: listeners) {
            numberReadListener.numberRead(numberReadEvent);
        }
    }

    @Override
    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {
        try {
            output.flush();
            output.close();
        } catch (Exception e) {
           
        }
        for (NumberReadListener numberReadListener: listeners) {
            numberReadListener.numberStreamTerminated(numberReadEvent);
        }
    }

}
",A simple example[edit],code_fragment
2354,"Of course, to make the adaptor work we have to make some changes to the bootstrap code:
",A simple example[edit],plain_text
2355,"package org.wikibooks.en.javaprogramming.example;

public class Main {

    public static void main(String[] args) {
        NumberReader reader = new NumberReader();
        NumberReadListener listener = new NumberReadListenerImpl();
        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();
        adaptor.addNumberReadListener(listener);
        reader.addNumberReadListener(adaptor);
        reader.start();
    }
}
",A simple example[edit],code_fragment
2356,"But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.
",A simple example[edit],plain_text
2357,"And of course, if we run the same example as given above, the numbers are now recorded in a log file.
",A simple example[edit],plain_text
2358,,Platform uses of the Event Model[edit],
2359,"The Event Model, as mentioned earlier, doesn't have a single all-encompassing implementation within the Java platform. Instead, the model serves as a basis for several different purpose-specific implementations, both within the standard Java platform and outside it (in frameworks).
",Platform uses of the Event Model[edit],plain_text
2360,"Within the platform the main implementations are found in two areas:
",Platform uses of the Event Model[edit],plain_text
2361,"As part of the JavaBeans classes, particularly in the support classes for the implementation of PropertyChangeListeners.
As part of the Java standard UI frameworks, AWT and Swing.",Platform uses of the Event Model[edit],plain_text
2362,"
",Platform uses of the Event Model[edit],plain_text
2363,"
Reusability comes at the core of any modern computer language's framework. It is often desirable to use components you previously built in recurring environments. In Rapid Application Development, these prove more helpful as you can drag them off a list of components and use it elsewhere in your project. Such level of reusability is added into the Java Programming language with the help of the JavaBeans architecture.
",JavaBeans,plain_text
2364,"JavaBeans are the mainstream Java component model, introduced in 1996 by Sun Microsystems. JavaBeans are defined as follows:
",JavaBeans,plain_text
2365,"""A JavaBean is a reusable software component that can be manipulated visually in a builder tool.""
",JavaBeans,plain_text
2366,"Together with the component model, Sun released a simple visual composition tool, the BeanBox. It is mostly intended for experimenting with Beans rather than offering a professional IDE. For real world applications, one should better deploy on one of the Java IDEs like Visual Age or JBuilder that support the visual composition of JavaBeans.
",JavaBeans,plain_text
2367,"As we will see, JavaBeans do not essentially differ from standard Java classes, which makes the component model quite easy to use. What sets a JavaBean apart from normal Java classes is that a JavaBean follows the Oracle JavaBeans Standard (the term JavaBean or simply bean also refers to the instances of a JavaBean class). There is a set of features and conventions adopted for facilitating reuse:
",JavaBeans,plain_text
2368,"Presence of a no argument constructor;
Support for persistence;
Properties manipulated by getter and setter methods;
Support for introspection;
Events as the mechanism of communication between beans;
Support for customization via property editors.",JavaBeans,plain_text
2369,"The JavaBeans standard provides a framework for creating objects to be used by GUI tools, including Java development environments. But in more common usage, a bean is a serializable class that follows the JavaBeans naming conventions for its properties. These naming standards make it easy to use Java introspection.
",JavaBeans,plain_text
2370,,Implementation[edit],
2371,"To follow these standards, the bean needs one or more properties abstractions which represent different state values of an object. A property has a name (a valid Java identifier) and a type (either a reference type, a primitive type or an array type). By default, the properties of a JavaBean class are inferred by the presence of either a getter method, a setter method, or both:
",Implementation[edit],plain_text
2372,"A getter method which is used to obtain the value of the property from a bean. The name is usually of the form getPropertyName. For example, the getter method for the String property whiskey is public String getWhiskey(). For boolean properties (those whose type is boolean, the convention is to use the naming pattern isPropertyName.",Implementation[edit],plain_text
2373,"isDiscounted() would be the getter method for a boolean property named discounted. Thus, the method signature of most getters is public PropertyType getPropertyName() or public boolean isPropertyName().
",Implementation[edit],plain_text
2374,"A setter method which is used to assign a value to a bean's property. A setter method is a method of the form public void setPropertyName(PropertyType value). For the previous example, the setter could be invoked as setWhiskey(""bourbon"");.",Implementation[edit],plain_text
2375,"As per the JavaBeans standard, getters and setters defined as described above automatically determine the properties of the class. However, by creating java.beans.PropertyDescriptor classes, you can specify alternate implementations by explicitly declaring the property names and the getter and/or setter methods for each property.
",Implementation[edit],plain_text
2376,"Properties are often implemented with private instance variables, but this is not required.
",Implementation[edit],plain_text
2377,,A Simple JavaBean[edit],
2378,"This is an example of a simple JavaBean type with the properties int age and String color.
",A Simple JavaBean[edit],plain_text
2379," 1 class Puppy implements java.io.Serializable {
 2 
 3   private static final long serialVersionUID = 348652158488L;
 4 
 5   private String color;
 6 
 7   private int age;
 8 
 9   public String getColor() {
10     return color;
11   }
12 
13   public void setColor(String color) {
14     this.color = color;
15   }
16 
17   public int getAge() {
18     return age;
19   }
20 
21   public void setAge(int age) {
22     this.age = age;
23   }
24 }
",A Simple JavaBean[edit],code_fragment
2380,,Persistence[edit],
2381,"The requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfaces java.io.Serializable or java.io.Externalizable need to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is called persistence. Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing the Externalizable interface.
",Persistence[edit],plain_text
2382,,Properties[edit],
2383,"The properties of a bean are all private fields that are accessible and modifiable by public methods. These getter and setter methods should be marked as such by following a simple naming convention: for some property named, say, xxx there should be a getXxx() which returns the property value and a setXxx() which sets the property.
",Properties[edit],plain_text
2384,,Introspection[edit],
2385,"In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.
",Introspection[edit],plain_text
2386,"For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field ""name"" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.
",Introspection[edit],plain_text
2387,"While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple ""is-a"" relationship can be confusing, as can looking through dozens of class definitions to find where a single ""dumb"" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.
",Introspection[edit],plain_text
2388,"The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.
",Introspection[edit],plain_text
2389," 1 public static Object getProperty(Object o, String propertyName) {
 2    if (o == null ||
 3        propertyName == null ||
 4        propertyName.length() < 1) {
 5       return null;
 6    }
 7    // Based on the property name build the getter method name
 8    String methodName = ""get"" +
 9                       propertyName.substring(0,1).toUpperCase() +
10                       propertyName.substring(1);
11    Object property = null;
12    try {
13       java.lang.Class c = o.getClass();
14       java.lang.reflect.Method m = c.getMethod(methodName, null);
15       property = m.invoke(o, null);
16    } catch (NoSuchMethodException e) {
17      // Handle exception
18    }  catch (SecurityException e) {
19      // No permission; Handle exception
20    }
21 return property;
22 }
",Introspection[edit],code_fragment
2390,"or
",Introspection[edit],plain_text
2391," 1 import org.apache.commons.beanutils.PropertyUtils;
 2 
 3 try {
 4   Object myValue = PropertyUtils.getSimpleProperty(o, propertyName);
 5 } catch (IllegalAccessException e) {
 6   // Handle exception
 7 } catch (InvocationTargetException e) {
 8   // Handle exception
 9 } catch (NoSuchMethodException e) {
10   // Handle exception
11 }
",Introspection[edit],code_fragment
2392,,Events[edit],
2393,"JavaBeans interact with each other by means of events. Events are notifications, a component can give to other components, that something interesting has happened. An example for an event might be a mouse click on a button or the closing of a window. Beans can be source and target of events. To be informed about an event, a bean has to register at another Bean as a listener.
",Events[edit],plain_text
2394,"The Java event model realizes the observer design pattern with the effect that the inter-component coupling is reduced. Method calls require tight coupling, as caller and receiver need to know each other at compile time, while with events all communication happens solely via interfaces.
",Events[edit],plain_text
2395,"A special kind of event are PropertyChangeEvents. They are used to restrict some properties to take only specific values, for example for a month integer values between 1 and 12. Every time, such a bound property is modified, notifications to all registered PropertyChangeListeners will be send.
",Events[edit],plain_text
2396,,Customization[edit],
2397,"Customization is done via Property Editors. A property editor is a tool for customizing at design time a particular property type. Property editors are activated from so-called property sheets, which display all properties of a bean. If a property is selected for customization, the property sheet finds out the type of the property, displays the appropriate property editor with the property's current value.
",Customization[edit],plain_text
2398,,Additional Remarks[edit],
2399,"A big strength of the JavaBean component model is that it is designed for simplicity. Developing JavaBeans is very simple, because a lot of behavior (like the platform independence or packaging mechanism) is supported in the Java Programming Language by default. However, one can optionally equip beans with additional objects like BeanInfos or custom PropertyEditors to use the component model in a more flexible way. A second facility is that Sun designed the whole Swing GUI library according to the JavaBeans component model. Thereby Swing components can easily be composed in visual builder tools.
",Additional Remarks[edit],plain_text
2400,"However, JavaBeans do not realize all features of a component model. A drawback is that JavaBeans are restricted to the Java programming language, while an important goal of components is the independence of an implementation language.
",Additional Remarks[edit],plain_text
2401,,Recommended readings[edit],
2402,"Learning JavaTM, Niemeyer, P. and Knudsen, J., 3rd Edition, 2005, O'Reilly: Sebastopol, CA. pp.751-786",Recommended readings[edit],plain_text
2403,"
",Recommended readings[edit],plain_text
2404,"
An essential part of programming in Java requires you to build exciting new user interfaces for yourselves. Components that come built into the Java framework are regular UI elements, however for a more rich experience, you need controls of your own. Take, for instance, a charting application. No charting tool comes built into a Java API. You need to manually draw the chart yourself.
",Canvas,plain_text
2405,"Coding drawing, to begin with, is pretty daunting but once you know the basics of Graphics programming in Java, you can create elegant graphics and art in no time. But the question that arises in one's mind is what to draw on. The answer to this question is simpler than it seems. You can start drawing on any component in the Java framework. Whether it be a panel, window or even a button.
",Canvas,plain_text
2406,"Let me break it down for you. A component in the Java language is a class that has been derived from the Component class. Each component has a method with a signature paint(Graphics) which can be overridden to manually draw something atop it.
",Canvas,plain_text
2407,,Overriding the paint(Graphics) method[edit],
2408,"Below is an example on how you need to override the above method. For this very example, the component class that we would be using would be the Canvas class. For more information about the Canvas class, see the section on Understanding the Canvas class
",Overriding the paint(Graphics) method[edit],plain_text
2409,"import java.awt.*;

public class MyCanvas extends Canvas {

    public MyCanvas() {
        //...
    }

    public void paint(Graphics graphics) {
        /* We override the method here. The graphics
         * code comes here within the method body. */
    }
}
",Overriding the paint(Graphics) method[edit],code_fragment
2410,,Understanding the Canvas class[edit],
2411,"Code listing 9.1 shows the simplicity and power of the syntax for enabling the graphics functions within Java. Lets begin by understanding what a Canvas class does. A Canvas class is a derivative or a sub-class of the Component class and when placed over a Frame, displays as a blank area.
",Understanding the Canvas class[edit],plain_text
2412,"For the purpose of drawing graphics, you may use any other class derived from the Component class, for instance, JPanel or even JTextField or JButton. Why we use the Canvas class is purely to grasp the idea of drawing in Java.
",Understanding the Canvas class[edit],plain_text
2413,"Let us refine the above code for the class to be executable and the Canvas to be displayed. For this we will add an entry-point method namely the main(String[]) method in its body and calling a JFrame class to load the canvas on.
",Understanding the Canvas class[edit],plain_text
2414,"import java.awt.*;
import javax.swing.*;

public class MyCanvas extends Canvas {
    public MyCanvas() {
    }

    public void paint(Graphics graphics) {
    }

    public static void main(String[] args) {
        // We initialize our class here
        MyCanvas canvas = new MyCanvas();
        JFrame frame = new JFrame();
        frame.setSize(400, 400);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        // Here we add it to the frame
        frame.getContentPane().add(canvas);
        frame.setVisible(true);
    }
}
",Understanding the Canvas class[edit],code_fragment
2415,"The following code now helps our class to be executable and displays the canvas on top of the frame as it displays. Running this class would result in an empty frame, however it should be clear that the canvas is sitting atop it and is merely not displaying any drawings yet.
",Understanding the Canvas class[edit],plain_text
2416,,"Get, set, draw![edit]",
2417,"Now that the basic structure of our program has been laid out, we need to explore how drawing is actually done by writing Java code. Move to the next section and try your hand at drawing basic shapes and lines. But whilst you are still fresh to the concept of a Canvas, why not test your knowledge. Try answering these questions below.
","Get, set, draw![edit]",plain_text
2418,"
","Get, set, draw![edit]",plain_text
2419,"
",Graphics,plain_text
2420,,Graphics - Drawing in Java[edit],
2421," Drawing basic shapes
 Drawing complex shapes
 Drawing text
 Understanding gradients
 Anti-aliasing basics
 Interactive drawings",Graphics - Drawing in Java[edit],plain_text
2422,"
",Graphics - Drawing in Java[edit],plain_text
2423,"
",Drawing basic shapes,plain_text
2424,,Introduction to Graphics[edit],
2425,"Throughout this chapter, we will refer to the process of creating Graphical content with code as either drawing or painting. However, Java officially recognizes the latter as the proper word for the process, but we will differentiate between the two later on.
",Introduction to Graphics[edit],plain_text
2426,"Now, the main class that you would be needing would, without doubt, be the Graphics class. If you take a closer look at the method that we used in theIdentifying the acquisition of the Graphics class in our code
",Introduction to Graphics[edit],plain_text
2427,"import java.awt.*;
import javax.swing.*;
public class MyCanvas extends Canvas {
    public MyCanvas() {
    }

    public void paint(Graphics graphics) {
        /* We would be using this method only for the sake
         * of brevity throughout the current section. Note
         * that the Graphics class has been acquired along
         * with the method that we overrode. */
    }

    public static void main(String[] args) {
        MyCanvas canvas = new MyCanvas();
        JFrame frame = new JFrame();
        frame.setSize(400, 400);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().add(canvas);
        frame.setVisible(true);
    }
}
",Introduction to Graphics[edit],code_fragment
2428,"To view the contents of the Graphics class, please check the external links at the bottom of the page for links to the online API.
",Introduction to Graphics[edit],plain_text
2429,,Etching a line on the canvas[edit],
2430,"To start off your drawing experience, consider drawing the most basic shape — a line. A canvas when viewed upon with regards to drawing routines can be expressed as an inverted Cartesian coordinate system. A plane expressed by an x- and a y-axis. The origin point or 



(
0
,
0
)


{\displaystyle (0,0)}

 being the top-left corner of a canvas and the visible area of the canvas being the Cartesian quadrant I or the positive-positive (+,+) quadrant. The further you go down from the top, the greater the value of y-coordinate on the y-axis, vice-versa for the x-axis as you move toward the right from the left. And unlike the values on a normal graph, the values appear to be positive. So a point at 



(
10
,
20
)


{\displaystyle (10,20)}

 would be 10 pixels away from the left and 20 pixels away from the top, hence the format 



(
x
,
y
)


{\displaystyle (x,y)}

.

",Etching a line on the canvas[edit],plain_text
2431,"Now, we already know that a line is a connection of two discreet points atop a canvas. So, if one point is at 



(
x
1
,
y
1
)


{\displaystyle (x1,y1)}

 and the other is at 



(
x
2
,
y
2
)


{\displaystyle (x2,y2)}

, drawing a line would require you to write a syntax like code below. For the sake of brevity, we will skim out the rest of the method unused in the example.
",Etching a line on the canvas[edit],plain_text
2432,"...
public class MyCanvas extends Canvas {
    ...
    public void paint(Graphics graphics) {
        graphics.setColor(Color.black);
        graphics.drawLine(40, 30, 330, 380);
        
    }
    ...
}
",Etching a line on the canvas[edit],code_fragment
2433,"In the above example, a simple method is used to define precisely where to place the line on the Cartesian scale of the canvas. The drawLine(int,int,int,int) asks you to put four arguments, appearing in order, the x1 coordinate, the y1 coordinate, the x2 coordinate and the y2 coordinate. Running the program will show a simple black line diagonally going across the canvas.

",Etching a line on the canvas[edit],plain_text
2434,,Drawing a simple rectangle[edit],
2435,"We now proceed on to our second drawing. A simple rectangle would do it justice, see below for code.
",Drawing a simple rectangle[edit],plain_text
2436,"...
public class MyCanvas extends Canvas {
    ...
    public void paint(Graphics graphics) {
        graphics.drawRect(10, 10, 100, 100);
    }
    ...
}
",Drawing a simple rectangle[edit],code_fragment
2437,"In the above example, you see how easy it is to draw a simple rectangle using the drawRect(int, int, int, int) method in the Graphics instance that we obtained. Run the program and you will see a simple black outline of a rectangle appearing where once a blank canvas was.
",Drawing a simple rectangle[edit],plain_text
2438,"The four arguments that are being passed into the method are, in order of appearance, the x-coordinate, the y-coordinate, width and the height. Hence, the resultant rectangle would start painting at the point on the screen 10 pixels from the left and 10 from the top and would be a 100 pixel wide and a 100 pixel in height. To save the argument here, the above drawing is that of a square with equal sides but squares are drawn using the same method and there is no such method as drawSquare(int, int, int)

",Drawing a simple rectangle[edit],plain_text
2439,"You can change the color of the outline by telling the Graphics instance the color you desire. This can be done as follows:
",Drawing a simple rectangle[edit],plain_text
2440,"...
public class MyCanvas extends Canvas {
    ...
    public void paint(Graphics graphics) {
        graphics.setColor(Color.red);
        graphics.drawRect(100, 100, 500, 500);
    }
    ...
}
",Drawing a simple rectangle[edit],code_fragment
2441,"Running the program would render the same rectangle but with a red colored outline.
",Drawing a simple rectangle[edit],plain_text
2442,"For the purposes of bringing color to our drawing, we used a method namely the setColor(Color) method. This method comes into force for all the drawing made after its call until another color is set. It asks for an argument of type Color. Now because you have no idea of how to actually instantiate a Color class, the class itself has a few built-in colors. Some built-in colors that you can use are mentioned below.
",Drawing a simple rectangle[edit],plain_text
2443,"Color.red
Color.blue
Color.green
Color.yellow
Color.pink
Color.black
Color.white",Drawing a simple rectangle[edit],plain_text
2444,"Try running the program while coding changes to colors for a different colored outline each time. Play around a bit with more colors. Look for the Color class API documentation in the external links at the bottom of the page.

",Drawing a simple rectangle[edit],plain_text
2445,"Up until now, you have been able to draw a simple rectangle for yourself while asking a question silently, ""why is the outline of the rectangle being painted rather the area as a whole?"" The answer is simple. Any method that starts with drawXxxx(...) only draws the outline. To paint the area within the outline, we use the fillXxxx(...) methods. For instance, the code below would fill a rectangle with yellow color while having a red outline. Notice that the arguments remain the same.
",Drawing a simple rectangle[edit],plain_text
2446,"...
public class MyCanvas extends Canvas {
    ...
    public void paint(Graphics graphics) {
        graphics.setColor(Color.yellow);
        graphics.fillRect(10, 10, 100, 100);
        graphics.setColor(Color.red);
        graphics.drawRect(10, 10, 100, 100);
    }
    ...
}
",Drawing a simple rectangle[edit],code_fragment
2447,"
",Drawing a simple rectangle[edit],plain_text
2448,,What about a circle?[edit],
2449,"Drawing a circle is ever so easy? It is the same process as the syntax above only that the word Rect is changed to the word Oval. And don't ask me why oval? You simply don't have the method drawCircle(int, int, int) as you don't have drawSquare(int, int, int). Following is the application of Graphics code to draw a circle just to whet your appetite.
",What about a circle?[edit],plain_text
2450,"...
public class MyCanvas extends Canvas {
    ...
    public void paint(Graphics graphics) {
        graphics.setColor(new Color(0,0,255));
        graphics.drawOval(50, 50, 100, 100);
    }
    ...
}
",What about a circle?[edit],code_fragment
2451,"
",What about a circle?[edit],plain_text
2452,,A new form of a rectangle[edit],
2453,"Simple so far, isn't it? Of all the shapes out there, these two are the only shapes that you'd need to build for the moment. Complex graphics routines are required to build shapes like a rhombus, triangle, trapezium or a parallelogram. We would be tackling them later on in another section. However, on a last note I would leave you with another interesting shape - a combination of both ovals and rectangle. Think a rectangle with rounded corners, a Rounded Rectangle (RoundRect).
",A new form of a rectangle[edit],plain_text
2454,"...
public class MyCanvas extends Canvas {
    ...
    public void paint(Graphics graphics) {
        graphics.setColor(Color.pink);
        graphics.fillRoundRect(10, 10, 100, 100, 5, 5);
        graphics.setColor(Color.red);
        graphics.drawRoundRect(10, 10, 100, 100, 5, 5);
    }
    ...
}
",A new form of a rectangle[edit],code_fragment
2455,"Notice that the syntax of the drawRoundRect(int, int, int, int, int, int) method is a bit different than the syntax for the simple rectangle drawing routine drawRect(int, int, int, int). The two new arguments added at the end are the width of the arc in pixels and the height of the arc in pixels. The result is pretty amazing when you run the program. You don't need to squint your eyes to tell that the corners of the rectangle are slightly rounded. The more the values of the width and height of the arcs, the more roundness appears to form around the corner.
",A new form of a rectangle[edit],plain_text
2456,,"Hmm, everything's perfect, but...[edit]",
2457,"Sometimes people ask, after creating simple programs like the ones above, questions like:
","Hmm, everything's perfect, but...[edit]",plain_text
2458,"Why did I have to tell the Graphics instance the color before each drawing routine? Why can't it remember my choice for the outlines and for the fill colors? The answer is simpler than it seems. But, to fully understand it, we need to focus on one little thing called the Graphics Context. The graphics context is the information that adheres to a single instance of the Graphics class. Such an instance remembers only one color at a time and that is why we need to make sure the context knows of the color we need to use by using the setColor(Color) method.
Can I manipulate the shapes, like tilt them and crop them? Hold your horses, cowboy! Everything is possible in Java, even tilting and cropping drawings. We will be focusing on these issues in a later section.
Is making shapes like triangles, rhombuses and other complex ones tedious? Well, to be honest here, you need to go back to your dusty book cabinet and take out that High School Geometry book because we would be covering some geometry basics while dealing with such shapes. Why not read a wikibook on Geometry?","Hmm, everything's perfect, but...[edit]",plain_text
2459,"...
public void paint(Graphics graphics) {
    graphics.setColor(Color.red);
    graphics.drawRect(10, 10, 100, 100);
    graphics.setColor(Color.yellow);
    graphics.fillRect(10, 10, 100, 100);
}
...
","Hmm, everything's perfect, but...[edit]",code_fragment
2460,"If you have any questions regarding the content provided here, please feel free to comment in this page's discussion.
","Hmm, everything's perfect, but...[edit]",plain_text
2461,,External Links[edit],
2462,"Locate the Graphics class in the online Java API documentation
Locate the Color class in the online Java API documentation",External Links[edit],plain_text
2463,"
",External Links[edit],plain_text
2464,"
",Drawing complex shapes,plain_text
2465,"public class Hello {
    JLabel label = newJLabel(""Hello, Mundo!"");
    JFrame frame = new JFrame(""BK*"");
    frame.add(label);

    frame.setSize(300, 300);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setVisible(true);
    frame.setLocationRelativeTo(null);
    frame.toFront();
    }
}
",Drawing complex shapes,code_fragment
2466,"
",Drawing complex shapes,plain_text
2467,"
",Drawing text,plain_text
2468,"public class MyCanvas extends Canvas {
    public void init() {
        setFont(""Times New Roman"", Font.PLAIN, 24);
        setColor(Color.white);
        setBackGroundColor(Color.black);
        setLayout(new GridLayout());
 
        add(label);
        add(button);
    }
}
",Drawing text,code_fragment
2469,"
",Drawing text,plain_text
2470,"
",Applets,plain_text
2471," Overview
 User Interface
 Event Listeners
 Graphics and Media",Applets,plain_text
2472,"
",Applets,plain_text
2473,"
A Java applet is an applet delivered in the form of Java bytecode. Java applets can run in a Web browser using a Java Virtual Machine (JVM), or in Oracle's AppletViewer, a stand alone tool to test applets. Java applets were introduced in the first version of the Java language in 1995. Java applets are usually written in the Java programming language but they can also be written in other languages that compile to Java bytecode such as Jython.
",Overview,plain_text
2474,"Applets are used to provide interactive features to web applications that cannot be provided by HTML. Since Java's bytecode is platform independent, Java applets can be executed by browsers for many platforms, including Windows, Unix, Mac OS and Linux.  There are open source tools like applet2app which can be used to convert an applet to a stand alone Java application/windows executable.  This has the advantage of running a Java applet in off-line mode without the need for Internet browser software.
",Overview,plain_text
2475,"The Java applet is less and less used. You'd rather use JavaScript when it is possible.
",Overview,plain_text
2476,,First applet[edit],
2477,"The two things you must at least create is an HTML page and a Java class. It can be done on a local folder, no need to run a server but it will be harder to understand what is local, what is remote. The HTML page has to call the Java class using the <applet/> markup:
",First applet[edit],plain_text
2478,"1 <!DOCTYPE html>
2 <html>
3   <body>
4     HTML content before the applet.<applet code=""HelloWorld"" height=""40"" width=""200""></applet>HTML content after the applet.
5   </body>
6 </html>
",First applet[edit],code_fragment
2479,"Save this file on a folder. As the <applet/> markup is calling a Java class called HelloWorld, our class should be called HelloWorld.java:
",First applet[edit],plain_text
2480," 1 import java.applet.Applet;
 2 import java.awt.Graphics;
 3 
 4 public class HelloWorld extends Applet {
 5 
 6     /**
 7      * Print a message on the screen.
 8      */
 9     public void paint(Graphics g) {
10         g.drawString(""Hello, world!"", 20, 10);
11     }
12 }
",First applet[edit],code_fragment
2481,"Save this file and compile the class on the same folder. Now let's open the web page on a browser:
",First applet[edit],plain_text
2482,"We clearly see that ""Hello, world!"" is not rendered the same way as the rest of the page.
",First applet[edit],plain_text
2483,,HTML code[edit],
2484,"To embed an applet in a HTML page, you have to insert a <applet/> markup. This markup can have several attributes:
",HTML code[edit],plain_text
2485,"The attributes with * are mandatory.
",HTML code[edit],plain_text
2486,"There have been some discussions about the usage of applet tag but it still can be used for beginning and also would work in the real world as well.
",HTML code[edit],plain_text
2487,,Java source code[edit],
2488,"Applets are not constructed in the same way as other classes or main programs. The entry point is different and the main class should extend the Applet class. The Applet class has four methods that can be called by the browser and you can redefine:
",Java source code[edit],plain_text
2489,"The four first methods define the lifecycle of an applet. At least init() or paint() must be redefined. The HTML applet tag can be embedded in the applet source code to allow the applet to be run directly by a simple applet viewer, without the need for an .html file. Typically, the applet tag immediately follows the import statements. It must be enclosed by /* */ comments:
",Java source code[edit],plain_text
2490,"1  /*
2  <applet code=""MyApplet.class""> </applet>
3  */
",Java source code[edit],code_fragment
2491,"
The main difference between an applet and a regular command-line executed program is that applets allow for extensible Graphical User Interfaces (GUI).
",User Interface,plain_text
2492,"Since applets provide for the ability to create complex GUI, it is important for developers to know how to create such programs.
",User Interface,plain_text
2493,,Applying styles and adding content[edit],
2494,"In Java applets, graphical portions are initialized and added in two different areas.  While objects are initialized in the main class, they are added to the layout of the applet in the init() method.  This is done using the syntax of add(<object>).  A typical init() method looks something like this:
",Applying styles and adding content[edit],plain_text
2495," 1 ...
 2 
 3 public void init() {
 4     setFont(new Font(""Times New Roman"", Font.PLAIN, 24));
 5     setForeground(Color.white);
 6     setBackground(Color.black);
 7     setLayout(new GridLayout);
 8    
 9     ...
10    
11     add(label);
12     add(button);
13 }
",Applying styles and adding content[edit],code_fragment
2496,"The different aspects of this method will be covered below.
",Applying styles and adding content[edit],plain_text
2497,,Button[edit],
2498,"Lots of applets use buttons.  There are only a few ways to have contact between the applet and the user, and the use of buttons is one of those ways.  Buttons are created the same way as most other Java applet objects:
",Button[edit],plain_text
2499,"1 Button submitButton = new Button(""Submit"");
",Button[edit],code_fragment
2500,"When initializing a button, it is necessary to define what text will appear on that button in the given parameter.  In this example, the button is initialized with the word ""Submit"" printed on it. Adding the button to the actual layout is done in the init() method, as described above.
",Button[edit],plain_text
2501,"1 public void init() {
2    
3     ...
4    
5     add(submitButton);
6 }
",Button[edit],code_fragment
2502,"Allowing buttons to carry out tasks or utilize a user's input is a bit more complicated.  These functions require an ActionListener, and will be discussed in ActionListener section.
",Button[edit],plain_text
2503,"
",Button[edit],plain_text
2504,,Label[edit],
2505,"Labels are areas in applets that contain text which can not be edited by the user.  This is usually ideal for descriptions (i.e. ""Insert name:"").  Labels are initialized and added to applet layouts in the same way as buttons.  Also, like buttons, the text inside labels must be identified at initialization.  If, however, the label will receive its text as the cause of a later function and should start off blank, no text should be placed between the quotation marks.
",Label[edit],plain_text
2506,"1 Label nameLabel = new Label(""Name: "");
2 
3 ...
4 
5 public void init() {
6     add(nameLabel);
7 }
",Label[edit],code_fragment
2507,"
",Label[edit],plain_text
2508,,TextField[edit],
2509,"TextFields are areas in applets that allow users to insert text.  The two parameters, which are optional, for TextFields can set predefined text in the field or set the number of columns allowed in the TextField.  Here are a few examples:
",TextField[edit],plain_text
2510," 1     TextField t1 = new TextField();                // Blank
 2     TextField t2 = new TextField(5);               // Blank in 5 columns
 3     TextField t3 = new TextField(""Input here"");    // Predefined text
 4     TextField t4 = new TextField(""Input here"", 5); // Predefined text in 5 columns
 5 
 6     ...
 7 
 8     public void init() {
 9         add(t1);
10         add(t2);
11         add(t3);
12         add(t4);
13         ...
14     }
",TextField[edit],code_fragment
2511,"
",TextField[edit],plain_text
2512,,Font[edit],
2513,"Using stylish fonts in your Java applets may be necessary to help keep your Java applets attractive.  The setFont() allows for either the font used throughout the applet to be defined or for one element's font to be set at a time.
",Font[edit],plain_text
2514,"The syntax for setting a font is setFont(<fontName>, <fontStyle>, <fontSize>).
",Font[edit],plain_text
2515,"To make every font in the applet plain, size 24 Times New Roman, the following code should be used:
",Font[edit],plain_text
2516,"1 Font f = new Font(""Times New Roman"", Font.PLAIN, 24);
2 setFont(f);
",Font[edit],code_fragment
2517,"It is not necessary to initialize the font and set the font through two different lines of code.
",Font[edit],plain_text
2518,"1 setFont(new Font(""Times New Roman"", Font.PLAIN, 24));
",Font[edit],code_fragment
2519,"However, to make the font of element a plain, size 24 Times New Roman, and element b italicized, size 28 Times New Roman, the following code should be used:
",Font[edit],plain_text
2520,"1 a.setFont(new Font(""Times New Roman"", Font.PLAIN, 24));
2 b.setFont(new Font(""Times New Roman"", Font.ITALIC, 28));
",Font[edit],code_fragment
2521,"To set the color of the fonts used in an applet, the setForeground(<color>) method is used.  This method already includes some predefined colors which can be used by calling, for example, setForeground(Color.white).  Here are all of the predefined colors:
",Font[edit],plain_text
2522,"Color.black
Color.blue
Color.cyan
Color.darkGray
Color.gray
Color.green
Color.red
Color.white
Color.yellow",Font[edit],plain_text
2523,"To create a custom color, the RGB values of the color can be passed in as the color parameter.  For example, if red were not a predefined color, one could use setForeground(new Color(255, 0, 0)) to define red.
",Font[edit],plain_text
2524,"Just as font styles, font colors can be applied to separate elements.  The syntax follows the same pattern: a.setForeground(Color.white).
",Font[edit],plain_text
2525,,Layout[edit],
2526,"Layouts are what make applets visible.  Without a layout, nothing would display.  There are five different types of layouts to choose from — some are very simple while others are complex.
",Layout[edit],plain_text
2527,"This layout places components left to right, using as much space as is needed. The Flow Layout is the default layout for applets and, therefore, does not need to be set.  However, for clarity, one can specify the applet layout as a Flow Layout by placing this line of code at the top of the init() method:
",Layout[edit],plain_text
2528,"1 setLayout(new FlowLayout());
",Layout[edit],code_fragment
2529,"The added components to the layout that follow will be placed on screen in order of which they are added.
",Layout[edit],plain_text
2530,"1 public void init() {
2     setLayout(new FlowLayout());
3     add(nameLabel);
4     add(t1);
5     add(submitButton);
6 }
",Layout[edit],code_fragment
2531,"Assuming that these variables are defined the same as above, these lines of code will create the layout of an applet that is composed of a label, a text field, and a button.  They will all appear on one line if the window permits.  By changing the width of window, the Flow Layout will contract and expand the components accordingly.
",Layout[edit],plain_text
2532,"
",Layout[edit],plain_text
2533,"This layout arranges components in the form of the table (grid). The number of rows and columns in the grid is specified in the constructor. The other two parameters, if present, specify vertical and horizontal padding between components.
",Layout[edit],plain_text
2534," 1 import java.applet.Applet;
 2 import java.awt.Button;
 3 import java.awt.GridLayout;
 4 import java.awt.Label;
 5 import java.awt.TextField;
 6 
 7 public class GridLayoutApplet extends Applet {
 8 
 9     Button submitButton = new Button(""Submit"");
10     TextField t1 = new TextField();                // Blank
11     TextField t2 = new TextField(5);               // Blank in 5 columns
12     TextField t3 = new TextField(""Input here"");    // Predefined text
13     TextField t4 = new TextField(""Input here"", 5); // Predefined text in 5 columns
14     Label nameLabel = new Label(""Name: "");
15 
16     /**
17      * Init.
18      */
19     public void init() {
20         // 3 rows, 4 columns, 2 pixel spacing
21         setLayout(new GridLayout(3, 4, 2, 2));
22         add(nameLabel);
23         add(t1);
24         add(t2);
25         add(t3);
26         add(t4);
27         add(submitButton);
28     }
29 }
",Layout[edit],code_fragment
2535,"
The items have been displayed in this order:
",Layout[edit],plain_text
2536,"We see that the layout has been configured to fill the grid left-to-right and then top-to-bottom and that the two last columns have been ignored (they don't even exist). They have been ignored because there are not enough items to fill them and the number of rows is prior to the number of columns. This means that when you specify a number of rows that is not zero, the number of columns is simply ignored. You should specify zero rows in order that the number of columns is taken into account.
",Layout[edit],plain_text
2537,"A grid layout creates cells with equal sizes. So it can be used not only to display items as a grid but also to display two items with the same width or height.
",Layout[edit],plain_text
2538,"This layout places one big component in the center and up till four components at the edges. When adding to the container with this layout, you need to specify the location as the second parameter like BorderLayout.CENTER for the center or one of the world directions for the edge (BorderLayout.NORTH points to the top edge).
",Layout[edit],plain_text
2539,"1 import java.awt.*;
2 
3 Container container = getContentPane();
4 container.setLayout(new BorderLayout());
5 
6 JButton b2 = new JButton(""two"");
7 // Add the button to the right edge.
8 container.add(b2, BorderLayout.EAST);
9 ...
",Layout[edit],code_fragment
2540,"
If you have two components, it is not the same to put the first in the north and the second to the center as to put the first in the center and the second to the south. In the first case, the layout will calculate the size of the component and the second component will have all the space left. In the second case, it is the opposite.
",Layout[edit],plain_text
2541,"The card layout displays only one item at a time and is only interesting with interactivity. The other items are stored in a stack and the displayed item is one of the items of the stack. The name of the card layout is a reference to a playing card deck where you can see the card at the top of the stack and you can put a card on the top. The difference in the card layout is that the items in the stack keeps their order. When you use this layout, you must use this method to add items to the container, i.e. the applet:
",Layout[edit],plain_text
2542,"The card layout has several methods to change the currently displayed item:
",Layout[edit],plain_text
2543," 1 import java.applet.Applet;
 2 import java.awt.CardLayout;
 3 import java.awt.Label;
 4 
 5 public class CardLayoutApplet extends Applet {
 6 
 7     static final String COMPONENT_POSITION_TOP = ""TOP"";
 8     static final String COMPONENT_POSITION_MIDDLE = ""MIDDLE"";
 9     static final String COMPONENT_POSITION_BOTTOM = ""BOTTOM"";
10 
11     Label topLabel = new Label(""At the top"");
12     Label middleLabel = new Label(""In the middle"");
13     Label bottomLabel = new Label(""At the bottom"");
14 
15     /**
16      * Init.
17      */
18     public void init() {
19         setLayout(new CardLayout());
20         add(COMPONENT_POSITION_TOP, topLabel);
21         add(COMPONENT_POSITION_MIDDLE, middleLabel);
22         add(COMPONENT_POSITION_BOTTOM, bottomLabel);
23         ((CardLayout)getLayout()).show(this, COMPONENT_POSITION_MIDDLE);
24     }
25 }
",Layout[edit],code_fragment
2544,"
",Layout[edit],plain_text
2545,,Panel[edit],
2546,"The main benefit of the layouts is that you can combine them one into another and you can do that with a panel. A panel is a component that has other components inside. A panel can then be added to the top component (frame or applet) or to another panel and be placed itself as defined by layout and constraints of this parent component. It has its own layout and is normally used to place a group of related components like buttons, for instance:
",Panel[edit],plain_text
2547," 1 import java.applet.Applet;
 2 import java.awt.BorderLayout;
 3 import java.awt.Button;
 4 import java.awt.FlowLayout;
 5 import java.awt.GridLayout;
 6 import java.awt.Label;
 7 import java.awt.Panel;
 8 
 9 public class Answer5 extends Applet {
10 
11     Label applicationNameLabel = new Label(""Wikibooks FTP"");
12     Button tool1Button = new Button(""Tool"");
13     Button tool2Button = new Button(""Tool"");
14     Button tool3Button = new Button(""Tool"");
15     Button tool4Button = new Button(""Tool"");
16     Button tool5Button = new Button(""Tool"");
17     Button tool6Button = new Button(""Tool"");
18     Button tool7Button = new Button(""Tool"");
19     Button tool8Button = new Button(""Tool"");
20     Button tool9Button = new Button(""Tool"");
21     Label localFolderLabel = new Label(""5 files"");
22     Label remoteFolderLabel = new Label(""3 files"");
23     Label statusBarLabel = new Label(""Available"");
24 
25     /**
26      * Init.
27      */
28     public void init() {
29         setLayout(new BorderLayout());
30 
31         // The application name
32         add(applicationNameLabel, BorderLayout.NORTH);
33 
34         // The center
35         Panel centerPanel = new Panel();
36         centerPanel.setLayout(new BorderLayout());
37 
38         // The buttons
39         Panel buttonPanel = new Panel();
40         buttonPanel.setLayout(new FlowLayout(FlowLayout.LEFT));
41         buttonPanel.add(tool1Button);
42         buttonPanel.add(tool2Button);
43         buttonPanel.add(tool3Button);
44         buttonPanel.add(tool4Button);
45         buttonPanel.add(tool5Button);
46         buttonPanel.add(tool6Button);
47         buttonPanel.add(tool7Button);
48         buttonPanel.add(tool8Button);
49         buttonPanel.add(tool9Button);
50         centerPanel.add(buttonPanel, BorderLayout.CENTER);
51 
52         // The local and remote folders
53         Panel folderPanel = new Panel();
54         folderPanel.setLayout(new GridLayout(0, 2, 2, 2));
55         folderPanel.add(localFolderLabel);
56         folderPanel.add(remoteFolderLabel);
57         centerPanel.add(folderPanel, BorderLayout.SOUTH);
58 
59         add(centerPanel, BorderLayout.CENTER);
60 
61         // The status bar
62         add(statusBarLabel, BorderLayout.SOUTH);
63     }
64 }
",Panel[edit],code_fragment
2548,"
An Event Listener, once set to an applet object, waits for some action to be performed on it, be it mouse click, mouse hover, pressing of keys, click of button, etc. The class you are using (e.g. JButton, etc.) reports the activity to a class set by the class using it. That method then decides on how to react because of that action, usually with a series of if statements to determine which action it was performed on. source.getSource() will return the name of the object that the event was performed on, while the source is the object passed to the function when the action is performed. Every single time the action is performed, it calls the method.
",Event Listeners,plain_text
2549,,ActionListener[edit],
2550,"ActionListener is an interface that could be implemented in order to determine how a certain event should be handled. When implementing an interface, all methods in that interface should be implemented, ActionListener interface has one method to implement named actionPerformed().
",ActionListener[edit],plain_text
2551,"The code listing 9.6 shows how to implement ActionListener:
",ActionListener[edit],plain_text
2552," 1 import java.applet.Applet;
 2 import java.awt.Button;
 3 import java.awt.Container;
 4 import java.awt.Dialog;
 5 import java.awt.FlowLayout;
 6 import java.awt.Frame;
 7 import java.awt.Label;
 8 import java.awt.event.ActionEvent;
 9 import java.awt.event.ActionListener;
10 
11 public class EventApplet extends Applet {
12 
13     /**
14      * Init.
15      */
16     public void init() {
17         Button clickMeButton = new Button(""Click me"");
18 
19         final Applet eventApplet = this;
20 
21         ActionListener specificClassToPerformButtonAction = new ActionListener() {
22 
23             public void actionPerformed(ActionEvent event) {
24                 Dialog dialog = new Dialog(getParentFrame(eventApplet), false);
25                 dialog.setLayout(new FlowLayout());
26                 dialog.add(new Label(""Hi!!!""));
27                 dialog.pack();
28                 dialog.setLocation(100, 100);
29                 dialog.setVisible(true);
30             }
31 
32             private Frame getParentFrame(Container container) {
33                 if (container == null) {
34                     return null;
35                 } else if (container instanceof Frame) {
36                     return (Frame) container;
37                 } else {
38                     return getParentFrame(container.getParent());
39                 }
40 
41             }
42         };
43         clickMeButton.addActionListener(specificClassToPerformButtonAction);
44 
45         add(clickMeButton);
46     }
47 }
",ActionListener[edit],code_fragment
2553,"When you compile and run the above code, the message ""Hi!!!"" will appear when you click on the button.
",ActionListener[edit],plain_text
2554,,MouseListener[edit],
2555,"Applet mouse listener does not differ from the AWT mouse listener in general. When the mouse is in the applet area, the listener receives notifications about the mouse clicks and drags (if MouseListener is registered) and mouse movements (if MouseMotionListener is registered). As applets are often small, it is a common practice to let applet itself to implement the mouse listeners.
",MouseListener[edit],plain_text
2556,"
",MouseListener[edit],plain_text
2557,"
",Graphics and Media,plain_text
2558,"By overriding the update(Graphics g) and paint(Graphics g) methods of an Applet (or one of it's sub-components), you can have fairly direct control over the rendering of an Applet.  The Graphics object provides various primitives for working for two-dimensional graphics.
",Graphics and Media,plain_text
2559,"
",Graphics and Media,plain_text
2560,"Reflection is the mechanism by which Java exposes the features of a class during runtime, allowing Java programs to enumerate and access a class' methods, fields, and constructors as objects. In other words, there are object-based mirrors that reflect the Java object model, and you can use these objects to access an object's features using runtime API constructs instead of compile-time language constructs. 
Each object instance has a getClass() method, inherited from java.lang.Object, which returns an object with the runtime representation of that object's class; this object is an instance of the java.lang.Class, which in turn has methods that return the fields, methods, constructors, superclass, and other properties of that class.
You can use these reflection objects to access fields, invoke methods, or instantiate instances, all without having compile-time dependencies on those features. The Java runtime provides the corresponding classes for reflection. Most of the Java classes that support reflection are in the java.lang.reflect package.
Reflection is most useful for performing dynamic operations with Java — operations that are not hard-coded into a source program, but that are determined at run time. One of the most important aspects of reflection is dynamic class loading.
",Reflection Overview,plain_text
2561,,Example: Invoking a main method[edit],
2562,"One way to understand how reflection works is to use reflection to model how the Java Runtime Environment (JRE) loads and executes a class. When you invoke a Java program
",Example: Invoking a main method[edit],plain_text
2563,"and pass it command line arguments, the JRE must
",Example: Invoking a main method[edit],plain_text
2564,"Steps 2, 3, and 4 can be accomplished with Java reflection.
Below is an example of loading the Distance class, locating the main method, (see Understanding a Java Program) and invoking it via reflection.
",Example: Invoking a main method[edit],plain_text
2565," 1 public static void invokeMain()
 2    throws ClassNotFoundException,
 3    	ExceptionInInitializerError,
 4    	IllegalAccessException,
 5    	IllegalArgumentException,
 6    	InvocationTargetException,
 7    	NoSuchMethodException,
 8    	SecurityException {
 9    Class<?> distanceClass = Class.forName(""Distance"");
10    String[] points = {""0"", ""0"", ""3"", ""4""};
11    Method mainMethod = distanceClass.getMethod(""main"", String[].class);
12    Object result = mainMethod.invoke(null, (Object) points);
13 }
",Example: Invoking a main method[edit],code_fragment
2566,"This code is obviously more complicated than simply calling
",Example: Invoking a main method[edit],plain_text
2567,"1 Distance.main(new String[]{""0"", ""0"", ""3"", ""4""});
",Example: Invoking a main method[edit],code_fragment
2568,"However, the main Java runtime does not know about the Distance class. The name of the class to execute is a runtime value. Reflection allows a Java program to work with classes even though the classes are not known when the program was written.
Let's explore what the invokeMain method is doing.
The first statement at line 9 is an example of dynamic class loading. The forName() method will load a Java class and return an instance of java.lang.Class that results from loading the class. In this case, we are loading the class ""Distance"" from the default package. We store the class object in the local variable distanceClass; its type is Class<?>.
The second statement at line 10 simply creates a String array with the four command line arguments we wish to pass to the main method of the Distance class.
The third statement at line 11 performs a reflection operation on the Distance class. The getMethod() method is defined for the Class class. It takes a variable number of parameters: the method name is the first parameter and the remaining parameters are the types of each of main's parameters. The method name is trivial: we want to invoke the main method, so we pass in the name ""main"". We then add a Class variable for each of the method parameters. main accepts one parameter (String[] args) so we add a single Class element representing the String[]. The getMethod method has a return type of java.lang.reflect.Method; we store the result in a local variable named mainMethod.
Finally, we invoke the method by calling the invoke() method of the Method instance. This method's first parameter is the instance to invoke on, and the remaining parameters are for the invokee's parameters. Since we are invoking a static method and not an instance method, we pass null as the instance argument. Since we only have a single parameter we pass it as the second argument. However, we must cast the parameter to Object to indicate that the array is the parameter, and not that the parameters are in the array. See varargs for more details on this.
",Example: Invoking a main method[edit],plain_text
2569,"1 Object result = mainMethod.invoke(null, arguments);
",Example: Invoking a main method[edit],code_fragment
2570,"The invoke() method returns an Object that will contain the result that the reflected method returns. In this case, our main method is a void method, so we ignore the return type.
Most of the methods in this short invokeMain method may throw various exceptions. The method declares all of them in its signatures. Here is a brief rundown of what might throw an exception:
",Example: Invoking a main method[edit],plain_text
2571,"Class.forName(String) will throw ClassNotFoundException, if the named class cannot be located.
Class.forName(String) will throw ExceptionInInitializerError, if the class could not be loaded due the static initializer throwing an exception or a static field's initialization throwing an exception.
Class.getMethod(String name, Class parameterTypes[]) will throw
NoSuchMethodException, if a matching method is not found, or is not public (use getDeclaredMethod to get a non-public method).
SecurityException, if a security manager is installed and calling the method would result in an access violation (for example, the method is in the sun.* package designed for internal use only).
Method.invoke(Object instance, Object... arguments) may throw:
IllegalAccessException, if this method is invoked in a manner that violates its access modifiers.
IllegalArgumentException for various reasons, including
passing an instance that does not implement this method.
the actual arguments do not match the method's arguments
InvocationTargetException, if the underlying method (main in this case) throws an exception.",Example: Invoking a main method[edit],plain_text
2572,"In addition to these exceptions, there are also errors and runtime exceptions that these methods may throw.
",Example: Invoking a main method[edit],plain_text
2573,"Dynamic Class Loading allows the loading of java code that is not known about before a program starts. Many classes rely on other classes and resources such as icons which make loading a single class unfeasible. For this reason the ClassLoader (java.lang.ClassLoader) is used to manage all the inner dependencies of a collection of classes. The Java model loads classes as needed and doesn't need to know the name of all classes in a collection before any one of its classes can be loaded and run.
",Dynamic Class Loading,plain_text
2574,,Simple Dynamic Class Loading[edit],
2575,"An easy way to dynamically load a Class is via the java.net.URLClassLoader class. This class can be used to load a Class or a collection of classes that are accessible via a URL. This is very similar to the -classpath parameter in the java executable. To create a URLClassLoader, use the factory method (as using the constructor requires a security privilege):
",Simple Dynamic Class Loading[edit],plain_text
2576,"1 URLClassLoader classLoader = URLClassLoader.newInstance(
2    new URL[]{""http://example.com/javaClasses.jar""});
",Simple Dynamic Class Loading[edit],code_fragment
2577,"Unlike other dynamic class loading techniques, this can be used even without security permission provided the classes come from the same Web domain as the caller.
Once a ClassLoader instance is obtained, a class can be loaded via the loadClass method. For example, to load the class com.example.MyClass, one would:
",Simple Dynamic Class Loading[edit],plain_text
2578,"1 Class<?> clazz = classLoader.load(""com.example.MyClass"");
",Simple Dynamic Class Loading[edit],code_fragment
2579,"Executing code from a Class instance is explained in the Dynamic Invocation chapter.
",Simple Dynamic Class Loading[edit],plain_text
2580,"We start with basic transfer object:
",Dynamic Method Invocation,plain_text
2581," 1 package com.test;
 2  
 3 public class DummyTo {
 4     private String name;
 5     private String address;
 6  
 7     public String getName() {
 8         return name;
 9     }
10  
11     public void setName(String name) {
12         this.name = name;
13     }
14  
15     public String getAddress() {
16         return address;
17     }
18  
19     public void setAddress(String address) {
20         this.address = address;
21     }
22  
23     public DummyTo(String name, String address) {
24         this.name = name;
25         this.address = address;
26     }
27  
28     public DummyTo() {
29         this.name = new String();
30         this.address = new String();
31     }
32  
33     public String toString(String appendBefore) {
34         return appendBefore + "" "" + name + "", "" + address;
35     }
36 }
",Dynamic Method Invocation,code_fragment
2582,"Following is the example for invoking method from the above mentioned to dynamically.
Code is self explanatory.
",Dynamic Method Invocation,plain_text
2583," 1 package com.test;
 2  
 3 import java.lang.reflect.Constructor;
 4 import java.lang.reflect.InvocationTargetException;
 5 import java.lang.reflect.Method;
 6  
 7 public class ReflectTest {
 8     public static void main(String[] args) {
 9         try {
10             Class<?> dummyClass = Class.forName(""com.test.DummyTo"");
11  
12             // parameter types for methods
13             Class<?>[] partypes = new Class[]{String.class};
14  
15             // Create method object. methodname and parameter types
16             Method meth = dummyClass.getMethod(""toString"", partypes);
17  
18             // parameter types for constructor
19             Class<?>[] constrpartypes = new Class[]{String.class, String.class};
20  
21             //Create constructor object. parameter types
22             Constructor<?> constr = dummyClass.getConstructor(constrpartypes);
23  
24             // create instance
25             Object dummyto = constr.newInstance(new Object[]{""Java Programmer"", ""India""});
26  
27             // Arguments to be passed into method
28             Object[] arglist = new Object[]{""I am""};
29  
30             // invoke method!!
31             String output = (String) meth.invoke(dummyto, arglist);
32             System.out.println(output);
33  
34         } catch (ClassNotFoundException e) {
35             e.printStackTrace();
36         } catch (SecurityException e) {
37             e.printStackTrace();
38         } catch (NoSuchMethodException e) {
39             e.printStackTrace();
40         } catch (IllegalArgumentException e) {
41             e.printStackTrace();
42         } catch (IllegalAccessException e) {
43             e.printStackTrace();
44         } catch (InvocationTargetException e) {
45             e.printStackTrace();
46         } catch (InstantiationException e) {
47             e.printStackTrace();
48         }
49     }
50 }
",Dynamic Method Invocation,code_fragment
2584,"Conclusion: Above examples demonstrate the invocation of method dynamically using reflection.
",Dynamic Method Invocation,plain_text
2585,"All features of a class can be obtained via reflection, including access to private methods & variables. But not always see [1].
Let us look at the following example:
",Accessing Private Features with Reflection,plain_text
2586,"1 public class Secret {
2   private String secretCode = ""It's a secret"";
3  
4   private String getSecretCode() {
5     return secretCode;     
6   }
7 }
",Accessing Private Features with Reflection,code_fragment
2587,"Although the field and method are marked private, the following class shows that it is possible to access the private features of a class:
",Accessing Private Features with Reflection,plain_text
2588," 1 import java.lang.reflect.Field;
 2 import java.lang.reflect.InvocationTargetException;
 3 import java.lang.reflect.Method;
 4  
 5 public class Hacker {
 6  
 7    private static final Object[] EMPTY = {};
 8  
 9    public void reflect() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
10      Secret instance = new Secret();
11      Class<?> secretClass = instance.getClass();
12  
13      // Print all the method names & execution result
14      Method methods[] = secretClass.getDeclaredMethods();
15      System.out.println(""Access all the methods"");
16      for (Method method : methods) {
17         System.out.println(""Method Name: "" + method.getName());
18         System.out.println(""Return type: "" + method.getReturnType());
19         method.setAccessible(true);
20         System.out.println(method.invoke(instance, EMPTY) + ""\n"");
21      }
22  
23      // Print all the field names & values
24      Field fields[] = secretClass.getDeclaredFields();
25      System.out.println(""Access all the fields"");
26      for (Field field : fields) {
27         System.out.println(""Field Name: "" + field.getName());
28         field.setAccessible(true);
29         System.out.println(field.get(instance) + ""\n"");
30      }
31   }
32  
33   public static void main(String[] args) {
34     Hacker newHacker = new Hacker();
35  
36     try {
37       newHacker.reflect();
38     } catch (Exception e) {
39       e.printStackTrace();
40     }
41   }
42 }
",Accessing Private Features with Reflection,code_fragment
2589,"JUnit's are unit test cases, used to test the Java programs. Now you know how to test a private method using Reflection in JUnit.
There's a long-standing debate on whether testing private members is a good habit[1];There are cases where you want to make sure a class exhibited the right behavior while not making the fields that need checking to assert that public (as it's generally considered bad practice to create accessors to a class just for the sake of a unit test). There are also cases when you can greatly simplify a test case by using reflection to test all smaller private methods (and their various branches), then test the main function. 
With dp4j it is possible to test private members without directly using the Reflection API but simply accessing them as if they were accessible from the testing method; dp4j injects the needed Reflection code at compile-time[2].
",Accessing Private Features with Reflection,plain_text
2590,"Prior to modern networking solutions there existed workstations that were connected to a massive Mainframe computer that was solely responsible for memory management, processes and almost everything. The workstations would just render the information sent in from the Mainframe console.
",Networking,plain_text
2591,"But in the mid 90's, with the prices of Unix servers dropping, the trend was moving away from Mainframe computing toward Client-Server computing. This would enable rich clients to be developed on workstations while they would communicate with a centralized server, serving computers connected to it, to either communicate with other workstations also connected to it or it would request for database access or business logic stored on the server itself. The workstations were called clients.
",Networking,plain_text
2592,"This form of computing gave rise to the notion of the Front-end and Back-end programming. In it's hey-day, Java came up with different ways of making networking between computers possible. In this chapter, we would be looking at some of these ways. Listed below are two of the frameworks that Java uses to enable network programming. We would be exploring both of these in this chapter.
",Networking,plain_text
2593,"
",Networking,plain_text
2594,,Connecting to Microsoft Access databases[edit],
2595,"The following is used to open an ODBC connection to an Access database.  Note that the username (and password, if applicable) are given in the DSN rather than the getConnection call.  This is a MS Windows-only example, due to the requirement for the Microsoft Access Driver.
",Connecting to Microsoft Access databases[edit],plain_text
2596,,Connecting to MySQL[edit],
2597,,Connecting to Oracle Database[edit],
2598,"This script returns the database size:
",Connecting to Oracle Database[edit],plain_text
2599,,Connecting to PostgreSQL[edit],
2600,,Known errors[edit],
2601,"If you have Oracle Database on your PC, just add to the classpath its following files[3]:
",Known errors[edit],plain_text
2602,"C:\oracle12\app\oracle\product\12.1.0\dbhome_1\jdbc\lib\ojdbc7.jar
C:\oracle12\app\oracle\product\12.1.0\dbhome_1\sqlj\lib\runtime12.jar",Known errors[edit],plain_text
2603,"Otherwise, ojdbc7.jar can be downloaded from http://www.oracle.com/technetwork/database/features/jdbc/jdbc-drivers-12c-download-1958347.html, and add it to the compilation. Eg:
",Known errors[edit],plain_text
2604,"javac MyClass.java -classpath ojdbc7.jar
",Known errors[edit],plain_text
2605,"Just add "" as sysdba"" after your Oracle account name, eg:
",Known errors[edit],plain_text
2606,"Connection conn = DriverManager.getConnection(""jdbc:oracle:thin:@localhost:1521:MyDatabase"", ""MyAccount as sysdba"",
",Known errors[edit],plain_text
2607,,References[edit],
2608,"
The regular expressions (regex) are provided by the package java.util.regex.
",Regular Expressions,plain_text
2609,,Researches[edit],
2610,"The Pattern class offers the function matches which returns true if an expression is found into a string.
",Researches[edit],plain_text
2611,"For example, this script returns the unknown word preceding a known word:
",Researches[edit],plain_text
2612,"
The Matcher class allows to get all matches for a given expression, with different methods:
",Researches[edit],plain_text
2613,"For example, this script displays the HTML b tags contents:
",Researches[edit],plain_text
2614,,Replacements[edit],
2615,,"Libraries, Extensions, and Frameworks[edit]",
2616,"Math and Geometry 
Regular Expressions 
Security 
Input and Output 
Logging 
Database Connectivity 
Zip and Other Archives 
XML 
Graphical User Interfaces 
Open Source 
Struts 
Spring framework","Libraries, Extensions, and Frameworks[edit]",plain_text
2617,,3D graphics Java libraries[edit],
2618,"Java 3D
JOGL
JPCT
Light Weight Java Game Library",3D graphics Java libraries[edit],plain_text
2619,"
The Java Native Interface (JNI) enables Java code running in a Java Virtual Machine (JVM) to call and to be called by native applications (programs specific to a hardware and operating system platform) and libraries written in other languages, such as C, C++ and assembly.
",Java Native Interface,plain_text
2620,"JNI can be used:
",Java Native Interface,plain_text
2621,"To implement or use features that are platform-specific.
To implement or use features that the standard Java class library does not support.
To enable an existing application—written in another programming language—to be accessible to Java applications.
To let a native method use Java objects in the same way that Java code uses these objects (a native method can create Java objects and then inspect and use these objects to perform its tasks).
To let a native method inspect and use objects created by Java application code.
For time-critical calculations or operations like solving complicated mathematical equations (native code may be faster than JVM code).",Java Native Interface,plain_text
2622,"On the other hand, an application that relies on JNI loses the platform portability Java offers. So you will have to write a separate implementation of JNI code for each platform and have Java detect the operating system and load the correct one at runtime. Many of the standard library classes depend on JNI to provide functionality to the developer and the user (file I/O, sound capabilities...). Including performance- and platform-sensitive API implementations in the standard library allows all Java applications to access this functionality in a safe and platform-independent manner. Only applications and signed applets can invoke JNI. JNI should be used with caution. Subtle errors in the use of JNI can destabilize the entire JVM in ways that are very difficult to reproduce and debug. Error checking is a must or it has the potential to crash the JNI side and the JVM.
",Java Native Interface,plain_text
2623,"This page will only explain how to call native code from JVM, not how to call JVM from native code.
",Java Native Interface,plain_text
2624,,Calling native code from JVM[edit],
2625,"In the JNI framework, native functions are implemented in separate .c or .cpp files. C++ provides a slightly simpler interface with JNI. When the JVM invokes the function, it passes a JNIEnv pointer, a jobject pointer, and any Java arguments declared by the Java method. A JNI function may look like this:
",Calling native code from JVM[edit],plain_text
2626,"The env pointer is a structure that contains the interface to the JVM.  It includes all of the functions necessary to interact with the JVM and to work with Java objects.  Example JNI functions are converting native arrays to/from Java arrays, converting native strings to/from Java strings, instantiating objects, throwing exceptions, etc.  Basically, anything that Java code can do can be done using JNIEnv, albeit with considerably less ease.
",Calling native code from JVM[edit],plain_text
2627,"On Linux and Solaris platforms, if the native code registers itself as a signal handler, it could intercept signals intended for the JVM.  Signal chaining should be used to allow native code to better interoperate with JVM. On Windows platforms, Structured Exception Handling (SEH) may be employed to wrap native code in SEH try/catch blocks so as to capture machine (CPU/FPU) generated software interrupts (such as NULL pointer access violations and divide-by-zero operations), and to handle these situations before the interrupt is propagated back up into the JVM (i.e. Java side code), in all likelihood resulting in an unhandled exception.
",Calling native code from JVM[edit],plain_text
2628,"For example, the following converts a Java string to a native string:
",Calling native code from JVM[edit],plain_text
2629,"The JNI framework does not provide any automatic garbage collection for non-JVM memory resources allocated by code executing on the native side. Consequently, native side code (such as C, C++, or assembly language) must assume the responsibility for explicitly releasing any such memory resources that it itself acquires.
",Calling native code from JVM[edit],plain_text
2630,"Note that C++ JNI code is syntactically slightly cleaner than C JNI code because like Java, C++ uses object method invocation semantics.  That means that in C, the env parameter is dereferenced using (*env)-> and env has to be explicitly passed to JNIEnv methods. In C++, the env parameter is dereferenced using env-> and the env parameter is implicitly passed as part of the object method invocation semantics.
",Calling native code from JVM[edit],plain_text
2631,"JNI also allows direct access to assembly code, without even going through a C bridge.
",Calling native code from JVM[edit],plain_text
2632,"Native data types can be mapped to/from Java data types. For compound types such as objects, arrays and strings the native code must explicitly convert the data by calling methods in the JNIEnv. The following table shows the mapping of types between Java (JNI) and native code.
",Calling native code from JVM[edit],plain_text
2633,"In addition, the signature ""L fully-qualified-class ;"" would mean the class uniquely specified by that name; e.g., the signature ""Ljava/lang/String;"" refers to the class java.lang.String. Also, prefixing [ to the signature makes the array of that type; for example, [I means the int array type. Finally, a void signature uses the V code.
Here, these types are interchangeable. You can use jint where you normally use an int, and vice-versa, without any typecasting required.
",Calling native code from JVM[edit],plain_text
2634,"However, mapping between Java Strings and arrays to native strings and arrays is different. If you use a jstring in where a char * would be, your code could crash the JVM.
",Calling native code from JVM[edit],plain_text
2635,"The encoding used for the NewStringUTF, GetStringUTFLength, GetStringUTFChars, ReleaseStringUTFChars, GetStringUTFRegion functions is not standard UTF-8, but modified UTF-8. The null character (U+0000) and codepoints greater than or equal to U+10000 are encoded differently in modified UTF-8. Many programs actually use these functions incorrectly and treat the UTF-8 strings returned or passed into the functions as standard UTF-8 strings instead of modified UTF-8 strings. Programs should use the NewString, GetStringLength, GetStringChars, ReleaseStringChars, GetStringRegion, GetStringCritical, and ReleaseStringCritical functions, which use UTF-16LE encoding on little-endian architectures and UTF-16BE on big-endian architectures, and then use a UTF-16 to standard UTF-8 conversion routine.
",Calling native code from JVM[edit],plain_text
2636,"The code is similar with Java arrays, as illustrated in the example below that takes the sum of all the elements in an array.
",Calling native code from JVM[edit],plain_text
2637,"Of course, there is much more to it than this.
",Calling native code from JVM[edit],plain_text
2638,"A JNI environment pointer (JNIEnv*) is passed as an argument for each native function mapped to a Java method, allowing for interaction with the JNI environment within the native method. This JNI interface pointer can be stored, but remains valid only in the current thread. Other threads must first call AttachCurrentThread() to attach themselves to the VM and obtain a JNI interface pointer. Once attached, a native thread works like a regular Java thread running within a native method. The native thread remains attached to the VM until it calls DetachCurrentThread() to detach itself.
",Calling native code from JVM[edit],plain_text
2639,"To attach to the current thread and get a JNI interface pointer:
",Calling native code from JVM[edit],plain_text
2640,"JNIEnv *env;
(*g_vm)->AttachCurrentThread (g_vm, (void **) &env, NULL);
",Calling native code from JVM[edit],plain_text
2641,"To detach from the current thread:
",Calling native code from JVM[edit],plain_text
2642,"(*g_vm)->DetachCurrentThread (g_vm);
",Calling native code from JVM[edit],plain_text
2643,,HelloWorld[edit],
2644," 1 public class HelloWorld {
 2  private native void print();
 3 
 4  public static void main(String[] args) {
 5   new HelloWorld().print();
 6  }
 7 
 8  static {
 9   System.loadLibrary(""HelloWorld"");
10  }
11 }
",HelloWorld[edit],code_fragment
2645,"HelloWorld.h
",HelloWorld[edit],plain_text
2646,"libHelloWorld.c
",HelloWorld[edit],plain_text
2647,"make.sh
",HelloWorld[edit],plain_text
2648,,Advanced uses[edit],
2649,"Not only can native code interface with Java, it can also draw on a  Java API: java.awt.Canvas, which is possible with the Java AWT Native Interface. The process is almost the same, with just a few changes. The Java AWT Native Interface is only available since J2SE 1.3.
",Advanced uses[edit],plain_text
2650,"
",Advanced uses[edit],plain_text
2651,"
You can use Runtime.exec() method to invoke a program from within a running Java application. Runtime.exec() also allows you to perform operations related to the program, such as control the program's standard input and output, wait until it completes execution, and get its exit status.
",Invoking C,plain_text
2652,"Here's a simple C application that illustrates these features. This C program will be called from Java:
",Invoking C,plain_text
2653,"This application writes a string ""testing"" to standard output, and then terminates with an exit status of 0.
To execute this simple program within a Java application, compile the C application:
",Invoking C,plain_text
2654,"Then invoke the C program using this Java code:
",Invoking C,plain_text
2655," 1 import java.io.InputStream;
 2 import java.io.BufferedReader;
 3 import java.io.InputStreamReader;
 4 import java.io.IOException;
 5 import java.io.InterruptedException;
 6 import java.io.Process;
 7 import java.io.Runtime;
 8 
 9 import java.util.ArrayList;
10 
11 public class ExecDemo {
12     public static String[] runCommand(String cmd) throws IOException {
13         // --- set up list to capture command output lines ---
14         ArrayList list = new ArrayList();
15 
16         // --- start command running
17         Process proc = Runtime.getRuntime().exec(cmd);
18 
19         // --- get command's output stream and
20         // put a buffered reader input stream on it ---
21         InputStream istr = proc.getInputStream();
22         BufferedReader br = new BufferedReader(new InputStreamReader(istr));
23 
24         // --- read output lines from command
25         String str;
26         while ((str = br.readLine()) != null) {
27             list.add(str);
28         }
29 
30         // wait for command to terminate
31         try {
32             proc.waitFor();
33         }
34         catch (InterruptedException e) {
35             System.err.println(""process was interrupted"");
36         }
37 
38         // check its exit value
39         if (proc.exitValue() != 0) {
40             System.err.println(""exit value was non-zero"");
41         }
42 
43         // close stream
44         br.close();
45 
46         // return list of strings to caller
47         return (String[])list.toArray(new String[0]);
48     }
49 
50     public static void main(String args[]) throws IOException {
51         try {
52 
53             // run a command
54             String outlist[] = runCommand(""test"");
55 
56             // display its output
57             for (int i = 0; i < outlist.length; i++)
58                 System.out.println(outlist[i]);
59         }
60         catch (IOException e) {
61             System.err.println(e);
62         }
63     }
64 }
",Invoking C,code_fragment
2656,"The demo calls a method runCommand to actually run the program.
",Invoking C,plain_text
2657,"1 String outlist[] = runCommand(""test"");
",Invoking C,code_fragment
2658,"This method hooks an input stream to the program's output stream, so that it can read the program's output, and save it into a list of strings.
",Invoking C,plain_text
2659,"1 InputStream istr = proc.getInputStream();
2 BufferedReader br = new BufferedReader(new InputStreamReader(istr));
3              
4 String str;
5 while ((str = br.readLine()) != null) {
6     list.add(str);
7 }
",Invoking C,code_fragment
2660,,Migrating C to Java[edit],
2661,"Tools exist to aid the migration of existing projects from C to Java. In general, automated translator tools fall into one of two distinct kinds:
",Migrating C to Java[edit],plain_text
2662,"One kind converts C code to Java byte code. It is basically a compiler that creates byte code. It has the same steps as any other C compiler. See also C to Java JVM compilers.
The other kind translates C code to Java source code. This type is more complicated and uses various syntax rules to create readable Java source code. This option is best for those who want to move their C code to Java and stay in Java.",Migrating C to Java[edit],plain_text
2663,"
",Migrating C to Java[edit],plain_text
2664,"
Java Byte Code is the language to which Java source is compiled and the Java Virtual Machine understands. Unlike compiled languages that have to be specifically compiled for each different type of computers, a Java program only needs to be converted to byte code once, after which it can run on any platform for which a Java Virtual Machine exists. 
",Byte Code,plain_text
2665,"Bytecode is the compiled format for Java programs. Once a Java program has been converted to bytecode, it can be transferred across a network and executed by Java Virtual Machine (JVM). Bytecode files generally have a .class extension. 
It is not normally necessary for a Java programmer to know byte code, but it can be useful.
",Byte Code,plain_text
2666,,Other Languages[edit],
2667,"There are a number of exciting new languages being created that also compile to Java byte code, such as Groovy.
",Other Languages[edit],plain_text
2668,"
",Other Languages[edit],plain_text
2669,,Example[edit],
2670,"Consider the following Java code.
",Example[edit],plain_text
2671,"A Java compiler might translate the Java code above into byte code as follows, assuming the above was put in a method:
",Example[edit],plain_text
2672,"
",Example[edit],plain_text
2673,"
",Example[edit],plain_text
2674,,Example 2[edit],
2675,"As an example we can write a simple Foo.java source:
",Example 2[edit],plain_text
2676,"Compile it and then move Foo.java to another directory or delete it if you wish. What can we do with javap and Foo.class ?
",Example 2[edit],plain_text
2677,"$javap Foo
",Example 2[edit],plain_text
2678,"produces this result:
",Example 2[edit],plain_text
2679,"Compiled from ""Foo.java""
public class Foo extends java.lang.Object {
    public Foo();
    public static void main(java.lang.String[]);
    public static void a();
    public static void b();
}
",Example 2[edit],plain_text
2680,"As you can see the javac compiler doesn't strip any (public) variable name from the .class file. As a result the names of the functions, their parameters and types of return are exposed. (This is necessary in order for other classes to access them.)
",Example 2[edit],plain_text
2681,"Let's do a bit more, try:
",Example 2[edit],plain_text
2682,"$javap -c Foo
",Example 2[edit],plain_text
2683,"Compiled from ""Foo.java""
public class Foo extends java.lang.Object{
public Foo();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object.""<init>"":()V
   4:   return

public static void main(java.lang.String[]);
  Code:
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc             #3; //String This is a simple example of decompilation using javap
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   invokestatic    #5; //Method a:()V
   11:  invokestatic    #6; //Method b:()V
   14:  return

public static void a();
  Code:
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc             #7; //String Now we are calling a function...
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   return

public static void b();
  Code:
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc             #8; //String ...and now we are calling b
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   return

}
",Example 2[edit],plain_text
2684,,The Java bytecodes[edit],
2685,"See Oracle's Java Virtual Machine Specification[1] for more detailed descriptions
",The Java bytecodes[edit],plain_text
2686,"The manipulation of the operand stack is notated as [before]→[after], where [before] is the stack before the instruction is executed and [after] is the stack after the instruction is executed. A stack with the element 'b' on the top and element 'a' just after the top element is denoted 'a,b'.
",The Java bytecodes[edit],plain_text
2687,,References[edit],
2688,,External Links[edit],
2689,"Bytecode Visualizer - free Eclipse plugin for visualizing and debugging Java bytecode
Bytecode Outline plugin for Eclipse by ObjectWeb
Easy illustration to fill the gap between JVM, its purpose and advantages vs JIT Compiling",External Links[edit],plain_text
2690,"
",External Links[edit],plain_text
2691,comp.lang.java (Google's web interface),Links,plain_text
2692,"
",Links,plain_text
2693,,A[edit],
2694,,B[edit],
2695,,G[edit],
2696,,P[edit],
2697,,R[edit],
2698,"
",R[edit],plain_text
2699,"
",Index,plain_text